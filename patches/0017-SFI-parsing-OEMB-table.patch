From a19d78c5001fc4b266c46fb7b388d7634a7c023b Mon Sep 17 00:00:00 2001
From: Fei Yang <fei.yang@intel.com>
Date: Tue, 25 Jun 2013 15:10:39 -0700
Subject: [PATCH 017/429] SFI: parsing OEMB table

OEMB table is being used for intel mid platforms providing information
such as IA firmware version, spid.

Signed-off-by: Fei Yang <fei.yang@intel.com>
---
 arch/x86/include/asm/intel-mid.h            |  34 ++
 arch/x86/include/asm/spid.h                 | 497 ++++++++++++++++++++
 arch/x86/platform/intel-mid/intel_mid_sfi.c | 216 ++++++++-
 include/linux/sfi.h                         |   4 +
 4 files changed, 750 insertions(+), 1 deletion(-)
 create mode 100644 arch/x86/include/asm/spid.h

diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h
index 0e6a2d1586b5..ccf480cf7bfe 100644
--- a/arch/x86/include/asm/intel-mid.h
+++ b/arch/x86/include/asm/intel-mid.h
@@ -14,6 +14,12 @@
 #include <linux/sfi.h>
 #include <linux/pci.h>
 #include <linux/platform_device.h>
+#include <asm/spid.h>
+
+#define INTEL_MID_SSN_SIZE	32
+
+extern struct soft_platform_id spid;
+extern char intel_mid_ssn[INTEL_MID_SSN_SIZE + 1];
 
 #ifdef CONFIG_SFI
 extern int get_gpio_by_name(const char *name);
@@ -31,6 +37,25 @@ extern int __init sfi_parse_mtmr(struct sfi_table_header *table);
 extern int sfi_mrtc_num;
 extern struct sfi_rtc_table_entry sfi_mrtc_array[];
 
+/* OEMB table */
+struct sfi_table_oemb {
+	struct sfi_table_header header;
+	u32 board_id;
+	u32 board_fab;
+	u8 iafw_major_version;
+	u8 iafw_main_version;
+	u8 val_hooks_major_version;
+	u8 val_hooks_minor_version;
+	u8 ia_suppfw_major_version;
+	u8 ia_suppfw_minor_version;
+	u8 scu_runtime_major_version;
+	u8 scu_runtime_minor_version;
+	u8 ifwi_major_version;
+	u8 ifwi_minor_version;
+	struct soft_platform_id spid;
+	u8 ssn[INTEL_MID_SSN_SIZE];
+} __packed;
+
 /*
  * Here defines the array of devices platform data that IAFW would export
  * through SFI "DEVS" table, we use name and type to match the device and
@@ -102,6 +127,15 @@ enum intel_mid_timer_options {
 
 extern enum intel_mid_timer_options intel_mid_timer_options;
 
+#define spid_attr(_name) \
+static struct kobj_attribute _name##_attr = { \
+	.attr = {                             \
+		.name = __stringify(_name),   \
+		.mode = 0444,                 \
+	},                                    \
+	.show   = _name##_show,               \
+}
+
 /*
  * Penwell uses spread spectrum clock, so the freq number is not exactly
  * the same as reported by MSR based on SDM.
diff --git a/arch/x86/include/asm/spid.h b/arch/x86/include/asm/spid.h
new file mode 100644
index 000000000000..900edf8d559d
--- /dev/null
+++ b/arch/x86/include/asm/spid.h
@@ -0,0 +1,497 @@
+/*
+ * spid.h: Intel MID software platform ID definitions
+ *
+ * (C) Copyright 2012 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _ASM_X86_SPID_H
+#define _ASM_X86_SPID_H
+
+struct soft_platform_id {
+	u16 customer_id; /*Defines the final customer for the product */
+	u16 vendor_id; /* Defines who owns the final product delivery */
+	u16 manufacturer_id; /* Defines who build the hardware. This can be
+			      * different for the same product */
+	u16 platform_family_id; /* Defined by vendor and defines the family of
+				 * the product with the same root components */
+	u16 product_line_id; /* Defined by vendor and defines the name of the
+			      * product. This can be used to differentiate the
+			      * feature set for the same product family (low
+			      * cost vs full feature). */
+	u16 hardware_id; /* Defined by vendor and defines the physical hardware
+			  * component set present on the PCB/FAB */
+	u8  fru[SPID_FRU_SIZE]; /* Field Replaceabl Unit */
+} __packed;
+
+/* Customer_ID table */
+enum {
+	CUSTOMER_INTEL,
+	CUSTOMER_INTEL_RSVD1,
+	CUSTOMER_INTEL_RSVD2,
+	CUSTOMER_INTEL_RSVD3,
+	CUSTOMER_INTEL_RSVD4,
+	CUSTOMER_INTEL_RSVD5,
+	CUSTOMER_INTEL_RSVD6,
+	CUSTOMER_RSVD,
+	CUSTOMER_UNKNOWN = 0xFFFF
+};
+
+/* Vendor_ID table */
+enum {
+	VENDOR_INTEL,
+	VENDOR_INTEL_RSVD1,
+	VENDOR_INTEL_RSVD2,
+	VENDOR_INTEL_RSVD3,
+	VENDOR_INTEL_RSVD4,
+	VENDOR_INTEL_RSVD5,
+	VENDOR_INTEL_RSVD6,
+	VENDOR_RSVD,
+	VENDOR_UNKNOWN = 0xFFFF
+};
+
+/* Manufacturer_ID table for Vendor_ID == VENDOR_INTEL */
+enum {
+	MANUFACTURER_FAB1,
+	MANUFACTURER_FAB2,
+	MANUFACTURER_FAB3,
+	MANUFACTURER_FAB4,
+	MANUFACTURER_FAB5,
+	MANUFACTURER_FAB6,
+	MANUFACTURER_FAB7,
+	MANUFACTURER_FAB8,
+	MANUFACTURER_FAB9,
+	MANUFACTURER_RSVD,
+	MANUFACTURER_UNKNOWN = 0xFFFF
+};
+
+/* Platform_Family_ID table for Vendor_ID == VENDOR_INTEL */
+enum {
+	INTEL_MFLD_PHONE  = 0x0000,
+	INTEL_MFLD_TABLET = 0x0001,
+	INTEL_CLVTP_PHONE = 0x0002,
+	INTEL_CLVT_TABLET = 0x0003,
+	INTEL_MRFL_PHONE  = 0x0004,
+	INTEL_MRFL_TABLET = 0x0005,
+	INTEL_BYT_PHONE   = 0x0006,
+	INTEL_BYT_TABLET  = 0x0007,
+	INTEL_MOOR_PHONE  = 0x0008,
+	INTEL_MOOR_TABLET = 0x0009,
+	INTEL_PLATFORM_UNKNOWN = 0xFFFF
+};
+
+/* Product_Line_ID table for Platform_Family_ID == INTEL_MFLD_PHONE */
+enum {
+	INTEL_MFLD_PHONE_BB15_PRO = 0x0000,
+	INTEL_MFLD_PHONE_BB15_ENG = 0x8000,
+	INTEL_MFLD_PHONE_BB20_PRO = 0x0001,
+	INTEL_MFLD_PHONE_BB20_ENG = 0x8001,
+	INTEL_MFLD_PHONE_OR_PRO   = 0x0002,
+	INTEL_MFLD_PHONE_OR_ENG   = 0x8002,
+	INTEL_MFLD_PHONE_AT_PRO   = 0x0003,
+	INTEL_MFLD_PHONE_AT_ENG   = 0x8003,
+	INTEL_MFLD_PHONE_LEX_PRO  = 0x0004,
+	INTEL_MFLD_PHONE_LEX_ENG  = 0x8004,
+	INTEL_MFLD_PHONE_UNKNOWN  = 0xFFFF
+};
+
+/* Product_Line_ID table for Platform_Family_ID == INTEL_MFLD_TABLET */
+enum {
+	INTEL_MFLD_TABLET_RR_PRO  = 0x0000,
+	INTEL_MFLD_TABLET_RR_ENG  = 0x8000,
+	INTEL_MFLD_TABLET_FM_PRO  = 0x0001,
+	INTEL_MFLD_TABLET_FM_ENG  = 0x8001,
+	INTEL_MFLD_TABLET_FVA_PRO = 0x0002,
+	INTEL_MFLD_TABLET_FVA_ENG = 0x8002,
+	INTEL_MFLD_TABLET_SLP_PRO = 0x0003,
+	INTEL_MFLD_TABLET_SLP_ENG = 0x8003,
+	INTEL_MFLD_TABLET_YKB_PRO = 0x0004,
+	INTEL_MFLD_TABLET_YKB_ENG = 0x8004,
+	INTEL_MFLD_TABLET_UNKNOWN = 0xFFFF
+};
+
+/* Product_Line_ID table for Platform_Family_ID == INTEL_CLVTP_PHONE */
+enum {
+	INTEL_CLVTP_PHONE_RHB_PRO = 0x0000,
+	INTEL_CLVTP_PHONE_RHB_ENG = 0x8000,
+	INTEL_CLVTP_PHONE_VB_PRO  = 0x0001,
+	INTEL_CLVTP_PHONE_VB_ENG  = 0x8001,
+	INTEL_CLVTP_PHONE_UNKNOWN = 0xFFFF
+};
+
+/* Product_Line_ID table for Platform_Family_ID == INTEL_CLVT_TABLET */
+enum {
+	INTEL_CLVT_TABLET_TBD_PRO = 0x0000,
+	INTEL_CLVT_TABLET_TBD_ENG = 0x8000,
+	INTEL_CLVT_TABLET_SLP_PRO = 0x0001,
+	INTEL_CLVT_TABLET_SLP_ENG = 0x8001,
+	INTEL_CLVT_TABLET_UNKNOWN = 0xFFFF
+};
+
+/* Product_Line_ID table for Platform_Family_ID == INTEL_MRFL_PHONE */
+enum {
+	INTEL_MRFL_PHONE_SB_PRO = 0x0000,
+	INTEL_MRFL_PHONE_SB_ENG = 0x8000,
+	INTEL_MRFL_PHONE_BB_PRO = 0x0001,
+	INTEL_MRFL_PHONE_BB_ENG = 0x8001,
+	INTEL_MRFL_PHONE_UNKNOWN = 0xFFFF
+};
+
+/* Product_Line_ID table for Platform_Family_ID == INTEL_MRFL_TABLET */
+enum {
+	INTEL_MRFL_TABLET_TBD_PRO = 0x0000,
+	INTEL_MRFL_TABLET_TBD_ENG = 0x8000,
+	INTEL_MRFL_TABLET_UNKNOWN = 0xFFFF
+};
+
+/* Product_Line_ID table for Platform_Family_ID == INTEL_BYT_PHONE */
+enum {
+	INTEL_BYT_PHONE_TBD_PRO = 0x0000,
+	INTEL_BYT_PHONE_TBD_ENG = 0x8000,
+	INTEL_BYT_PHONE_UNKNOWN = 0xFFFF
+};
+
+/* Product_Line_ID table for Platform_Family_ID == INTEL_BYT_TABLET */
+enum {
+	INTEL_BYT_TABLET_BLK_PRO = 0x0000,
+	INTEL_BYT_TABLET_BLK_ENG = 0x8000,
+	INTEL_BYT_TABLET_BLB_PRO = 0x0001,
+	INTEL_BYT_TABLET_BLB_ENG = 0x8001,
+	INTEL_BYT_TABLET_UNKNOWN = 0xFFFF
+};
+
+/* Product_Line_ID table for Platform_Family_ID == INTEL_MOOR_PHONE */
+enum {
+	INTEL_MOOR_PHONE_FRCB_PRO = 0x0000,
+	INTEL_MOOR_PHONE_FRCB_ENG = 0x8000,
+	INTEL_MOOR_PHONE_UNKNOWN = 0xFFFF
+};
+
+/* Product_Line_ID table for Platform_Family_ID == INTEL_MOOR_TABLET */
+enum {
+	INTEL_MOOR_TABLET_TBD_PRO = 0x0000,
+	INTEL_MOOR_TABLET_TBD_ENG = 0x8000,
+	INTEL_MOOR_TABLET_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MFLD_PHONE_BB15 */
+enum {
+	MFLD_PHONE_BB15_PR20, /* CRAK C0 */
+	MFLD_PHONE_BB15_PR31, /* CRAK D0 */
+	MFLD_PHONE_BB15_PR32, /* CRAK D0 */
+	MFLD_PHONE_BB15_PR33, /* CRAK D1 - 1.6GHz */
+	MFLD_PHONE_BB15_PR34, /* CRAK D1 - 1.6GHz, alt eMMC, DDR2 */
+	MFLD_PHONE_BB15_PR35, /* CRAK D1 - 1.6GHz, alt eMMC, DDR2 */
+	MFLD_PHONE_BB15_PR36, /* CRAK D1 - 1.6GHz, alt eMMC, DDR2, MSIC C2 */
+	MFLD_PHONE_BB15_PR40, /* CRAK D1 - 2.0GHz */
+	MFLD_PHONE_BB15_PR2A,
+	MFLD_PHONE_BB15_PR3A,
+	MFLD_PHONE_BB15_PR3B,
+	MFLD_PHONE_BB15_4MVV,
+	MFLD_PHONE_BB15_4MSV,
+	MFLD_PHONE_BB15_ICDK,
+	MFLD_PHONE_BB15_4MVV3,
+	MFLD_PHONE_BB15_RSVD,
+	MFLD_PHONE_BB15_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MFLD_PHONE_BB20 */
+enum {
+	MFLD_PHONE_BB20_TBD,
+	MFLD_PHONE_BB20_RSVD,
+	MFLD_PHONE_BB20_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MFLD_PHONE_OR */
+enum {
+	MFLD_PHONE_OR_NHDV1,    /* CRAK D0 - 1.6G */
+	MFLD_PHONE_OR_NHDV2,    /* CRAK D1 - 1.6G */
+	MFLD_PHONE_OR_NHDV3,    /* CRAK D1 - 1.6G */
+	MFLD_PHONE_OR_NHDV31R,  /* CRAK D1 - 1.6G */
+	MFLD_PHONE_OR_NHDV31A,  /* CAAK D1 - 1.6G */
+	MFLD_PHONE_OR_NHDV30F,  /* CRAK D1 - 2.0G */
+	MFLD_PHONE_OR_NHDV31A1, /* CAAK D1 - 2.0G */
+	MFLD_PHONE_OR_NHDV30D,  /* CRAK D2 - 1.6G */
+	MFLD_PHONE_OR_NHDV30G,  /* CRAK D2 - 2.0G */
+	MFLD_PHONE_OR_NHDV31A2, /* CAAK D2 - 1.6G */
+	MFLD_PHONE_OR_NHDV31A3, /* CAAK D2 - 2.0G */
+	MFLD_PHONE_OR_NHDV30E,  /* CRAK D1, Samsung eMMC for part quals */
+	MFLD_PHONE_OR_RSVD,
+	MFLD_PHONE_OR_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MFLD_PHONE_AT */
+enum {
+	MFLD_PHONE_AT_LA, /* CAAK D1 */
+	MFLD_PHONE_AT_LA_RSVD,
+	MFLD_PHONE_AT_LA_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MFLD_PHONE_LEX */
+enum {
+	MFLD_PHONE_LEX_PR11, /* RYS/PNW 1GHz CREK D1 */
+	MFLD_PHONE_LEX_PR1M, /* RYS/PNW 1GHz CREK D1 */
+	MFLD_PHONE_LEX_PR21, /* RYS/PNW 1GHz CSEK D1 */
+	MFLD_PHONE_LEX_PR2M, /* BND/PNW 1GHz CSEK D1 */
+	MFLD_PHONE_LEX_DV1,  /* BND/PNW 1.2GHz CSEK D1 */
+	MFLD_PHONE_LEX_RSVD,
+	MFLD_PHONE_LEX_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MFLD_TABLET_RR */
+enum {
+	MFLD_TABLET_RR_DV10, /* CRAK D0 */
+	MFLD_TABLET_RR_DV15, /* CRAK D0/D1 */
+	MFLD_TABLET_RR_DV20, /* CRAK D1 */
+	MFLD_TABLET_RR_DV21, /* CRAK D1 */
+	MFLD_TABLET_RR_RSVD,
+	MFLD_TABLET_RR_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MFLD_TABLET_FM */
+enum {
+	MFLD_TABLET_FM_EV20, /* CRAK D0 */
+	MFLD_TABLET_FM_DV10, /* CRAK D1 */
+	MFLD_TABLET_FM_RSVD,
+	MFLD_TABLET_FM_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MFLD_TABLET_FVA */
+enum {
+	MFLD_TABLET_FVA_EV10P, /* CRAK Dx */
+	MFLD_TABLET_FVA_EV10,  /* CRAK Dx */
+	MFLD_TABLET_FVA_EV20,  /* CRAK Dx */
+	MFLD_TABLET_FVA_DV10,  /* CRAK Dx */
+	MFLD_TABLET_FVA_RSVD,
+	MFLD_TABLET_FVA_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MFLD_TABLET_SLP */
+enum {
+	MFLD_TABLET_SLP_EV05,  /* CRAK Dx */
+	MFLD_TABLET_SLP_EV10,  /* CRAK Dx */
+	MFLD_TABLET_SLP_EV20,  /* CRAK Dx */
+	MFLD_TABLET_SLP_DV10,  /* CRAK Dx */
+	MFLD_TABLET_SLP_EVL10, /* CRAK Dx */
+	MFLD_TABLET_SLP_EVL20, /* CRAK Dx */
+	MFLD_TABLET_SLP_DVL10, /* CRAK Dx */
+	MFLD_TABLET_SLP_RSVD,
+	MFLD_TABLET_SLP_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MFLD_TABLET_YKB */
+enum {
+	MFLD_TABLET_YKB_DV10, /* CRAK Dx */
+	MFLD_TABLET_YKB_RSVD,
+	MFLD_TABLET_YKB_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_CLVTP_PHONE_RHB */
+enum {
+	CLVTP_PHONE_RHB_CCVV0,  /* Clover City VV0 FAB A CLV/CLV+ A0*/
+	CLVTP_PHONE_RHB_CCVV1,  /* Clover City VV1 FAB B CLV+ A0*/
+	CLVTP_PHONE_RHB_CCVV2,  /* Clover City VV2 FAB C CLV+ A0*/
+	CLVTP_PHONE_RHB_CLEV,   /* Clover Lake CRB EV */
+	CLVTP_PHONE_RHB_PR01,   /* RHB PR0.1 CLV A0 C-CLASS */
+	CLVTP_PHONE_RHB_PR02,   /* RHB PR0.2 CLV A0 C-CLASS */
+	CLVTP_PHONE_RHB_PR10PM, /* CLV+ A0 */
+	CLVTP_PHONE_RHB_CCVV1P, /* Clover City Pre-VV1 Fab B CLV+ A0 */
+	CLVTP_PHONE_RHB_PR10P,  /* RHB Pre-PR1.0 CLV A0 C- CLASS */
+	CLVTP_PHONE_RHB_PR10M,  /* RHB Macro PR1.0 CLV+ A0 */
+	CLVTP_PHONE_RHB_PR10,   /* RHB PR1.0 CLV+ A0 C-CLASS */
+	CLVTP_PHONE_RHB_PR15M,  /* RHB Macro PR1.5 CLV+ A0 */
+	CLVTP_PHONE_RHB_PR15,   /* RHB PR1.5 CLV+ A0 C-CLASS */
+	CLVTP_PHONE_RHB_PR20M,  /* RHB Macro PR2.0 CLV+ B0 */
+	CLVTP_PHONE_RHB_PR20,   /* RHB PR2.0 CLV+ B0 C-CLASS */
+	CLVTP_PHONE_RHB_PR30M,  /* RHB Macro PR3.0 CLV+ B0 */
+	CLVTP_PHONE_RHB_CCVV3,  /* Clover City VV3 FAB D CLV+ A0 */
+	CLVTP_PHONE_RHB_PR30,   /* RHB PR3.0 CLV+ B0 C-CLASS */
+	CLVTP_PHONE_RHB_DV1,    /* RHB Dv1 */
+	CLVTP_PHONE_RHB_PR20A,  /* CLV+ B0 C-Class-touch panel sensor GFF */
+	CLVTP_PHONE_RHB_CCVV2VB, /* Clover City VV2-Victoria Bay FAB B CLV B0 */
+	CLVTP_PHONE_RHB_PR19M,  /* Macro PR1.9 CLV+ B0 */
+	CLVTP_PHONE_RHB_PR199M, /* Macro PR1.99 CLV+ B0 */
+	CLVTP_PHONE_RSVD0,
+	CLVTP_PHONE_RHB_PR20B,  /* CLV+ B0 C-Class-touch panel sensor
+					GFF-LPDDR2 */
+	CLVTP_PHONE_RHB_PR30A,  /* CLV+ B1 C-Class */
+	CLVTP_PHONE_RHB_PR30AM, /* Macro CLV+ B1 C-Class */
+	CLVTP_PHONE_RHB_PR31,   /* CLV+ B2 C-Class */
+	CLVTP_PHONE_RHB_PR31M,  /* Macro CLV+ B2 C-Class */
+	CLVTP_PHONE_RHB_CCVV3A, /* Clover City VV3 FAB B CLV+ B0 */
+	CLVTP_PHONE_RHB_CCVV3B, /* Clover City VV3 FAB B CLV+ B1 */
+	CLVTP_PHONE_RHB_CCVV3C, /* Clover City VV3 FAB B CLV+ B2 */
+	CLVTP_PHONE_RSVD1,
+	CLVTP_PHONE_RSVD2,
+	CLVTP_PHONE_RSVD3,
+	CLVTP_PHONE_RSVD4,
+	CLVTP_PHONE_RHB_RDP,    /* Clovertrail RDP CLV+ B2 */
+	CLVTP_PHONE_RHB_VVLITE = 0x29, /* VV-Lite CLV+ B2 */
+	CLVTP_PHONE_RHB_RSVD,
+	CLVTP_PHONE_RHB_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_CLVTP_PHONE_VB */
+enum {
+	CLVTP_PHONE_VB_PR1A = 0x17,    /* Victoria Bay PR1 CLV+ B1 */
+	CLVTP_PHONE_VB_PR1B = 0x23,    /* Victoria Bay PR1 CLV+ B2 */
+	CLVTP_PHONE_VB_PR20 = 0x25,    /* Victoria Bay PR2 CLV+ B2 */
+	CLVTP_PHONE_VB_PR21,           /* Victoria Bay PR2.1 CLV+ B2 */
+	CLVTP_PHONE_VB_PR30,           /* Victoria Bay PR3 B2 */
+	CLVTP_PHONE_VB_PR21NA,         /* Victoria Bay PR2.1 NA CLV+ B2 */
+	CLVTP_PHONE_VB_RSVD,
+	CLVTP_PHONE_VB_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_CLVT_TABLET_TBD */
+enum {
+	CLVT_TABLET_TBD_CLEVA, /* Clover Lake EV - CRB - FAB A */
+	CLVT_TABLET_TBD_CLEVB, /* Clover Lake EV - CRB - FAB B */
+	CLVT_TABLET_TBD_CLEVC, /* Clover Lake EV - CRB - FAB C */
+	CLVT_TABLET_TBD_CLEVD, /* Clover Lake EV - CRB - FAB D */
+	CLVT_TABLET_TBD_VV2SS, /* Clover City VV2-Samtab-FAB B CLV+ B0 */
+	CLVT_TABLET_TBD_RSVD,
+	CLVT_TABLET_TBD_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_CLVT_TABLET_SLP */
+enum {
+	CLVT_TABLET_SLP_EV10, /* CRAK Bx */
+	CLVT_TABLET_SLP_RSVD,
+	CLVT_TABLET_SLP_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MRFL_PHONE_SB */
+enum {
+	MRFL_PHONE_SR_VVA,  /* SilverRidge VV FAB A */
+	MRFL_PHONE_SR_VVB,  /* SilverRidge VV FAB B */
+	MRFL_PHONE_SR_VVC,  /* SilverRidge VV FAB C */
+	MRFL_PHONE_SR_VVD,  /* SilverRidge VV FAB D */
+	MRFL_PHONE_SR_SVA,  /* SilverRidge SV FAB A */
+	MRFL_PHONE_SR_SVB,  /* SilverRidge SV FAB B */
+	MRFL_PHONE_SR_SVC,  /* SilverRidge SV FAB C */
+	MRFL_PHONE_SR_SVD,  /* SilverRidge SV FAB D */
+	MRFL_PHONE_SB_PR0M, /* Salt Bay PR0-Macro (A0) */
+	MRFL_PHONE_SB_PR0,  /* Salt Bay PR0-FF (A0) */
+	MRFL_PHONE_SB_PR1M, /* Salt Bay PR1-Macro (A0) */
+	MRFL_PHONE_SB_PR1,  /* Salt Bay PR1-FF (A0) */
+	MRFL_PHONE_SB_PR2M, /* Salt Bay PR2-Macro (B0) */
+	MRFL_PHONE_SB_PR2,  /* Salt Bay PR2-FF (B0) */
+	MRFL_PHONE_SB_PR3M, /* Salt Bay PR3-Macro (B0) */
+	MRFL_PHONE_SB_PR3,  /* Salt Bay PR3-FF (B0) */
+	MRFL_PHONE_SB_PR11,  /* Salt Bay PR1.1-FF (A0) */
+	MRFL_PHONE_SB_PR11M,  /* Salt Bay PR1.1-Macro (A0) */
+	MRFL_PHONE_SB_RSVD,
+	MRFL_PHONE_SB_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MRFL_PHONE_BB */
+enum {
+	MRFL_PHONE_BB_PRH,  /* Bodega Bay PRh FAB A */
+	MRFL_PHONE_BB_RSVD,
+	MRFL_PHONE_BB_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MRFL_TABLET_TBD */
+enum {
+	MRFL_TABLET_TBD_TBD,
+	MRFL_TABLET_TBD_RSVD,
+	MRFL_TABLET_TBD_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_BYT_PHONE_TBD */
+enum {
+	BYT_PHONE_TBD_TBD,
+	BYT_PHONE_TBD_RSVD,
+	BYT_PHONE_TBD_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_BYT_TABLET_TBD */
+enum {
+	BYT_TABLET_BLK_VV1, /* Bay Lake CRB/RVP FAB 1 */
+	BYT_TABLET_BLK_VV2, /* Bay Lake CRB/RVP FAB 2 */
+	BYT_TABLET_BLK_VV3, /* Bay Lake CRB/RVP FAB 3 */
+	BYT_TABLET_BLK_PR1_1, /* Bay Lake FFRD-10 PR1.1 */
+	BYT_TABLET_BLB_VV3, /* Bayley Bay CRB FAB 3 Rev3 */
+	BYT_TABLET_BLK_RSVD,
+	BYT_TABLET_BLK_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MOOR_PHONE_FRCB */
+enum {
+	MOOR_PHONE_FRCB_VVA, /* Mountain Prairie VV FAB A */
+	MOOR_PHONE_FRCB_VVB, /* Mountain Prairie VV FAB B */
+	MOOR_PHONE_FRCB_VVC, /* Mountain Prairie VV FAB C */
+	MOOR_PHONE_FRCB_VVD, /* Mountain Prairie VV FAB D */
+	MOOR_PHONE_FRCB_PR0, /* Francis Bay FAB A */
+	MOOR_PHONE_FRCB_PR1, /* Francis Bay FAB B */
+	MOOR_PHONE_FRCB_PR2, /* Francis Bay FAB C */
+	MOOR_PHONE_FRCB_PR3, /* Francis Bay FAB D */
+	MOOR_PHONE_FRCB_RSVD,
+	MOOR_PHONE_FRCB_UNKNOWN = 0xFFFF
+};
+
+/* Hardware_ID table for Product_Line_ID == INTEL_MOOR_TABLET_TBD */
+enum {
+	MOOR_TABLET_TBD_TBD,
+	MOOR_TABLET_TBD_RSVD,
+	MOOR_TABLET_TBD_UNKNOWN = 0xFFFF
+};
+
+/* Macros for SPID based checks */
+
+#define SPID_CUSTOMER_ID(customer) ( \
+	(spid.customer_id == CUSTOMER_##customer))
+#define SPID_VENDOR_ID(vendor) ( \
+	(spid.vendor_id == VENDOR_##vendor))
+#define SPID_PLATFORM_ID(vendor, platform, devtype) ( \
+	(spid.platform_family_id == vendor##_##platform##_##devtype))
+#define SPID_PRODUCT_ID(vendor, platform, devtype, product, type) (\
+	(spid.product_line_id == \
+	vendor##_##platform##_##devtype##_##product##_##type))
+#define SPID_PRODUCT(vendor, platform, devtype, product) (\
+	((spid.product_line_id & 0x7FFF) == \
+	vendor##_##platform##_##devtype##_##product##_PRO))
+#define SPID_HARDWARE_ID(platform, devtype, product, hardware) (\
+	(spid.hardware_id == platform##_##devtype##_##product##_##hardware))
+
+#define INTEL_MID_BOARDV1(devtype, platform) ( \
+	SPID_CUSTOMER_ID(INTEL) && \
+	SPID_VENDOR_ID(INTEL) && \
+	SPID_PLATFORM_ID(INTEL, platform, devtype))
+
+#define INTEL_MID_BOARDV2(devtype, platform, product, type) ( \
+	INTEL_MID_BOARDV1(devtype, platform) && \
+	SPID_PRODUCT_ID(INTEL, platform, devtype, product, type))
+
+#define INTEL_MID_BOARDV3(devtype, platform, product, type, hardware) ( \
+	INTEL_MID_BOARDV2(devtype, platform, product, type) && \
+	SPID_HARDWARE_ID(platform, devtype, product, hardware))
+
+
+
+/* INTEL_MID_BOARD - Returns true if arugments matches SPID contents
+ * @ level:	1, 2, 3
+		- 1 for verifying platform_id,
+		- 2 for verifying platform_type & product_id,
+		- 3 for verifying platform_type, product_id & hardware_id.
+ * @ devtype:	PHONE or TABLET
+ * @ arg3:	platform_type - MFLD,CLVTP,CLVT,MRFL.
+ * @ arg4:	product ID - product id supported by
+		platform_type passed in arg3.
+ * @ arg5:	PRO or ENG.
+ * @ arg6:	hardware_id -Hardware IDs supported by above
+		platform_type & product_id.
+ *
+ * Example:	INTEL_MID_BOARD(1,PHONE,MFLD)
+ *		INTEL_MID_BOARD(2,PHONE,MFLD,BB15,PRO)
+ *		INTEL_MID_BOARD(3,PHONE,MFLD,BB15,PRO,PR20),
+ *
+ */
+#define INTEL_MID_BOARD(level, devtype, ...) ( \
+	INTEL_MID_BOARDV##level(devtype, __VA_ARGS__))
+
+#endif /* _ASM_X86_SPID_H */
diff --git a/arch/x86/platform/intel-mid/intel_mid_sfi.c b/arch/x86/platform/intel-mid/intel_mid_sfi.c
index d6722c351c0a..622dacd374ca 100644
--- a/arch/x86/platform/intel-mid/intel_mid_sfi.c
+++ b/arch/x86/platform/intel-mid/intel_mid_sfi.c
@@ -62,6 +62,9 @@ static int gpio_num_entry;
 static u32 sfi_mtimer_usage[SFI_MTMR_MAX_NUM];
 int sfi_mrtc_num;
 int sfi_mtimer_num;
+struct kobject *spid_kobj;
+struct soft_platform_id spid;
+char intel_mid_ssn[INTEL_MID_SSN_SIZE + 1];
 
 struct sfi_rtc_table_entry sfi_mrtc_array[SFI_MRTC_MAX];
 EXPORT_SYMBOL_GPL(sfi_mrtc_array);
@@ -475,11 +478,222 @@ static int __init sfi_parse_devs(struct sfi_table_header *table)
 	return 0;
 }
 
+static int __init sfi_parse_oemb(struct sfi_table_header *table)
+{
+	struct sfi_table_oemb *oemb;
+	u32 board_id;
+	u8 sig[SFI_SIGNATURE_SIZE + 1] = {'\0'};
+	u8 oem_id[SFI_OEM_ID_SIZE + 1] = {'\0'};
+	u8 oem_table_id[SFI_OEM_TABLE_ID_SIZE + 1] = {'\0'};
+
+	oemb = (struct sfi_table_oemb *) table;
+	if (!oemb) {
+		pr_err("%s: fail to read SFI OEMB Layout\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	board_id = oemb->board_id | (oemb->board_fab << 4);
+
+	memcpy(&spid, &oemb->spid, sizeof(struct soft_platform_id));
+
+	if (oemb->header.len <
+			(char *)oemb->ssn + INTEL_MID_SSN_SIZE - (char *)oemb) {
+		pr_err("SFI OEMB does not contains SSN\n");
+		intel_mid_ssn[0] = '\0';
+	} else {
+		memcpy(intel_mid_ssn, oemb->ssn, INTEL_MID_SSN_SIZE);
+		intel_mid_ssn[INTEL_MID_SSN_SIZE] = '\0';
+	}
+
+	snprintf(sig, (SFI_SIGNATURE_SIZE + 1), "%s", oemb->header.sig);
+	snprintf(oem_id, (SFI_OEM_ID_SIZE + 1), "%s", oemb->header.oem_id);
+	snprintf(oem_table_id, (SFI_OEM_TABLE_ID_SIZE + 1), "%s",
+		 oemb->header.oem_table_id);
+	pr_info("SFI OEMB Layout\n");
+	pr_info("\tOEMB signature               : %s\n"
+		"\tOEMB length                  : %d\n"
+		"\tOEMB revision                : %d\n"
+		"\tOEMB checksum                : 0x%X\n"
+		"\tOEMB oem_id                  : %s\n"
+		"\tOEMB oem_table_id            : %s\n"
+		"\tOEMB board_id                : 0x%02X\n"
+		"\tOEMB iafw version            : %03d.%03d\n"
+		"\tOEMB val_hooks version       : %03d.%03d\n"
+		"\tOEMB ia suppfw version       : %03d.%03d\n"
+		"\tOEMB scu runtime version     : %03d.%03d\n"
+		"\tOEMB ifwi version            : %03d.%03d\n"
+		"\tOEMB spid customer id        : %04x\n"
+		"\tOEMB spid vendor id          : %04x\n"
+		"\tOEMB spid manufacturer id    : %04x\n"
+		"\tOEMB spid platform family id : %04x\n"
+		"\tOEMB spid product line id    : %04x\n"
+		"\tOEMB spid hardware id        : %04x\n"
+		"\tOEMB spid fru[4..0]          : %02x %02x %02x %02x %02x\n"
+		"\tOEMB spid fru[9..5]          : %02x %02x %02x %02x %02x\n"
+		"\tOEMB ssn                     : %s\n",
+		sig,
+		oemb->header.len,
+		oemb->header.rev,
+		oemb->header.csum,
+		oem_id,
+		oem_table_id,
+		board_id,
+		oemb->iafw_major_version,
+		oemb->iafw_main_version,
+		oemb->val_hooks_major_version,
+		oemb->val_hooks_minor_version,
+		oemb->ia_suppfw_major_version,
+		oemb->ia_suppfw_minor_version,
+		oemb->scu_runtime_major_version,
+		oemb->scu_runtime_minor_version,
+		oemb->ifwi_major_version,
+		oemb->ifwi_minor_version,
+		spid.customer_id,
+		spid.vendor_id,
+		spid.manufacturer_id,
+		spid.platform_family_id,
+		spid.product_line_id,
+		spid.hardware_id,
+		spid.fru[4], spid.fru[3], spid.fru[2], spid.fru[1],
+		spid.fru[0], spid.fru[9], spid.fru[8], spid.fru[7],
+		spid.fru[6], spid.fru[5],
+		intel_mid_ssn);
+	return 0;
+}
+
+static ssize_t customer_id_show(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.customer_id);
+}
+spid_attr(customer_id);
+
+static ssize_t vendor_id_show(struct kobject *kobj, struct kobj_attribute *attr,
+			      char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.vendor_id);
+}
+spid_attr(vendor_id);
+
+static ssize_t manufacturer_id_show(struct kobject *kobj,
+				    struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.manufacturer_id);
+}
+spid_attr(manufacturer_id);
+
+static ssize_t platform_family_id_show(struct kobject *kobj,
+				       struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.platform_family_id);
+}
+spid_attr(platform_family_id);
+
+static ssize_t product_line_id_show(struct kobject *kobj,
+				    struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.product_line_id);
+}
+spid_attr(product_line_id);
+
+static ssize_t hardware_id_show(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.hardware_id);
+}
+spid_attr(hardware_id);
+
+static ssize_t fru_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%02x\n%02x\n%02x\n%02x\n%02x\n"
+			    "%02x\n%02x\n%02x\n%02x\n%02x\n",
+			spid.fru[0], spid.fru[1], spid.fru[2], spid.fru[3],
+			spid.fru[4], spid.fru[5], spid.fru[6], spid.fru[7],
+			spid.fru[8], spid.fru[9]);
+}
+spid_attr(fru);
+
+static struct attribute *spid_attrs[] = {
+	&customer_id_attr.attr,
+	&vendor_id_attr.attr,
+	&manufacturer_id_attr.attr,
+	&platform_family_id_attr.attr,
+	&product_line_id_attr.attr,
+	&hardware_id_attr.attr,
+	&fru_attr.attr,
+	NULL,
+};
+
+static struct attribute_group spid_attr_group = {
+	.attrs = spid_attrs,
+};
+
+/* size of SPID cmdline : androidboot.spid=vend:cust:manu:plat:prod:hard */
+#define SPID_CMDLINE_SIZE 46
+#define SPID_PARAM_NAME "androidboot.spid="
+#define SPID_DEFAULT_VALUE "xxxx:xxxx:xxxx:xxxx:xxxx:xxxx"
+
+void populate_spid_cmdline(void)
+{
+	char *spid_param, *spid_default_value;
+	char spid_cmdline[SPID_CMDLINE_SIZE+1];
+
+	/* parameter format : cust:vend:manu:plat:prod:hard */
+	snprintf(spid_cmdline, sizeof(spid_cmdline),
+		 "%04x:%04x:%04x:%04x:%04x:%04x",
+		 spid.vendor_id,
+		 spid.customer_id,
+		 spid.manufacturer_id,
+		 spid.platform_family_id,
+		 spid.product_line_id,
+		 spid.hardware_id);
+
+	/* is there a spid param ? */
+	spid_param = strstr(saved_command_line, SPID_PARAM_NAME);
+	if (spid_param) {
+		/* is the param set to default value ? */
+		spid_default_value = strstr(saved_command_line,
+					    SPID_DEFAULT_VALUE);
+		if (spid_default_value) {
+			spid_param += strlen(SPID_PARAM_NAME);
+			if (strlen(spid_param) > strlen(spid_cmdline))
+				memcpy(spid_param, spid_cmdline,
+						strlen(spid_cmdline));
+			else
+				pr_err("Not enough free space for SPID in command line.\n");
+		} else
+			pr_warning("SPID already populated. Dont overwrite.\n");
+	} else
+		pr_err("SPID not found in kernel command line.\n");
+}
+
 static int __init intel_mid_platform_init(void)
 {
-	/* Get MFD Validation SFI OEMB Layout */
+	int ret = 0;
+
+	/* create sysfs entries for soft platform id */
+	spid_kobj = kobject_create_and_add("spid", NULL);
+	if (!spid_kobj) {
+		pr_err("SPID: ENOMEM for spid_kobj\n");
+		return -ENOMEM;
+	}
+
+	ret = sysfs_create_group(spid_kobj, &spid_attr_group);
+	if (ret) {
+		pr_err("SPID: failed to create /sys/spid\n");
+		return ret;
+	}
+
+	/* Get SFI OEMB Layout */
+	sfi_table_parse(SFI_SIG_OEMB, NULL, NULL, sfi_parse_oemb);
 	sfi_table_parse(SFI_SIG_GPIO, NULL, NULL, sfi_parse_gpio);
 	sfi_table_parse(SFI_SIG_DEVS, NULL, NULL, sfi_parse_devs);
+
+	/* Populate command line with SPID values */
+	populate_spid_cmdline();
+
 	return 0;
 }
 arch_initcall(intel_mid_platform_init);
diff --git a/include/linux/sfi.h b/include/linux/sfi.h
index fe817918b30e..c80ab80a4fd3 100644
--- a/include/linux/sfi.h
+++ b/include/linux/sfi.h
@@ -72,6 +72,7 @@
 #define SFI_SIG_WAKE		"WAKE"
 #define SFI_SIG_DEVS		"DEVS"
 #define SFI_SIG_GPIO		"GPIO"
+#define SFI_SIG_OEMB		"OEMB"
 
 #define SFI_SIGNATURE_SIZE	4
 #define SFI_OEM_ID_SIZE		6
@@ -85,6 +86,9 @@
 #define SFI_GET_NUM_ENTRIES(ptable, entry_type) \
 	((ptable->header.len - sizeof(struct sfi_table_header)) / \
 	(sizeof(entry_type)))
+
+#define SPID_FRU_SIZE	10
+
 /*
  * Table structures must be byte-packed to match the SFI specification,
  * as they are provided by the BIOS.
-- 
2.37.3

