From 76672489984706c963ce59999589aaaea887183e Mon Sep 17 00:00:00 2001
From: Nie Jun <jun.nie@intel.com>
Date: Thu, 4 Jul 2013 20:00:57 +0800
Subject: [PATCH 020/429] intel-mid: fix and unify message bus access

There are two issues currently for the message bus access:

1. Some drivers don't fill the message bus control register(0xD0)
byte enables bits (7:4) with 1111, so the write will fail(i.e.
the value being written is never updated to the target register).
Because the driver doesn't read back to check if the value is written
correctly, this is actually a huge bug!

2. Secondly each driver has its own version of message bus acess
function. This could cause concurrent conflict issue, i.e. one driver
may use the dirty ctrl or data register updated by another driver.

This patch aims to fix these two issues.
Original author yang Fei and changeID: I19bf7bd9c6fad7d9a9eec0cce89b11bef312b388

Signed-off-by: Nie Jun <jun.nie@intel.com>
---
 arch/x86/include/asm/intel-mid.h        | 21 +++++++++
 arch/x86/platform/intel-mid/intel-mid.c | 61 +++++++++++++++++++++++++
 2 files changed, 82 insertions(+)

diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h
index ccf480cf7bfe..be786fa6f1c0 100644
--- a/arch/x86/include/asm/intel-mid.h
+++ b/arch/x86/include/asm/intel-mid.h
@@ -27,6 +27,23 @@ extern int get_gpio_by_name(const char *name);
 static inline int get_gpio_by_name(const char *name) { return -1; }
 #endif
 
+/*
+ * Access to message bus through these 2 registers
+ * in CUNIT(0:0:0) PCI configuration space.
+ * MSGBUS_CTRL_REG(0xD0):
+ *   31:24	= message bus opcode
+ *   23:16	= message bus port
+ *   15:8	= message bus address
+ *   7:4	= message bus byte enables
+ * MSGBUS_DTAT_REG(0xD4):
+ *   hold the data for write or read
+ */
+#define PCI_ROOT_MSGBUS_CTRL_REG	0xD0
+#define PCI_ROOT_MSGBUS_DATA_REG	0xD4
+#define PCI_ROOT_MSGBUS_READ		0x10
+#define PCI_ROOT_MSGBUS_WRITE		0x11
+#define PCI_ROOT_MSGBUS_DWORD_ENABLE	0xf0
+
 extern int intel_mid_pci_init(void);
 extern void intel_delayed_device_register(void *dev,
 			void (*delayed_callback)(void *dev_desc));
@@ -36,6 +53,10 @@ extern int __init sfi_parse_mrtc(struct sfi_table_header *table);
 extern int __init sfi_parse_mtmr(struct sfi_table_header *table);
 extern int sfi_mrtc_num;
 extern struct sfi_rtc_table_entry sfi_mrtc_array[];
+extern u32 intel_mid_msgbus_read32_raw(u32 cmd);
+extern void intel_mid_msgbus_write32_raw(u32 cmd, u32 data);
+extern u32 intel_mid_msgbus_read32(u8 port, u8 addr);
+extern void intel_mid_msgbus_write32(u8 port, u8 addr, u32 data);
 
 /* OEMB table */
 struct sfi_table_oemb {
diff --git a/arch/x86/platform/intel-mid/intel-mid.c b/arch/x86/platform/intel-mid/intel-mid.c
index 8730e8a97f43..b7aab5806e26 100644
--- a/arch/x86/platform/intel-mid/intel-mid.c
+++ b/arch/x86/platform/intel-mid/intel-mid.c
@@ -21,6 +21,7 @@
 #include <linux/irq.h>
 #include <linux/module.h>
 #include <linux/notifier.h>
+#include <linux/spinlock.h>
 
 #include <asm/setup.h>
 #include <asm/mpspec_def.h>
@@ -74,6 +75,66 @@ static void intel_mid_reboot(void)
 		intel_scu_ipc_simple_command(IPCMSG_COLD_RESET, 0);
 }
 
+static unsigned long __init intel_mid_calibrate_tsc(void)
+{
+	return 0;
+}
+/* Unified message bus read/write operation */
+DEFINE_SPINLOCK(msgbus_lock);
+
+u32 intel_mid_msgbus_read32_raw(u32 cmd)
+{
+	struct pci_dev *pci_root;
+	unsigned long irq_flags;
+	u32 data;
+
+	pci_root = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
+
+	spin_lock_irqsave(&msgbus_lock, irq_flags);
+	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+	pci_read_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, &data);
+	spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+
+	pci_dev_put(pci_root);
+
+	return data;
+}
+EXPORT_SYMBOL(intel_mid_msgbus_read32_raw);
+
+void intel_mid_msgbus_write32_raw(u32 cmd, u32 data)
+{
+	struct pci_dev *pci_root;
+	unsigned long irq_flags;
+
+	pci_root = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
+
+	spin_lock_irqsave(&msgbus_lock, irq_flags);
+	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
+	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+	spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+
+	pci_dev_put(pci_root);
+}
+EXPORT_SYMBOL(intel_mid_msgbus_write32_raw);
+
+u32 intel_mid_msgbus_read32(u8 port, u8 addr)
+{
+	u32 cmd = (PCI_ROOT_MSGBUS_READ << 24) | (port << 16) |
+		  (addr << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+
+	return intel_mid_msgbus_read32_raw(cmd);
+}
+EXPORT_SYMBOL(intel_mid_msgbus_read32);
+
+void intel_mid_msgbus_write32(u8 port, u8 addr, u32 data)
+{
+	u32 cmd = (PCI_ROOT_MSGBUS_WRITE << 24) | (port << 16) |
+		  (addr << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+
+	intel_mid_msgbus_write32_raw(cmd, data);
+}
+EXPORT_SYMBOL(intel_mid_msgbus_write32);
+
 static void __init intel_mid_time_init(void)
 {
 
-- 
2.37.3

