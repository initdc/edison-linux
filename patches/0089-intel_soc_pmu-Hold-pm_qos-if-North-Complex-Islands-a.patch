From 5230d1b34679d08ae74a8c52deebfb20ed21a3af Mon Sep 17 00:00:00 2001
From: Illyas Mansoor <illyas.mansoor@intel.com>
Date: Fri, 11 Oct 2013 13:05:12 +0530
Subject: [PATCH 089/429] intel_soc_pmu: Hold pm_qos if North Complex Islands
 are in D0i0

S0ix will corrupt GFX PCI config when it's power on.
So, demote to low C-states.

Please refer to Bug 115181 for more details

This was earlier fixed in patch http://android.intel.com:8080/#/c/115478

But doing so will only fix in userdebug builds, since pmu_get_new_state is
gauarded in PM_DEBUG config flag.

Hence we need a better way of restricting s0ix when North complex is in D0i0

Signed-off-by: Illyas Mansoor <illyas.mansoor@intel.com>
---
 arch/x86/platform/intel-mid/intel_soc_pmu.c | 27 +++++++++++++++++++--
 arch/x86/platform/intel-mid/intel_soc_pmu.h |  1 +
 2 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/arch/x86/platform/intel-mid/intel_soc_pmu.c b/arch/x86/platform/intel-mid/intel_soc_pmu.c
index 8457de3f22a8..1feba003bd5b 100644
--- a/arch/x86/platform/intel-mid/intel_soc_pmu.c
+++ b/arch/x86/platform/intel-mid/intel_soc_pmu.c
@@ -1508,6 +1508,19 @@ nc_done:
 	}
 #endif
 
+	/* FIXME:: If S0ix is enabled when North Complex is ON we see
+	 * Fabric errors, tracked in BZ: 115181, hence hold pm_qos
+	 * to restrict s0ix during North Island in D0i0
+	 */
+	if (nc_device_state()) {
+		if (!pm_qos_request_active(mid_pmu_cxt->nc_restrict_qos))
+			pm_qos_add_request(mid_pmu_cxt->nc_restrict_qos,
+			 PM_QOS_CPU_DMA_LATENCY, (CSTATE_EXIT_LATENCY_S0i1-1));
+	} else {
+		if (pm_qos_request_active(mid_pmu_cxt->nc_restrict_qos))
+			pm_qos_remove_request(mid_pmu_cxt->nc_restrict_qos);
+	}
+
 unlock:
 	up(&mid_pmu_cxt->scu_ready_sem);
 
@@ -2066,6 +2079,11 @@ static int __init mid_pci_register_init(void)
 
 	init_nc_device_states();
 
+	mid_pmu_cxt->nc_restrict_qos =
+		kzalloc(sizeof(struct pm_qos_request), GFP_KERNEL);
+	if (mid_pmu_cxt->nc_restrict_qos == NULL)
+		return -ENOMEM;
+
 	/* initialize the semaphores */
 	sema_init(&mid_pmu_cxt->scu_ready_sem, 1);
 
@@ -2092,8 +2110,13 @@ void pmu_power_off(void)
 
 static void __exit mid_pci_cleanup(void)
 {
-	if (mid_pmu_cxt && mid_pmu_cxt->s3_restrict_qos)
-		pm_qos_remove_request(mid_pmu_cxt->s3_restrict_qos);
+	if (mid_pmu_cxt) {
+		if (mid_pmu_cxt->s3_restrict_qos)
+			pm_qos_remove_request(mid_pmu_cxt->s3_restrict_qos);
+
+		if (pm_qos_request_active(mid_pmu_cxt->nc_restrict_qos))
+			pm_qos_remove_request(mid_pmu_cxt->nc_restrict_qos);
+	}
 
 	suspend_set_ops(NULL);
 
diff --git a/arch/x86/platform/intel-mid/intel_soc_pmu.h b/arch/x86/platform/intel-mid/intel_soc_pmu.h
index ef2965bf1fe6..00bac52ef287 100644
--- a/arch/x86/platform/intel-mid/intel_soc_pmu.h
+++ b/arch/x86/platform/intel-mid/intel_soc_pmu.h
@@ -360,6 +360,7 @@ struct mid_pmu_dev {
 
 	struct pmu_suspend_config *ss_config;
 	struct pci_dev *pmu_dev;
+	struct pm_qos_request *nc_restrict_qos;
 
 	spinlock_t nc_ready_lock;
 
-- 
2.37.3

