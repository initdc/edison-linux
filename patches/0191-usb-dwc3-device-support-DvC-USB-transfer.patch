From cb0827b31b5c23c6fe9c17662683f3c35f397da8 Mon Sep 17 00:00:00 2001
From: Jiebing Li <jiebing.li@intel.com>
Date: Thu, 31 Oct 2013 12:09:44 +0800
Subject: [PATCH 191/429] usb/dwc3-device: support DvC USB transfer

This patch provides special USB transfer support for Debug Class
gadget in device driver based on K3.4.

Signed-off-by: Jiebing Li <jiebing.li@intel.com>
---
 drivers/usb/dwc3/core.h   |  21 ++
 drivers/usb/dwc3/gadget.c | 442 +++-----------------------------------
 drivers/usb/dwc3/gadget.h |   1 +
 3 files changed, 48 insertions(+), 416 deletions(-)

diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index d6654069f33f..91af7af4eace 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -432,6 +432,10 @@ struct dwc3_ep {
 	const struct usb_ss_ep_comp_descriptor *comp_desc;
 	struct dwc3		*dwc;
 
+	struct ebc_io		*ebc;
+#define DWC3_EP_EBC_OUT_NB	16
+#define DWC3_EP_EBC_IN_NB	17
+
 	unsigned		flags;
 #define DWC3_EP_ENABLED		(1 << 0)
 #define DWC3_EP_STALL		(1 << 1)
@@ -885,6 +889,23 @@ union dwc3_event {
 	struct dwc3_event_gevt		gevt;
 };
 
+struct ebc_io {
+	const char	*name;
+	const char	*epname;
+	u8		epnum;
+	u8		is_ondemand;
+	u8		static_trb_pool_size;
+	struct list_head	list;
+	int		(*init) (void);
+	void		*(*alloc_static_trb_pool) (dma_addr_t *dma_addr);
+	void		(*free_static_trb_pool) (void);
+	int		(*xfer_start) (void);
+	int		(*xfer_stop) (void);
+};
+
+void dwc3_register_io_ebc(struct ebc_io *ebc);
+void dwc3_unregister_io_ebc(struct ebc_io *ebc);
+
 /*
  * DWC3 Features to be used as Driver Data
  */
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index a1b150cfefd8..5493a6bdbe44 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -457,13 +457,24 @@ static int dwc3_gadget_set_ep_config(struct dwc3 *dwc, struct dwc3_ep *dep,
 		const struct usb_ss_ep_comp_descriptor *comp_desc,
 		bool ignore, u32 cfg_action)
 {
+	u16	maxp;
+
 	struct dwc3_gadget_ep_cmd_params params;
 
 	memset(&params, 0x00, sizeof(params));
 
+	if (dep->ebc) {
+		/* special consideration for TNG A0 */
+		if (dep->ebc->epnum == DWC3_EP_EBC_OUT_NB ||
+				dep->ebc->epnum == DWC3_EP_EBC_IN_NB)
+			maxp = 64;
+		else
+			maxp = usb_endpoint_maxp(desc);
+	} else
+		maxp = usb_endpoint_maxp(desc);
+
 	params.param0 = DWC3_DEPCFG_EP_TYPE(usb_endpoint_type(desc))
-		| DWC3_DEPCFG_MAX_PACKET_SIZE(usb_endpoint_maxp(desc))
-		| cfg_action;
+		| DWC3_DEPCFG_MAX_PACKET_SIZE(maxp);
 
 	if (dep->ebc) {
 		if (dwc->gadget.speed == USB_SPEED_SUPER) {
@@ -474,27 +485,12 @@ static int dwc3_gadget_set_ep_config(struct dwc3 *dwc, struct dwc3_ep *dep,
 
 		params.param0 |= DWC3_DEPCFG_IGN_SEQ_NUM;
 
+	if (dep->ebc) {
 		params.param1 = DWC3_DEPCFG_EBC_MODE_EN;
-
 		if (dep->ebc->is_ondemand)
 			params.param1 |= DWC3_DEPCFG_XFER_NOT_READY_EN;
-
 		dep->stream_capable = false;
 	} else {
-		/* Burst size is only needed in SuperSpeed mode */
-		if (dwc->gadget.speed == USB_SPEED_SUPER) {
-			/* In case a function forgets to set maxburst, maxburst
-			 * may be still 0, and we shouldn't minus 1 for it.
-			 */
-			u32 burst = dep->endpoint.maxburst ?
-					dep->endpoint.maxburst - 1 : 0;
-
-			params.param0 |= DWC3_DEPCFG_BURST_SIZE(burst);
-		}
-
-		if (ignore)
-			params.param0 |= DWC3_DEPCFG_IGN_SEQ_NUM;
-
 		params.param1 = DWC3_DEPCFG_XFER_COMPLETE_EN
 			| DWC3_DEPCFG_XFER_NOT_READY_EN;
 
@@ -697,12 +693,9 @@ static int __dwc3_gadget_ep_disable(struct dwc3_ep *dep)
 	struct ebc_io		*ebc = dep->ebc;
         u32			reg;
 
-	if (ebc) {
-		dwc->is_ebc = 0;
 
-		if (ebc->is_ondemand && ebc->xfer_stop)
-			ebc->xfer_stop();
-	}
+	if (ebc && ebc->is_ondemand && ebc->xfer_stop)
+		ebc->xfer_stop();
 
 	dwc3_remove_requests(dwc, dep);
 
@@ -1257,25 +1250,9 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 		WARN_ON_ONCE(!dep->resource_index);
 	}
 
-	if (dep->ebc) {
-		if (dep->ebc->is_ondemand == 1) {
-			ret = dwc3_gadget_update_ebc_ep_config(dwc, dep,
-				dep->endpoint.desc, dep->comp_desc, true);
-
-			if (ret < 0) {
-				dev_dbg(dwc->dev,
-					"DEPCFG command failed on %s\n",
-					dep->name);
-				return ret;
-			}
-			dev_dbg(dwc->dev,
-				"successfully udpated DEPCFG command on %s\n",
-				dep->name);
-		}
-
+	if (dep->ebc)
 		if (dep->ebc->xfer_start)
 			dep->ebc->xfer_start();
-	}
 
 	return 0;
 }
@@ -1323,18 +1300,15 @@ static int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)
 	if (dep->ebc) {
 		list_add_tail(&req->list, &dep->request_list);
 
-		if ((dep->ebc->is_ondemand == 1) &&
-			(!(dep->flags & DWC3_EP_PENDING_REQUEST))) {
-			dev_dbg(dwc->dev, "%s: delayed to kick ebc transfers\n",
-				dep->name);
+		if (!dep->ebc->is_ondemand) {
+			if (dep->flags & DWC3_EP_BUSY) {
+				dwc3_stop_active_transfer(dwc, dep->number);
+				dep->flags = DWC3_EP_ENABLED;
+			}
+		} else if (!(dep->flags & DWC3_EP_PENDING_REQUEST)) {
 			return 0;
 		}
 
-		if (dep->flags & DWC3_EP_BUSY) {
-			dwc3_stop_active_transfer(dwc, dep->number, 1);
-			dep->flags = DWC3_EP_ENABLED;
-		}
-
 		ret = __dwc3_gadget_kick_transfer(dep, 0, true);
 		if (ret)
 			dev_dbg(dwc->dev, "%s: failed to kick transfers\n",
@@ -2078,7 +2052,7 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
 			if (epnum == ebc->epnum) {
 				dep->ebc = ebc;
 				if (ebc->init)
-					if (ebc->init() == -ENODEV)
+					if (!ebc->init())
 						dev_err(dwc->dev,
 						"debug class init fail %d\n",
 						epnum);
@@ -2445,26 +2419,8 @@ static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum, int forcerm)
 
 	dep = dwc->eps[epnum];
 
-	if (dep->ebc) {
-		if (dep->ebc->is_ondemand == 1) {
-			ret = dwc3_gadget_update_ebc_ep_config(dwc, dep,
-				dep->endpoint.desc, dep->comp_desc, false);
-			if (ret < 0) {
-				dev_dbg(dwc->dev,
-					"DEPCFG failed on %s\n",
-					dep->name);
-				return;
-			}
-			dev_dbg(dwc->dev,
-				"successfully udpated DEPCFG command on %s\n",
-				dep->name);
-		}
-
-		if (dep->ebc->xfer_stop)
-			dep->ebc->xfer_stop();
-		else
-			dev_dbg(dwc->dev, "%s xfer_stop() NULL\n", dep->name);
-	}
+	if (dep->ebc && dep->ebc->xfer_stop)
+		dep->ebc->xfer_stop();
 
 	if (usb_endpoint_xfer_isoc(dep->endpoint.desc))
 		dep->resource_index = dwc3_gadget_ep_get_transfer_index(dwc,
@@ -3342,349 +3298,3 @@ void dwc3_unregister_io_ebc(struct ebc_io *ebc)
 {
 	list_del(&ebc->list);
 }
-
-#ifdef CONFIG_PM_RUNTIME
-static void dwc3_gadget_get_ep_state(struct dwc3 *dwc, struct dwc3_ep *dep)
-{
-	struct	dwc3_gadget_ep_cmd_params params;
-	int	ret;
-
-	dev_vdbg(dwc->dev, "%s\n", __func__);
-
-	memset(&params, 0, sizeof(params));
-	ret = dwc3_send_gadget_ep_cmd(dwc, dep->number,
-			DWC3_DEPCMD_GETEPSTATE, &params);
-	WARN_ON_ONCE(ret);
-
-	dep->ep_state = dwc3_readl(dwc->regs, DWC3_DEPCMDPAR2(dep->number));
-}
-
-static void dwc3_cache_hwregs(struct dwc3 *dwc)
-{
-	struct dwc3_hwregs	*regs = &dwc->hwregs;
-
-	dev_vdbg(dwc->dev, "%s\n", __func__);
-
-	regs->guctl = dwc3_readl(dwc->regs, DWC3_GUCTL);
-	regs->grxthrcfg = dwc3_readl(dwc->regs, DWC3_GRXTHRCFG);
-	regs->dcfg = dwc3_readl(dwc->regs, DWC3_DCFG);
-	regs->devten = dwc3_readl(dwc->regs, DWC3_DEVTEN);
-	regs->gctl = dwc3_readl(dwc->regs, DWC3_GCTL);
-	regs->gusb3pipectl0 = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));
-	regs->gusb2phycfg0 = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));
-	regs->gevntadrlo = dwc3_readl(dwc->regs, DWC3_GEVNTADRLO(0));
-	regs->gevntadrhi = dwc3_readl(dwc->regs, DWC3_GEVNTADRHI(0));
-	regs->gevntsiz = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(0));
-}
-
-static void dwc3_restore_hwregs(struct dwc3 *dwc)
-{
-	struct dwc3_hwregs	*regs = &dwc->hwregs;
-
-	dev_vdbg(dwc->dev, "%s\n", __func__);
-
-	dwc3_writel(dwc->regs, DWC3_GUCTL, regs->guctl);
-	dwc3_writel(dwc->regs, DWC3_GRXTHRCFG, regs->grxthrcfg);
-	dwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), regs->gusb3pipectl0);
-	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), regs->gusb2phycfg0);
-	dwc3_writel(dwc->regs, DWC3_GEVNTADRLO(0), regs->gevntadrlo);
-	dwc3_writel(dwc->regs, DWC3_GEVNTADRHI(0), regs->gevntadrhi);
-	dwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0), regs->gevntsiz);
-	dwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), 0);
-	dwc3_writel(dwc->regs, DWC3_DCFG, regs->dcfg);
-	dwc3_writel(dwc->regs, DWC3_DEVTEN, regs->devten);
-	dwc3_writel(dwc->regs, DWC3_GCTL, regs->gctl);
-}
-
-static int dwc3_gadget_controller_save_state(struct dwc3 *dwc)
-{
-	u32			reg;
-	u32			timeout = 1000;
-
-	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
-
-	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-
-	reg |= DWC3_DCTL_CSS;
-	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
-
-	do {
-		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
-		if (!(reg & DWC3_DSTS_SSS))
-				return 0;
-
-		timeout--;
-		if (!timeout)
-			return -ETIMEDOUT;
-		udelay(1);
-	} while (1);
-
-	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
-}
-
-static int dwc3_gadget_controller_restore_state(struct dwc3 *dwc)
-{
-	u32			reg;
-	u32			timeout = 1000;
-
-	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
-
-	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-
-	reg |= DWC3_DCTL_CRS;
-	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
-
-	do {
-		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
-		if (!(reg & DWC3_DSTS_RSS))
-				return 0;
-
-		timeout--;
-		if (!timeout)
-			return -ETIMEDOUT;
-		udelay(1);
-	} while (1);
-
-	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
-}
-
-void dwc3_gadget_keep_conn(struct dwc3 *dwc, int is_on)
-{
-	u32         reg;
-
-	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-	if (is_on)
-		reg |= DWC3_DCTL_KEEP_CONNECT;
-	else
-		reg &= ~DWC3_DCTL_KEEP_CONNECT;
-	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
-}
-
-int dwc3_runtime_suspend(struct device *device)
-{
-	struct dwc3			*dwc;
-	struct platform_device		*pdev;
-	unsigned long			flags;
-	u32				epnum;
-	struct dwc3_ep			*dep;
-
-	pdev = to_platform_device(device);
-	dwc = platform_get_drvdata(pdev);
-
-	if (!dwc || !dwc->hiber_enabled)
-		return 0;
-
-	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
-
-	spin_lock_irqsave(&dwc->lock, flags);
-
-	if (dwc->pm_state != PM_ACTIVE) {
-		spin_unlock_irqrestore(&dwc->lock, flags);
-		return 0;
-	}
-
-
-	for (epnum = 0; epnum < DWC3_ENDPOINTS_NUM; epnum++) {
-		dep = dwc->eps[epnum];
-		if (!(dep->flags & DWC3_EP_ENABLED))
-			continue;
-
-		dep->flags_backup = dep->flags;
-		if (dep->flags & DWC3_EP_BUSY)
-			dwc3_stop_active_transfer(dwc, epnum, 0);
-
-		dwc3_gadget_get_ep_state(dwc, dep);
-
-		dep->flags = DWC3_EP_HIBERNATION;
-	}
-
-	__dwc3_gadget_run_stop(dwc, 0);
-	dwc3_gadget_keep_conn(dwc, 1);
-
-	dwc3_cache_hwregs(dwc);
-
-	dwc3_gadget_disable_irq(dwc);
-	dwc3_event_buffers_cleanup(dwc);
-
-	dwc3_gadget_controller_save_state(dwc);
-
-	dwc->pm_state = PM_SUSPENDED;
-
-	spin_unlock_irqrestore(&dwc->lock, flags);
-
-	schedule_delayed_work(&dwc->link_work, msecs_to_jiffies(1000));
-	dev_info(dwc->dev, "suspended\n");
-	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
-
-	return 0;
-}
-
-int dwc3_runtime_resume(struct device *device)
-{
-	struct dwc3			*dwc;
-	struct platform_device		*pdev;
-	unsigned long			flags;
-	int				ret;
-	u32				epnum;
-	u32				timeout = 500;
-	u32				reg;
-	u8				link_state;
-	struct dwc3_ep			*dep;
-
-	pdev = to_platform_device(device);
-	dwc = platform_get_drvdata(pdev);
-
-	if (!dwc || !dwc->hiber_enabled)
-		return 0;
-
-	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
-
-	spin_lock_irqsave(&dwc->lock, flags);
-
-	if (dwc->pm_state == PM_ACTIVE ||
-		dwc->pm_state == PM_DISCONNECTED) {
-		spin_unlock_irqrestore(&dwc->lock, flags);
-		return 0;
-	}
-
-	dwc3_send_gadget_generic_command(dwc, DWC3_DGCMD_SET_SCRATCH_ADDR_LO,
-		dwc->scratch_array_dma & 0xffffffffU);
-
-	dwc3_gadget_controller_restore_state(dwc);
-
-	dwc3_restore_hwregs(dwc);
-
-	dep = dwc->eps[0];
-	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
-	if (ret) {
-		dev_err(dwc->dev, "failed to enable %s during runtime resume\n",
-			dep->name);
-		goto err0;
-	}
-
-	dep = dwc->eps[1];
-	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
-	if (ret) {
-		dev_err(dwc->dev, "failed to enable %s during runtime resume\n",
-			dep->name);
-		goto err1;
-	}
-
-	for (epnum = 0; epnum < 2; epnum++) {
-		struct dwc3_gadget_ep_cmd_params params;
-
-		dep = dwc->eps[epnum];
-		if (dep->flags_backup & DWC3_EP_BUSY) {
-			dwc->ep0_trb->ctrl |= DWC3_TRB_CTRL_HWO;
-
-			memset(&params, 0, sizeof(params));
-			params.param0 = upper_32_bits(dwc->ep0_trb_addr);
-			params.param1 = lower_32_bits(dwc->ep0_trb_addr);
-
-			ret = dwc3_send_gadget_ep_cmd(dwc, epnum,
-					DWC3_DEPCMD_STARTTRANSFER, &params);
-			WARN_ON_ONCE(ret);
-		}
-
-		dep->flags = dep->flags_backup;
-		dep->flags_backup = 0;
-	}
-
-	__dwc3_gadget_run_stop(dwc, 1);
-	dwc3_gadget_keep_conn(dwc, 1);
-
-	do {
-		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
-		if (!(reg & DWC3_DSTS_DCNRD))
-				break;
-
-		timeout--;
-		if (!timeout)
-			break;
-		udelay(1);
-	} while (1);
-
-	reg = dwc3_readl(dwc->regs, DWC3_DSTS);
-	link_state = DWC3_DSTS_USBLNKST(reg);
-	switch (link_state) {
-	case DWC3_LINK_STATE_U3:
-	case DWC3_LINK_STATE_RESUME:
-		dwc3_gadget_conndone_interrupt(dwc);
-
-		for (epnum = 2; epnum < DWC3_ENDPOINTS_NUM; epnum++) {
-			dep = dwc->eps[epnum];
-			if (!(dep->flags_backup & DWC3_EP_ENABLED))
-				continue;
-			if (dep->endpoint.desc)
-				dwc3_gadget_set_ep_config(dwc,
-					dep, dep->endpoint.desc, dep->comp_desc,
-					false, DWC3_DEPCFG_ACTION_RESTORE);
-
-			dwc3_gadget_set_xfer_resource(dwc, dep);
-
-			reg = dwc3_readl(dwc->regs, DWC3_DALEPENA);
-			reg |= DWC3_DALEPENA_EP(epnum);
-			dwc3_writel(dwc->regs, DWC3_DALEPENA, reg);
-
-			if (dep->flags_backup & DWC3_EP_STALL)
-				__dwc3_gadget_ep_set_halt(dep, 1);
-
-			if (dep->flags_backup & DWC3_EP_BUSY) {
-				struct dwc3_request			*req;
-				struct dwc3_gadget_ep_cmd_params	params;
-
-				req = next_request(&dep->req_queued);
-				if (!req)
-					break;
-				req->trb->ctrl |= DWC3_TRB_CTRL_HWO;
-				memset(&params, 0, sizeof(params));
-				params.param0 = upper_32_bits(req->trb_dma);
-				params.param1 = lower_32_bits(req->trb_dma);
-
-				ret = dwc3_send_gadget_ep_cmd(dwc, epnum,
-						DWC3_DEPCMD_STARTTRANSFER,
-						&params);
-				WARN_ON_ONCE(ret);
-
-			}
-
-			dep->flags = dep->flags_backup;
-			dep->flags_backup = 0;
-		}
-
-		reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-		reg |= DWC3_DCTL_ULSTCHNG_RECOVERY;
-		dwc3_writel(dwc->regs, DWC3_DCTL, reg);
-
-		break;
-	case DWC3_LINK_STATE_RESET:
-		reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-		reg |= DWC3_DCTL_ULSTCHNG_RECOVERY;
-		dwc3_writel(dwc->regs, DWC3_DCTL, reg);
-
-		break;
-	default:
-		/* wait for USB Reset or Connect Done event */
-		break;
-	}
-
-	dwc->pm_state = PM_ACTIVE;
-
-	spin_unlock_irqrestore(&dwc->lock, flags);
-
-	__dwc3_vbus_draw(dwc, OTG_DEVICE_RESUME);
-	dev_info(dwc->dev, "resumed\n");
-	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
-	return 0;
-
-err1:
-	__dwc3_gadget_ep_disable(dwc->eps[0]);
-
-err0:
-	spin_unlock_irqrestore(&dwc->lock, flags);
-
-	return ret;
-}
-#else
-void dwc3_gadget_keep_conn(struct dwc3 *dwc, int is_on) {}
-#endif
diff --git a/drivers/usb/dwc3/gadget.h b/drivers/usb/dwc3/gadget.h
index b3f25c302e35..06257d5b3443 100644
--- a/drivers/usb/dwc3/gadget.h
+++ b/drivers/usb/dwc3/gadget.h
@@ -54,6 +54,7 @@ struct dwc3;
 #define DWC3_DEPCFG_XFER_NOT_READY_EN	(1 << 10)
 #define DWC3_DEPCFG_FIFO_ERROR_EN	(1 << 11)
 #define DWC3_DEPCFG_STREAM_EVENT_EN	(1 << 13)
+#define DWC3_DEPCFG_EBC_MODE_EN		(1 << 15)
 #define DWC3_DEPCFG_BINTERVAL_M1(n)	((n) << 16)
 #define DWC3_DEPCFG_STREAM_CAPABLE	(1 << 24)
 #define DWC3_DEPCFG_EP_NUMBER(n)	((n) << 25)
-- 
2.37.3

