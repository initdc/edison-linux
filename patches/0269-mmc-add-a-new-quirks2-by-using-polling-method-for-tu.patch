From bc2cf4eedee84684fd2153dab3e6f3df8798bcda Mon Sep 17 00:00:00 2001
From: Dong Chuanxiao <chuanxiao.dong@intel.com>
Date: Fri, 25 Oct 2013 13:47:11 +0800
Subject: [PATCH 269/429] mmc: add a new quirks2 by using polling method for
 tuning cmd

Observed tuning failure on FFRD8 PR1 and Merrifield. After changing
to polling method, this is not observed. Suspect this is an available
workaround. SoC team should continue to help to root cause this issue
and provide a final workaround or fix for this issue

Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
---
 drivers/mmc/host/sdhci.c  | 54 ++++++++++++++++++++++++++++++++-------
 include/linux/mmc/sdhci.h |  1 +
 2 files changed, 46 insertions(+), 9 deletions(-)

diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 35df924b12e8..6bdb4ea0c298 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -2171,6 +2171,8 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 	do {
 		struct mmc_command cmd = {0};
 		struct mmc_request mrq = {NULL};
+		unsigned int intmask;
+		unsigned long t = jiffies + msecs_to_jiffies(150);
 
 		if (!tuning_loop_counter && !timeout)
 			break;
@@ -2211,19 +2213,53 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 		sdhci_writew(host, SDHCI_TRNS_READ, SDHCI_TRANSFER_MODE);
 
 		sdhci_send_command(host, &cmd);
+		mmiowb();
 
 		host->cmd = NULL;
 		host->mrq = NULL;
 
-		spin_unlock(&host->lock);
-		enable_irq(host->irq);
-
-		/* Wait for Buffer Read Ready interrupt */
-		wait_event_interruptible_timeout(host->buf_ready_int,
-					(host->tuning_done == 1),
-					msecs_to_jiffies(50));
-		disable_irq(host->irq);
-		spin_lock(&host->lock);
+		/* delete the timer created by send command */
+		del_timer(&host->timer);
+
+		if (host->quirks2 & SDHCI_QUIRK2_TUNING_POLL) {
+			while (!time_after(jiffies, t)) {
+				intmask = sdhci_readl(host, SDHCI_INT_STATUS);
+				if (intmask & SDHCI_INT_DATA_AVAIL) {
+					host->tuning_done = 1;
+					sdhci_writel(host,
+						intmask & SDHCI_INT_DATA_AVAIL,
+						SDHCI_INT_STATUS);
+					break;
+				}
+			}
+		} else {
+			intmask = sdhci_readl(host, SDHCI_INT_STATUS);
+			if (intmask & SDHCI_INT_DATA_AVAIL) {
+				host->tuning_done = 1;
+				sdhci_writel(host,
+					intmask & SDHCI_INT_DATA_AVAIL,
+					SDHCI_INT_STATUS);
+			}
+			spin_unlock(&host->lock);
+			enable_irq(host->irq);
+
+			if (!host->tuning_done)
+				/* Wait for Buffer Read Ready interrupt */
+				wait_event_interruptible_timeout(
+						host->buf_ready_int,
+						(host->tuning_done == 1),
+						msecs_to_jiffies(50));
+			disable_irq(host->irq);
+			spin_lock(&host->lock);
+
+			intmask = sdhci_readl(host, SDHCI_INT_STATUS);
+			if (intmask & SDHCI_INT_DATA_AVAIL) {
+				host->tuning_done = 1;
+				sdhci_writel(host,
+					intmask & SDHCI_INT_DATA_AVAIL,
+					SDHCI_INT_STATUS);
+			}
+		}
 
 		if (!host->tuning_done) {
 			pr_info(DRIVER_NAME ": Timeout waiting for "
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index d14cb95ffe15..d4c124bedb5b 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -121,6 +121,7 @@ struct sdhci_host {
 #define SDHCI_QUIRK2_POWER_PIN_GPIO_MODE		(1<<27)
 #define SDHCI_QUIRK2_ADVERTISE_3V0_FORCE_1V8   (1<<28)
 #define SDHCI_QUIRK2_NON_STD_CIS   (1<<29)
+#define SDHCI_QUIRK2_TUNING_POLL			(1<<30)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
-- 
2.37.3

