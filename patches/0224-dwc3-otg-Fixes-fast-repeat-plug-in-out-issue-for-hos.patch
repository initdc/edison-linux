From 95009c5b04466f19c562195fc1a244ac73a33e15 Mon Sep 17 00:00:00 2001
From: "Wang, Yu" <yu.y.wang@intel.com>
Date: Thu, 15 Aug 2013 19:14:23 +0800
Subject: [PATCH 224/429] dwc3-otg: Fixes fast repeat plug in/out issue for
 host mode.

If fast repeat plug in/out USB device with micro A cable. Then
sometimes, DUT can't enumerate USB device. It caused by some OTG events
were lost in USB OTG driver.

Signed-off-by: Wang, Yu <yu.y.wang@intel.com>
---
 drivers/usb/dwc3/otg.c | 63 +++++++++++++++++++++++-------------------
 1 file changed, 35 insertions(+), 28 deletions(-)

diff --git a/drivers/usb/dwc3/otg.c b/drivers/usb/dwc3/otg.c
index 59aa88cb4ab3..ba53ceacfc63 100644
--- a/drivers/usb/dwc3/otg.c
+++ b/drivers/usb/dwc3/otg.c
@@ -110,14 +110,20 @@ static void get_and_clear_events(struct dwc_otg2 *otg,
 
 	spin_lock_irqsave(&otg->lock, flags);
 
-	if (otg_events && (otg->otg_events & otg_mask)) {
-		*otg_events = otg->otg_events;
-		otg->otg_events &= ~otg_mask;
+	if (otg_events) {
+		if (otg->otg_events & otg_mask) {
+			*otg_events = otg->otg_events;
+			otg->otg_events &= ~otg_mask;
+		} else
+			*otg_events = 0;
 	}
 
-	if (user_events && (otg->user_events & user_mask)) {
-		*user_events = otg->user_events;
-		otg->user_events &= ~user_mask;
+	if (user_events) {
+		if (otg->user_events & user_mask) {
+			*user_events = otg->user_events;
+			otg->user_events &= ~user_mask;
+		} else
+			*user_events = 0;
 	}
 
 	spin_unlock_irqrestore(&otg->lock, flags);
@@ -305,14 +311,12 @@ static int is_self_powered_b_device(struct dwc_otg2 *otg)
 static enum dwc_otg_state do_wait_vbus_raise(struct dwc_otg2 *otg)
 {
 	int ret;
-	unsigned long flags;
 	u32 otg_events = 0;
 	u32 user_events = 0;
 	u32 otg_mask = 0;
 	u32 user_mask = 0;
 
-	otg_mask = OEVT_B_DEV_SES_VLD_DET_EVNT |
-				OEVT_CONN_ID_STS_CHNG_EVNT;
+	otg_mask = OEVT_B_DEV_SES_VLD_DET_EVNT;
 
 	ret = sleep_until_event(otg, otg_mask,
 			user_mask, &otg_events,
@@ -325,24 +329,11 @@ static enum dwc_otg_state do_wait_vbus_raise(struct dwc_otg2 *otg)
 		return DWC_STATE_CHARGER_DETECTION;
 	}
 
-	if (otg_events & OEVT_CONN_ID_STS_CHNG_EVNT) {
-		otg_dbg(otg, "OEVT_CONN_ID_STS_CHNG_EVNT\n");
-		return DWC_STATE_B_IDLE;
-	}
-
 	/* timeout*/
-	if (!ret) {
-		if (is_self_powered_b_device(otg)) {
-			spin_lock_irqsave(&otg->lock, flags);
-			otg->charging_cap.chrg_type =
-				POWER_SUPPLY_CHARGER_TYPE_B_DEVICE;
-			spin_unlock_irqrestore(&otg->lock, flags);
+	if (!ret)
+		return DWC_STATE_A_HOST;
 
-			return DWC_STATE_A_HOST;
-		}
-	}
-
-	return DWC_STATE_INVALID;
+	return DWC_STATE_B_IDLE;
 }
 
 static enum dwc_otg_state do_wait_vbus_fall(struct dwc_otg2 *otg)
@@ -506,6 +497,7 @@ static enum dwc_otg_state do_connector_id_status(struct dwc_otg2 *otg)
 	otg->charging_cap.chrg_evt = POWER_SUPPLY_CHARGER_EVENT_DISCONNECT;
 	spin_unlock_irqrestore(&otg->lock, flags);
 
+stay_b_idle:
 	otg_mask = OEVT_CONN_ID_STS_CHNG_EVNT |
 			OEVT_B_DEV_SES_VLD_DET_EVNT;
 
@@ -528,6 +520,15 @@ static enum dwc_otg_state do_connector_id_status(struct dwc_otg2 *otg)
 
 	if (events & OEVT_CONN_ID_STS_CHNG_EVNT) {
 		otg_dbg(otg, "OEVT_CONN_ID_STS_CHNG_EVNT\n");
+
+		/* Prevent user fast plug out after plug in.
+		 * It will cause the first ID change event lost.
+		 * So need to check real ID currently.
+		 */
+		if (get_id(otg) == RID_FLOAT) {
+			otg_dbg(otg, "Stay DWC_STATE_INIT\n");
+			goto stay_b_idle;
+		}
 		state = DWC_STATE_WAIT_VBUS_RAISE;
 	}
 
@@ -560,10 +561,8 @@ static enum dwc_otg_state do_a_host(struct dwc_otg2 *otg)
 		dwc_otg_enable_vbus(otg, 1);
 
 		/* meant receive vbus valid event*/
-		if (do_wait_vbus_raise(otg) !=
-				DWC_STATE_CHARGER_DETECTION) {
+		if (do_wait_vbus_raise(otg) == DWC_STATE_A_HOST)
 			otg_err(otg, "Drive VBUS maybe fail!\n");
-		}
 	}
 
 	rc = start_host(otg);
@@ -573,6 +572,7 @@ static enum dwc_otg_state do_a_host(struct dwc_otg2 *otg)
 		return DWC_STATE_INVALID;
 	}
 
+stay_host:
 	otg_events = 0;
 	user_events = 0;
 
@@ -641,6 +641,13 @@ static enum dwc_otg_state do_a_host(struct dwc_otg2 *otg)
 				stop_host(otg);
 				dwc_otg_enable_vbus(otg, 0);
 			}
+		} else if (id == RID_GND || id == RID_A) {
+			otg_dbg(otg, "Stay DWC_STATE_A_HOST!!\n");
+			/* Prevent user fast plug in after plug out.
+			 * It will cause the first ID change event lost.
+			 * So need to check real ID currently.
+			 */
+			goto stay_host;
 		} else {
 			otg_err(otg, "Meet invalid charger cases!");
 			spin_lock_irqsave(&otg->lock, flags);
-- 
2.37.3

