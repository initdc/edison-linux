From d63897c5c17be38d504885ef2466269ab8e4f90c Mon Sep 17 00:00:00 2001
From: Sumeet Pawnikar <sumeet.r.pawnikar@intel.com>
Date: Thu, 22 Aug 2013 12:07:37 +0530
Subject: [PATCH 158/429] Thermal: cloverview support to K3.10

Port K3.4 thermal code for cloverview platform to K3.10

Following changes are ported:
a9f8652 EM/THERMAL: Sysfs to read,override values mapped to states
fcf62aa EM/THERMAL: Add platform thermal driver for BYT-M
bd54515 BYT-M: add key buttons support based on non-ACPI ec driver
d42d794 psh: Remove the driver source file
456475d OSNIB: Moved OSNIB driver to external driver folder
a2fef50 OSIP: Moved osip driver to external_driver folder
a5a6fcb EM/THERMAL: Reverting msic die slope/intercept.
872aaa2 Revert "psh: Remove the driver source file"
a984b4a psh: Remove the driver source file
3211da2 intel_msic_gpio: Remove the driver source file
1796947 EM/THERMAL: Add new ear and mic zones for VB
b00a44e EM/THERMAL: Add SoC cooling device
1f3f0c1 BYT-M/EC: add EC driver(non ACPI) support for BYT-M
ee39e96 Modem NVRAM driver
4e89c4a EM/THERMAL: Modify slope and inercept for thermal sensors
f9ae71f EM/THERMAL: Predicting skin temperature accurately.
3edf760 crystal_cove: provide similar interfaces with earlier platforms
772f9f4 Merge remote-tracking branch 'aosp/android-3.4' into HEAD
be601e9 EM/THERMAL: Add Platform Thermal driver for BYT
ff8f9c9 x86: intel-mid: remove compilation warnings from CTP's
device_libs files
b9f3bf1 thermal: shorten too long mcast group name
61fd027 Change kernel intel_scu_ipc_command calls to rpmsg calls
b069aa4 EM/THERMAL: Negative temperature handling in thermal.
fa0e689 msic_gpio: add intel msic gpio support for CLV
1586ea0 EM/THERMAL: Changing msic die temp equation.
37fca05 OSNIB: add support for BYT using CMOS
99dcbb7 crystalcove_pwrsrc: Enable Power source detection driver
b0ee84f0 pmic_charger: handle the USBDET interrupt on CTP for USB
connect/disconnect
0e5ba36 platform/x86: fix section mismatches
fcc4149 EM/THERMAL[Port from k3.0]: Klockwork fix in thermal_sys.c
2298248 flis: port FLIS driver to K3.4
ce0a9d5 intel_psh_ipc: add PSH IPC support for
Merrifield Platform
dbfbda7 EM/THERMAL[Port from K3.0]: Add SoC Thermal driver
3cf105b EM/THERMAL[Port from K3.0]: Thermal driver for MRFLD
4642d8c EM/THERMAL[Port from K3.0]: Add get-set methods for slope
interface
83a7507 EM/THERMAL[Port from K3.0]: Add slope/intercept sysfs interfaces
892f28b EM/THERMAL: Update Thermal driver's init call
2fc592f Updating Thermal driver for battery/charger
changes
0237d0b OSIP: UMIP: Add OSIP and UMIP driver for Intel SoC
02efffb scu_ipc: Adding IPC,PMIC,MIP,FW,IPCUTIL driver
75734aa remoteproc: intel_mid_remoteproc framework (WIP)
9c7b942 INTEL-MID: re-structure arch/x86/platform/mrst
a335750 Merge branch 'release' of
git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux
61e5191 Merge branch 'for_linus' of
git://cavan.codon.org.uk/platform-drivers-x86
917ee75 platform/x86: Add driver for Apple gmux device
2390481 Merge branch 'x86-platform-for-linus' of
git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
f11f999 toshiba_acpi: Refuse to load on machines with buggy INFO
implementations
6a92c36 thermal: add support for thermal sensor present on SPEAr13xx
machines
f39eaa6 platform, x86: Kill off Moorestown
0266e49 platform-x86: intel_mid_thermal: turn off thermistor voltage by
default
420138a platform-x86: intel_mid_thermal: convert to use Intel MSIC API
3fca3d3 platform-x86: intel_mid_thermal: add msic_thermal alias
7ec48ce platform/x86: drop deprecated asus_acpi driver
73d99a2 platform-drivers-x86: convert drivers/platform/x86/* to use
module_platform_driver()
2d24c49 Fujitsu tablet extras driver
c215ab9 x86: Add amilo-rfkill driver for some Fujitsu-Siemens Amilo
laptops
1b7ccab x86/mid/thermal: Turn off thermistor
6348307 x86/mid/thermal: Add msic_thermal alias
0f48d34 x86/mid/thermal: Convert to use Intel MSIC API
33e9970 x86/mid: Kill off Moorestown
2d58d7e thermal: Rename generate_netlink_event
78542e1 Platform: Samsung Q10 backlight driver
03f8952 platform-drivers-x86: intel_mid_thermal: fix memory leak
31f5396 thermal: make THERMAL_HWMON implementation fully internal
239dca9 platform-x86: intel_mid_thermal: Fix memory leak
cb8b646 platform/x86: Fix Makefile for intel_mid_powerbtn
bb3ce20 platform/oaktrail: ACPI EC Extra driver for Oaktrail
253a006 platform-x86: intel_mid_thermal: Fix coding style
99b38b4 platform/x86: add MXM WMI driver.
25985ed Fix common misspellings
2d70b73 Platform: add Samsung Laptop platform driver
47ae435 platform-driver-x86: intel_mid_thermal: fix unterminated
platform_device_id table
b229ece asus-nb-wmi: Asus Notebooks WMI Driver
e12e6d9 eeepc-wmi: asus generic asus-wmi.ko module
5b799d4 asus-wmi: move generic code to asus-wmi
f017fbe medfield: Add Thermal Driver
820787f Enable Dell All-In-One volume up/down keys
8eec8a1 intel_mid_powerbtn: add power button driver for Medfield
platform (#3)
89ca117 OLPC XO-1.5 ebook switch driver
efcfed9 Move hp_accel to drivers/platform/x86
af06216 ACPI: Fix build for CONFIG_NET unset
52cfd50 Merge branch 'release' of
git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
156d821 Merge branch 'misc' into release
4cb1872 thermal: Add event notification to thermal framework
5369c02 intel_scu_ipc: Utility driver for intel scu ipc
5b275ce thermal: make ops constant
35f0ce0 IBM Real-Time "SMI Free" mode driver -v7
260586d Add OLPC XO-1 rfkill driver
bd9fc3a Move hdaps driver to platform/x86
75b2d09 ideapad-laptop: Fix Makefile
57ac3b0 ideapad: Change the driver name to ideapad-laptop
58ac7aa Add Lenovo ideapad driver
8950778 gpio: Add PMIC GPIO block support
c715a38 rar: Move the RAR driver into the right place as its now clean
aa7ffc0 x86 platform driver: intelligent power sharing driver
9a58a33 IPC driver for Intel Mobile Internet Device (MID) platforms
ee027e4 eeepc-wmi: new driver for WMI based hotkeys on Eee PC laptops
529aa8c classmate-laptop: add support for Classmate PC ACPI devices
243e1ef Merge branch 'toshiba-bt' into release
d12d8ba X86 drivers: Introduce msi-wmi driver
42b4e9e Toshiba Bluetooth Enabling driver (RFKill handler v3)
9caeb53 topstar-laptop: add new driver for hotkeys support on Topstar
N01
e86435e acerhdf: Acer Aspire One fan control
2e33b23 Merge branch 'dell-wmi' into release
0b3f610 dell-wmi: new driver for hotkey control
03a971a thermal: support forcing support for passive cooling
b1569e9 ACPI: move thermal trip handling to generic thermal layer
6503e5d thermal: use integers rather than strings for thermal values
cad7312 dell-laptop: move to drivers/platform/x86/ from drivers/misc/
b4f9fe1 ACPI: move wmi, asus_acpi, toshiba_acpi to drivers/platform/x86
41b16dc create drivers/platform/x86/ from drivers/misc/
16d7523 thermal: Create CONFIG_THERMAL_HWMON=n
ff16cab69 thermal: re-name thermal.c to thermal_sys.c
e68b16a thermal: add hwmon sysfs I/F
9ec732f thermal: add new get_crit_temp callback
63c4ec9 thermal: add the support for building the generic thermal as a
module
5f1a3f2 acpi thermal trip points increased to 12
a0dd25b ACPI: thermal: buildfix for CONFIG_THERMAL=n
041d4bb ACPI: CELSIUS_TO_KELVIN fixup
203d3d4 the generic thermal sysfs driver

Signed-off-by: Sumeet Pawnikar <sumeet.r.pawnikar@intel.com>
---
 arch/x86/include/asm/intel_mid_thermal.h      |  77 ++
 .../device_libs/platform_msic_thermal.c       | 171 +++-
 .../device_libs/platform_msic_thermal.h       |   9 +
 drivers/platform/x86/Makefile                 |   1 -
 drivers/platform/x86/intel_mid_thermal.c      | 574 -------------
 drivers/thermal/intel_mid_thermal.c           | 754 ++++++++++++++++++
 drivers/thermal/thermal_core.c                |  79 ++
 include/linux/thermal.h                       |   4 +
 8 files changed, 1093 insertions(+), 576 deletions(-)
 create mode 100644 arch/x86/include/asm/intel_mid_thermal.h
 delete mode 100644 drivers/platform/x86/intel_mid_thermal.c
 create mode 100644 drivers/thermal/intel_mid_thermal.c

diff --git a/arch/x86/include/asm/intel_mid_thermal.h b/arch/x86/include/asm/intel_mid_thermal.h
new file mode 100644
index 000000000000..6a604a11e484
--- /dev/null
+++ b/arch/x86/include/asm/intel_mid_thermal.h
@@ -0,0 +1,77 @@
+#ifndef __INTEL_MID_THERMAL_H__
+#define __INTEL_MID_THERMAL_H__
+
+#include <linux/thermal.h>
+
+#define BPTHERM_NAME	"bptherm"
+#define SKIN0_NAME	"skin0"
+#define SKIN1_NAME	"skin1"
+#define MSIC_DIE_NAME	"msicdie"
+#define MSIC_SYS_NAME	"sys"
+#define SYSTHERM2       "systherm2"
+/**
+ * struct intel_mid_thermal_sensor - intel_mid_thermal sensor information
+ * @name:		name of the sensor
+ * @index:		index number of sensor
+ * @slope:		slope used for temp calculation
+ * @intercept:		intercept used for temp calculation
+ * @adc_channel:	adc channel id|flags
+ * @direct:		If true then direct conversion is used.
+ * @priv:		private sensor data
+ * @temp_correlation:	temp correlation function
+ */
+struct intel_mid_thermal_sensor {
+	char name[THERMAL_NAME_LENGTH];
+	int index;
+	long slope;
+	long intercept;
+	int adc_channel;
+	bool direct;
+	void *priv;
+	int (*temp_correlation)(void *info, long temp, long *res);
+};
+
+/**
+ * struct soc_throttle_data - SoC level power limits for thermal throttling
+ * @power_limit:	power limit value
+ * @floor_freq:		The CPU frequency may not go below this value
+ */
+struct soc_throttle_data {
+	int power_limit;
+	int floor_freq;
+};
+
+/**
+ * struct intel_mid_thermal_platform_data - Platform data for
+ *		intel mid thermal driver
+ *
+ * @num_sensors:	Maximum number of sensors supported
+ * @sensors:		sensor info
+ * @soc_cooling:	True or false
+ */
+struct intel_mid_thermal_platform_data {
+	int num_sensors;
+	struct intel_mid_thermal_sensor *sensors;
+	bool soc_cooling;
+};
+
+/**
+ * struct skin1_private_info - skin1 sensor private data
+ *
+ * @dependent:		dependency on other sensors
+			0   - no dependency,
+			> 0 - depends on other sensors
+ * @sensors:		dependent sensor address.
+ */
+struct skin1_private_info {
+	int dependent;
+	struct intel_mid_thermal_sensor **sensors;
+};
+
+/* skin0 sensor temperature correlation function*/
+int skin0_temp_correlation(void *info, long temp, long *res);
+/* skin1 sensor temperature correlation function*/
+int skin1_temp_correlation(void *info, long temp, long *res);
+/* bptherm sensor temperature correlation function*/
+int bptherm_temp_correlation(void *info, long temp, long *res);
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.c b/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.c
index dfdfdb978ac3..38968b02ad8a 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.c
@@ -17,10 +17,179 @@
 #include <linux/platform_device.h>
 #include <linux/mfd/intel_msic.h>
 #include <asm/intel-mid.h>
+#include <asm/intel_mid_gpadc.h>
+#include <asm/intel_mid_thermal.h>
+#include <linux/platform_data/intel_mid_remoteproc.h>
 #include "platform_msic.h"
 #include "platform_msic_thermal.h"
 
+/* ctp thermal sensor list */
+static struct intel_mid_thermal_sensor ctp_sensors[] = {
+	{
+		.name = SKIN0_NAME,
+		.index = 0,
+		.slope = 410,
+		.intercept = 16808,
+		.adc_channel = 0x04 | CH_NEED_VREF | CH_NEED_VCALIB,
+		.temp_correlation = skin0_temp_correlation,
+		.direct = false,
+	},
+	{
+		.name = SKIN1_NAME,
+		.index = 1,
+		.slope = 665,
+		.intercept = 8375,
+		.adc_channel = 0x04 | CH_NEED_VREF | CH_NEED_VCALIB,
+		.temp_correlation = skin0_temp_correlation,
+		.direct = false,
+	},
+	{
+		.name = MSIC_DIE_NAME,
+		.index = 2,
+		.slope = 368,
+		.intercept = 219560,
+		.adc_channel = 0x03 | CH_NEED_VCALIB,
+		.direct = true,
+	},
+	{
+		.name = BPTHERM_NAME,
+		.index = 3,
+		.slope = 788,
+		.intercept = 5065,
+		.adc_channel = 0x09 | CH_NEED_VREF | CH_NEED_VCALIB,
+		.temp_correlation = bptherm_temp_correlation,
+		.direct = false,
+	},
+
+};
+
+/* mfld thermal sensor list */
+static struct intel_mid_thermal_sensor mfld_sensors[] = {
+	{
+		.name = SKIN0_NAME,
+		.index = 0,
+		.slope = 851,
+		.intercept = 2800,
+		.adc_channel = 0x08 | CH_NEED_VREF | CH_NEED_VCALIB,
+		.temp_correlation = skin0_temp_correlation,
+		.direct = false,
+	},
+	{
+		.name = SKIN1_NAME,
+		.index = 1,
+		.slope = 806,
+		.intercept = 1800,
+		.adc_channel = 0x08 | CH_NEED_VREF | CH_NEED_VCALIB,
+		.temp_correlation = skin1_temp_correlation,
+		.direct = false,
+	},
+	{
+		.name = MSIC_SYS_NAME,
+		.index = 2,
+		.slope = 0,
+		.intercept = 0,
+		.adc_channel = 0x0A | CH_NEED_VREF | CH_NEED_VCALIB,
+		.direct = false,
+	},
+	{
+		.name = MSIC_DIE_NAME,
+		.index = 3,
+		.slope = 368,
+		.intercept = 219560,
+		.adc_channel = 0x03 | CH_NEED_VCALIB,
+		.direct = true,
+	},
+
+};
+
+/* LEX thermal sensor list */
+static struct intel_mid_thermal_sensor lex_sensors[] = {
+	{
+		.name = SKIN0_NAME,
+		.index = 0,
+		.slope = 851,
+		.intercept = 2800,
+		.adc_channel = 0x08 | CH_NEED_VREF | CH_NEED_VCALIB,
+		.temp_correlation = skin0_temp_correlation,
+		.direct = false,
+	},
+	{
+		.name = SKIN1_NAME,
+		.index = 1,
+		.slope = 806,
+		.intercept = 1800,
+		.adc_channel = 0x08 | CH_NEED_VREF | CH_NEED_VCALIB,
+		.temp_correlation = skin1_temp_correlation,
+		.direct = false,
+	},
+	{
+		.name = MSIC_SYS_NAME,
+		.index = 2,
+		.slope = 0,
+		.intercept = 0,
+		.adc_channel = 0x0A | CH_NEED_VREF | CH_NEED_VCALIB,
+		.direct = false,
+	},
+	{
+		.name = MSIC_DIE_NAME,
+		.index = 3,
+		.slope = 368,
+		.intercept = 219560,
+		.adc_channel = 0x03 | CH_NEED_VCALIB,
+		.direct = true,
+	},
+
+};
+
+
+static struct intel_mid_thermal_platform_data pdata[] = {
+	[mfld_thermal] = {
+		.num_sensors = 4,
+		.sensors = mfld_sensors,
+		.soc_cooling = false,
+	},
+	[ctp_thermal] = {
+		.num_sensors = 4,
+		.sensors = ctp_sensors,
+		.soc_cooling = true,
+	},
+	[lex_thermal] = {
+		.num_sensors = 4,
+		.sensors = lex_sensors,
+		.soc_cooling = false,
+	},
+};
+
 void __init *msic_thermal_platform_data(void *info)
 {
-	return msic_generic_platform_data(info, INTEL_MSIC_BLOCK_THERMAL);
+	struct platform_device *pdev;
+
+	pdev = platform_device_alloc(MSIC_THERM_DEV_NAME, -1);
+	if (!pdev) {
+		pr_err("out of memory for SFI platform dev %s\n",
+			MSIC_THERM_DEV_NAME);
+		return NULL;
+	}
+
+	if (platform_device_add(pdev)) {
+		pr_err("failed to add thermal platform device\n");
+		platform_device_put(pdev);
+		return NULL;
+	}
+
+	if (INTEL_MID_BOARD(2, PHONE, CLVTP, VB, PRO) ||
+		INTEL_MID_BOARD(2, PHONE, CLVTP, VB, ENG))
+		pdev->dev.platform_data = &pdata[vb_thermal];
+	else if (INTEL_MID_BOARD(1, PHONE, CLVTP) ||
+			(INTEL_MID_BOARD(1, TABLET, CLVT)))
+		pdev->dev.platform_data = &pdata[ctp_thermal];
+	else if (INTEL_MID_BOARD(2, PHONE, MFLD, LEX, ENG) ||
+			(INTEL_MID_BOARD(2, PHONE, MFLD, LEX, PRO)))
+		pdev->dev.platform_data = &pdata[lex_thermal];
+	else
+		pdev->dev.platform_data = &pdata[mfld_thermal];
+
+	register_rpmsg_service("rpmsg_mid_thermal", RPROC_SCU, RP_MSIC_THERMAL);
+
+	return 0;
 }
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.h b/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.h
index eb8e087c5286..c4f34048d479 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.h
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.h
@@ -12,6 +12,15 @@
 #ifndef _PLATFORM_MSIC_THERMAL_H_
 #define _PLATFORM_MSIC_THERMAL_H_
 
+#define MSIC_THERM_DEV_NAME "msic_thermal"
+
 extern void __init *msic_thermal_platform_data(void *info)
 			__attribute__((weak));
+enum {
+	mfld_thermal,
+	ctp_thermal,
+	lex_thermal,
+	vb_thermal,
+};
+
 #endif
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index e4b09644c0ba..c075bb2e8c8a 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -39,7 +39,6 @@ obj-$(CONFIG_TOSHIBA_BT_RFKILL)	+= toshiba_bluetooth.o
 obj-$(CONFIG_INTEL_SCU_IPC)	+= intel_scu_ipc.o intel_scu_pmic.o intel_scu_mip.o intel_scu_fw_update.o
 obj-$(CONFIG_INTEL_SCU_IPC_UTIL) += intel_scu_ipcutil.o
 obj-$(CONFIG_INTEL_SCU_FLIS)	+= intel_scu_flis.o
-obj-$(CONFIG_INTEL_MFLD_THERMAL) += intel_mid_thermal.o
 obj-$(CONFIG_INTEL_IPS)		+= intel_ips.o
 obj-$(CONFIG_GPIO_INTEL_PMIC)	+= intel_pmic_gpio.o
 obj-$(CONFIG_XO1_RFKILL)	+= xo1-rfkill.o
diff --git a/drivers/platform/x86/intel_mid_thermal.c b/drivers/platform/x86/intel_mid_thermal.c
deleted file mode 100644
index 81c491e74b34..000000000000
--- a/drivers/platform/x86/intel_mid_thermal.c
+++ /dev/null
@@ -1,574 +0,0 @@
-/*
- * intel_mid_thermal.c - Intel MID platform thermal driver
- *
- * Copyright (C) 2011 Intel Corporation
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.        See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- * Author: Durgadoss R <durgadoss.r@intel.com>
- */
-
-#define pr_fmt(fmt) "intel_mid_thermal: " fmt
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/err.h>
-#include <linux/param.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/pm.h>
-#include <linux/thermal.h>
-#include <linux/mfd/intel_msic.h>
-
-/* Number of thermal sensors */
-#define MSIC_THERMAL_SENSORS	4
-
-/* ADC1 - thermal registers */
-#define MSIC_ADC_ENBL		0x10
-#define MSIC_ADC_START		0x08
-
-#define MSIC_ADCTHERM_ENBL	0x04
-#define MSIC_ADCRRDATA_ENBL	0x05
-#define MSIC_CHANL_MASK_VAL	0x0F
-
-#define MSIC_STOPBIT_MASK	16
-#define MSIC_ADCTHERM_MASK	4
-/* Number of ADC channels */
-#define ADC_CHANLS_MAX		15
-#define ADC_LOOP_MAX		(ADC_CHANLS_MAX - MSIC_THERMAL_SENSORS)
-
-/* ADC channel code values */
-#define SKIN_SENSOR0_CODE	0x08
-#define SKIN_SENSOR1_CODE	0x09
-#define SYS_SENSOR_CODE		0x0A
-#define MSIC_DIE_SENSOR_CODE	0x03
-
-#define SKIN_THERM_SENSOR0	0
-#define SKIN_THERM_SENSOR1	1
-#define SYS_THERM_SENSOR2	2
-#define MSIC_DIE_THERM_SENSOR3	3
-
-/* ADC code range */
-#define ADC_MAX			977
-#define ADC_MIN			162
-#define ADC_VAL0C		887
-#define ADC_VAL20C		720
-#define ADC_VAL40C		508
-#define ADC_VAL60C		315
-
-/* ADC base addresses */
-#define ADC_CHNL_START_ADDR	INTEL_MSIC_ADC1ADDR0	/* increments by 1 */
-#define ADC_DATA_START_ADDR	INTEL_MSIC_ADC1SNS0H	/* increments by 2 */
-
-/* MSIC die attributes */
-#define MSIC_DIE_ADC_MIN	488
-#define MSIC_DIE_ADC_MAX	1004
-
-/* This holds the address of the first free ADC channel,
- * among the 15 channels
- */
-static int channel_index;
-
-struct platform_info {
-	struct platform_device *pdev;
-	struct thermal_zone_device *tzd[MSIC_THERMAL_SENSORS];
-};
-
-struct thermal_device_info {
-	unsigned int chnl_addr;
-	int direct;
-	/* This holds the current temperature in millidegree celsius */
-	long curr_temp;
-};
-
-/**
- * to_msic_die_temp - converts adc_val to msic_die temperature
- * @adc_val: ADC value to be converted
- *
- * Can sleep
- */
-static int to_msic_die_temp(uint16_t adc_val)
-{
-	return (368 * (adc_val) / 1000) - 220;
-}
-
-/**
- * is_valid_adc - checks whether the adc code is within the defined range
- * @min: minimum value for the sensor
- * @max: maximum value for the sensor
- *
- * Can sleep
- */
-static int is_valid_adc(uint16_t adc_val, uint16_t min, uint16_t max)
-{
-	return (adc_val >= min) && (adc_val <= max);
-}
-
-/**
- * adc_to_temp - converts the ADC code to temperature in C
- * @direct: true if ths channel is direct index
- * @adc_val: the adc_val that needs to be converted
- * @tp: temperature return value
- *
- * Linear approximation is used to covert the skin adc value into temperature.
- * This technique is used to avoid very long look-up table to get
- * the appropriate temp value from ADC value.
- * The adc code vs sensor temp curve is split into five parts
- * to achieve very close approximate temp value with less than
- * 0.5C error
- */
-static int adc_to_temp(int direct, uint16_t adc_val, unsigned long *tp)
-{
-	int temp;
-
-	/* Direct conversion for die temperature */
-	if (direct) {
-		if (is_valid_adc(adc_val, MSIC_DIE_ADC_MIN, MSIC_DIE_ADC_MAX)) {
-			*tp = to_msic_die_temp(adc_val) * 1000;
-			return 0;
-		}
-		return -ERANGE;
-	}
-
-	if (!is_valid_adc(adc_val, ADC_MIN, ADC_MAX))
-		return -ERANGE;
-
-	/* Linear approximation for skin temperature */
-	if (adc_val > ADC_VAL0C)
-		temp = 177 - (adc_val/5);
-	else if ((adc_val <= ADC_VAL0C) && (adc_val > ADC_VAL20C))
-		temp = 111 - (adc_val/8);
-	else if ((adc_val <= ADC_VAL20C) && (adc_val > ADC_VAL40C))
-		temp = 92 - (adc_val/10);
-	else if ((adc_val <= ADC_VAL40C) && (adc_val > ADC_VAL60C))
-		temp = 91 - (adc_val/10);
-	else
-		temp = 112 - (adc_val/6);
-
-	/* Convert temperature in celsius to milli degree celsius */
-	*tp = temp * 1000;
-	return 0;
-}
-
-/**
- * mid_read_temp - read sensors for temperature
- * @temp: holds the current temperature for the sensor after reading
- *
- * reads the adc_code from the channel and converts it to real
- * temperature. The converted value is stored in temp.
- *
- * Can sleep
- */
-static int mid_read_temp(struct thermal_zone_device *tzd, unsigned long *temp)
-{
-	struct thermal_device_info *td_info = tzd->devdata;
-	uint16_t adc_val, addr;
-	uint8_t data = 0;
-	int ret;
-	unsigned long curr_temp;
-
-
-	addr = td_info->chnl_addr;
-
-	/* Enable the msic for conversion before reading */
-	ret = intel_msic_reg_write(INTEL_MSIC_ADC1CNTL3, MSIC_ADCRRDATA_ENBL);
-	if (ret)
-		return ret;
-
-	/* Re-toggle the RRDATARD bit (temporary workaround) */
-	ret = intel_msic_reg_write(INTEL_MSIC_ADC1CNTL3, MSIC_ADCTHERM_ENBL);
-	if (ret)
-		return ret;
-
-	/* Read the higher bits of data */
-	ret = intel_msic_reg_read(addr, &data);
-	if (ret)
-		return ret;
-
-	/* Shift bits to accommodate the lower two data bits */
-	adc_val = (data << 2);
-	addr++;
-
-	ret = intel_msic_reg_read(addr, &data);/* Read lower bits */
-	if (ret)
-		return ret;
-
-	/* Adding lower two bits to the higher bits */
-	data &= 03;
-	adc_val += data;
-
-	/* Convert ADC value to temperature */
-	ret = adc_to_temp(td_info->direct, adc_val, &curr_temp);
-	if (ret == 0)
-		*temp = td_info->curr_temp = curr_temp;
-	return ret;
-}
-
-/**
- * configure_adc - enables/disables the ADC for conversion
- * @val: zero: disables the ADC non-zero:enables the ADC
- *
- * Enable/Disable the ADC depending on the argument
- *
- * Can sleep
- */
-static int configure_adc(int val)
-{
-	int ret;
-	uint8_t data;
-
-	ret = intel_msic_reg_read(INTEL_MSIC_ADC1CNTL1, &data);
-	if (ret)
-		return ret;
-
-	if (val) {
-		/* Enable and start the ADC */
-		data |= (MSIC_ADC_ENBL | MSIC_ADC_START);
-	} else {
-		/* Just stop the ADC */
-		data &= (~MSIC_ADC_START);
-	}
-	return intel_msic_reg_write(INTEL_MSIC_ADC1CNTL1, data);
-}
-
-/**
- * set_up_therm_channel - enable thermal channel for conversion
- * @base_addr: index of free msic ADC channel
- *
- * Enable all the three channels for conversion
- *
- * Can sleep
- */
-static int set_up_therm_channel(u16 base_addr)
-{
-	int ret;
-
-	/* Enable all the sensor channels */
-	ret = intel_msic_reg_write(base_addr, SKIN_SENSOR0_CODE);
-	if (ret)
-		return ret;
-
-	ret = intel_msic_reg_write(base_addr + 1, SKIN_SENSOR1_CODE);
-	if (ret)
-		return ret;
-
-	ret = intel_msic_reg_write(base_addr + 2, SYS_SENSOR_CODE);
-	if (ret)
-		return ret;
-
-	/* Since this is the last channel, set the stop bit
-	 * to 1 by ORing the DIE_SENSOR_CODE with 0x10 */
-	ret = intel_msic_reg_write(base_addr + 3,
-			(MSIC_DIE_SENSOR_CODE | 0x10));
-	if (ret)
-		return ret;
-
-	/* Enable ADC and start it */
-	return configure_adc(1);
-}
-
-/**
- * reset_stopbit - sets the stop bit to 0 on the given channel
- * @addr: address of the channel
- *
- * Can sleep
- */
-static int reset_stopbit(uint16_t addr)
-{
-	int ret;
-	uint8_t data;
-	ret = intel_msic_reg_read(addr, &data);
-	if (ret)
-		return ret;
-	/* Set the stop bit to zero */
-	return intel_msic_reg_write(addr, (data & 0xEF));
-}
-
-/**
- * find_free_channel - finds an empty channel for conversion
- *
- * If the ADC is not enabled then start using 0th channel
- * itself. Otherwise find an empty channel by looking for a
- * channel in which the stopbit is set to 1. returns the index
- * of the first free channel if succeeds or an error code.
- *
- * Context: can sleep
- *
- * FIXME: Ultimately the channel allocator will move into the intel_scu_ipc
- * code.
- */
-static int find_free_channel(void)
-{
-	int ret;
-	int i;
-	uint8_t data;
-
-	/* check whether ADC is enabled */
-	ret = intel_msic_reg_read(INTEL_MSIC_ADC1CNTL1, &data);
-	if (ret)
-		return ret;
-
-	if ((data & MSIC_ADC_ENBL) == 0)
-		return 0;
-
-	/* ADC is already enabled; Looking for an empty channel */
-	for (i = 0; i < ADC_CHANLS_MAX; i++) {
-		ret = intel_msic_reg_read(ADC_CHNL_START_ADDR + i, &data);
-		if (ret)
-			return ret;
-
-		if (data & MSIC_STOPBIT_MASK) {
-			ret = i;
-			break;
-		}
-	}
-	return (ret > ADC_LOOP_MAX) ? (-EINVAL) : ret;
-}
-
-/**
- * mid_initialize_adc - initializing the ADC
- * @dev: our device structure
- *
- * Initialize the ADC for reading thermistor values. Can sleep.
- */
-static int mid_initialize_adc(struct device *dev)
-{
-	u8  data;
-	u16 base_addr;
-	int ret;
-
-	/*
-	 * Ensure that adctherm is disabled before we
-	 * initialize the ADC
-	 */
-	ret = intel_msic_reg_read(INTEL_MSIC_ADC1CNTL3, &data);
-	if (ret)
-		return ret;
-
-	data &= ~MSIC_ADCTHERM_MASK;
-	ret = intel_msic_reg_write(INTEL_MSIC_ADC1CNTL3, data);
-	if (ret)
-		return ret;
-
-	/* Index of the first channel in which the stop bit is set */
-	channel_index = find_free_channel();
-	if (channel_index < 0) {
-		dev_err(dev, "No free ADC channels");
-		return channel_index;
-	}
-
-	base_addr = ADC_CHNL_START_ADDR + channel_index;
-
-	if (!(channel_index == 0 || channel_index == ADC_LOOP_MAX)) {
-		/* Reset stop bit for channels other than 0 and 12 */
-		ret = reset_stopbit(base_addr);
-		if (ret)
-			return ret;
-
-		/* Index of the first free channel */
-		base_addr++;
-		channel_index++;
-	}
-
-	ret = set_up_therm_channel(base_addr);
-	if (ret) {
-		dev_err(dev, "unable to enable ADC");
-		return ret;
-	}
-	dev_dbg(dev, "ADC initialization successful");
-	return ret;
-}
-
-/**
- * initialize_sensor - sets default temp and timer ranges
- * @index: index of the sensor
- *
- * Context: can sleep
- */
-static struct thermal_device_info *initialize_sensor(int index)
-{
-	struct thermal_device_info *td_info =
-		kzalloc(sizeof(struct thermal_device_info), GFP_KERNEL);
-
-	if (!td_info)
-		return NULL;
-
-	/* Set the base addr of the channel for this sensor */
-	td_info->chnl_addr = ADC_DATA_START_ADDR + 2 * (channel_index + index);
-	/* Sensor 3 is direct conversion */
-	if (index == 3)
-		td_info->direct = 1;
-	return td_info;
-}
-
-/**
- * mid_thermal_resume - resume routine
- * @dev: device structure
- *
- * mid thermal resume: re-initializes the adc. Can sleep.
- */
-static int mid_thermal_resume(struct device *dev)
-{
-	return mid_initialize_adc(dev);
-}
-
-/**
- * mid_thermal_suspend - suspend routine
- * @dev: device structure
- *
- * mid thermal suspend implements the suspend functionality
- * by stopping the ADC. Can sleep.
- */
-static int mid_thermal_suspend(struct device *dev)
-{
-	/*
-	 * This just stops the ADC and does not disable it.
-	 * temporary workaround until we have a generic ADC driver.
-	 * If 0 is passed, it disables the ADC.
-	 */
-	return configure_adc(0);
-}
-
-static SIMPLE_DEV_PM_OPS(mid_thermal_pm,
-			 mid_thermal_suspend, mid_thermal_resume);
-
-/**
- * read_curr_temp - reads the current temperature and stores in temp
- * @temp: holds the current temperature value after reading
- *
- * Can sleep
- */
-static int read_curr_temp(struct thermal_zone_device *tzd, unsigned long *temp)
-{
-	WARN_ON(tzd == NULL);
-	return mid_read_temp(tzd, temp);
-}
-
-/* Can't be const */
-static struct thermal_zone_device_ops tzd_ops = {
-	.get_temp = read_curr_temp,
-};
-
-/**
- * mid_thermal_probe - mfld thermal initialize
- * @pdev: platform device structure
- *
- * mid thermal probe initializes the hardware and registers
- * all the sensors with the generic thermal framework. Can sleep.
- */
-static int mid_thermal_probe(struct platform_device *pdev)
-{
-	static char *name[MSIC_THERMAL_SENSORS] = {
-		"skin0", "skin1", "sys", "msicdie"
-	};
-
-	int ret;
-	int i;
-	struct platform_info *pinfo;
-
-	pinfo = kzalloc(sizeof(struct platform_info), GFP_KERNEL);
-	if (!pinfo)
-		return -ENOMEM;
-
-	/* Initializing the hardware */
-	ret = mid_initialize_adc(&pdev->dev);
-	if (ret) {
-		dev_err(&pdev->dev, "ADC init failed");
-		kfree(pinfo);
-		return ret;
-	}
-
-	/* Register each sensor with the generic thermal framework*/
-	for (i = 0; i < MSIC_THERMAL_SENSORS; i++) {
-		struct thermal_device_info *td_info = initialize_sensor(i);
-
-		if (!td_info) {
-			ret = -ENOMEM;
-			goto err;
-		}
-		pinfo->tzd[i] = thermal_zone_device_register(name[i],
-				0, 0, td_info, &tzd_ops, NULL, 0, 0);
-		if (IS_ERR(pinfo->tzd[i])) {
-			kfree(td_info);
-			ret = PTR_ERR(pinfo->tzd[i]);
-			goto err;
-		}
-	}
-
-	pinfo->pdev = pdev;
-	platform_set_drvdata(pdev, pinfo);
-	return 0;
-
-err:
-	while (--i >= 0) {
-		kfree(pinfo->tzd[i]->devdata);
-		thermal_zone_device_unregister(pinfo->tzd[i]);
-	}
-	configure_adc(0);
-	kfree(pinfo);
-	return ret;
-}
-
-/**
- * mid_thermal_remove - mfld thermal finalize
- * @dev: platform device structure
- *
- * MLFD thermal remove unregisters all the sensors from the generic
- * thermal framework. Can sleep.
- */
-static int mid_thermal_remove(struct platform_device *pdev)
-{
-	int i;
-	struct platform_info *pinfo = platform_get_drvdata(pdev);
-
-	for (i = 0; i < MSIC_THERMAL_SENSORS; i++) {
-		kfree(pinfo->tzd[i]->devdata);
-		thermal_zone_device_unregister(pinfo->tzd[i]);
-	}
-
-	kfree(pinfo);
-	platform_set_drvdata(pdev, NULL);
-
-	/* Stop the ADC */
-	return configure_adc(0);
-}
-
-#define DRIVER_NAME "msic_thermal"
-
-static const struct platform_device_id therm_id_table[] = {
-	{ DRIVER_NAME, 1 },
-	{ "msic_thermal", 1 },
-	{ }
-};
-
-static struct platform_driver mid_thermal_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-		.pm = &mid_thermal_pm,
-	},
-	.probe = mid_thermal_probe,
-	.remove = mid_thermal_remove,
-	.id_table = therm_id_table,
-};
-
-module_platform_driver(mid_thermal_driver);
-
-MODULE_AUTHOR("Durgadoss R <durgadoss.r@intel.com>");
-MODULE_DESCRIPTION("Intel Medfield Platform Thermal Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/thermal/intel_mid_thermal.c b/drivers/thermal/intel_mid_thermal.c
new file mode 100644
index 000000000000..d577046247a0
--- /dev/null
+++ b/drivers/thermal/intel_mid_thermal.c
@@ -0,0 +1,754 @@
+/*
+ * intel_mid_thermal.c - Intel MID platform thermal driver
+ *
+ * Copyright (C) 2010 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Ananth Krishna <ananth.krishna.r@intel.com>
+ * Author: Durgadoss <durgadoss.r@intel.com>
+ */
+
+#define pr_fmt(fmt)  "intel_mid_thermal: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/param.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/rpmsg.h>
+
+#include <linux/slab.h>
+#include <linux/pm.h>
+#include <linux/thermal.h>
+
+#include <asm/intel_scu_ipc.h>
+#include <asm/intel_mid_gpadc.h>
+#include <asm/intel_mid_thermal.h>
+#include <asm/intel_mid_rpmsg.h>
+
+#define DRIVER_NAME "msic_thermal"
+
+/* Cooling device attributes */
+#define SOC_IPC_COMMAND		0xCF
+
+enum {
+	NORMAL = 0,
+	WARNING,
+	ALERT,
+	CRITICAL
+} thermal_state;
+
+enum {
+	SOC_SKIN_NORMAL = 0,
+	SOC_SKIN_WARM = 2,
+	SOC_SKIN_PROCHOT,
+	SOC_MAX_STATES
+} soc_skin_state;
+
+/* MSIC die attributes */
+#define MSIC_DIE_ADC_MIN	488
+#define MSIC_DIE_ADC_MAX	1004
+
+#define TABLE_LENGTH 24
+/*
+ * ADC code vs Temperature table
+ * This table will be different for different thermistors
+ * Row 0: ADC code
+ * Row 1: Temperature (in degree celsius)
+ */
+static const int adc_code[2][TABLE_LENGTH] = {
+	{977, 961, 941, 917, 887, 853, 813, 769, 720, 669, 615, 561, 508, 456,
+		407, 357, 315, 277, 243, 212, 186, 162, 140, 107},
+	{-20, -15, -10, -5, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60,
+		65, 70, 75, 80, 85, 90, 100},
+	};
+
+struct ts_cache_info {
+	bool is_cached_data_initialized;
+	struct mutex lock;
+	int *cached_values;
+	unsigned long last_updated;
+};
+
+struct soc_cooling_device_info {
+	unsigned long soc_state;
+	struct mutex lock_cool_state;
+};
+
+static struct soc_cooling_device_info soc_cdev_info;
+
+struct platform_info {
+	struct platform_device *pdev;
+	struct thermal_zone_device **tzd;
+	struct ts_cache_info cacheinfo;
+	/* ADC handle used to read sensor temperature values */
+	void *therm_adc_handle;
+	struct thermal_cooling_device *soc_cdev;
+	int num_sensors;
+	int soc_cooling;
+	struct intel_mid_thermal_sensor *sensors;
+};
+
+static struct platform_info *platforminfo;
+
+struct thermal_device_info {
+	struct intel_mid_thermal_sensor *sensor;
+};
+
+/* SoC cooling device callbacks */
+static int soc_get_max_state(struct thermal_cooling_device *cdev,
+				unsigned long *state)
+{
+	/* SoC has 4 levels of throttling from 0 to 3 */
+	*state = SOC_MAX_STATES - 1;
+	return 0;
+}
+
+static int soc_get_cur_state(struct thermal_cooling_device *cdev,
+				unsigned long *state)
+{
+	mutex_lock(&soc_cdev_info.lock_cool_state);
+	*state = soc_cdev_info.soc_state;
+	mutex_unlock(&soc_cdev_info.lock_cool_state);
+	return 0;
+}
+
+static int soc_set_cur_state(struct thermal_cooling_device *cdev,
+				unsigned long state)
+{
+	int ret;
+	if (state > SOC_MAX_STATES - 1) {
+		pr_err("Invalid SoC throttle state:%ld\n", state);
+		return -EINVAL;
+	}
+
+	switch (state) {
+	/* SoC De-Throttle */
+	case NORMAL:
+		state = SOC_SKIN_NORMAL;
+		break;
+	case WARNING:
+		/*
+		 * New state is assigned based on present state.
+		 * State 1 can be reached from state 0 or 2.
+		 * State 0 to 1 means skin WARM.
+		 * state 2 to 1 means skin no longer PROCHOT but WARM
+		 */
+		state = SOC_SKIN_WARM;
+		break;
+	/* SoC Throttle, PROCHOT */
+	case ALERT:
+	case CRITICAL:
+		state = SOC_SKIN_PROCHOT;
+		break;
+	}
+	/* Send IPC command to throttle SoC */
+	mutex_lock(&soc_cdev_info.lock_cool_state);
+	ret = rpmsg_send_generic_command(SOC_IPC_COMMAND, 0,
+			(u8 *) &state, 4, NULL, 0);
+	if (ret)
+		pr_err("IPC_COMMAND failed: %d\n", ret);
+	else
+		soc_cdev_info.soc_state = state;
+
+	mutex_unlock(&soc_cdev_info.lock_cool_state);
+	return ret;
+}
+
+static struct thermal_cooling_device_ops soc_cooling_ops = {
+	.get_max_state = soc_get_max_state,
+	.get_cur_state = soc_get_cur_state,
+	.set_cur_state = soc_set_cur_state,
+};
+
+static int register_soc_as_cdev(void)
+{
+	int ret = 0;
+	platforminfo->soc_cdev = thermal_cooling_device_register("SoC", NULL,
+						&soc_cooling_ops);
+	if (IS_ERR(platforminfo->soc_cdev)) {
+		ret = PTR_ERR(platforminfo->soc_cdev);
+		platforminfo->soc_cdev = NULL;
+	}
+	return ret;
+}
+
+static void unregister_soc_as_cdev(void)
+{
+	thermal_cooling_device_unregister(platforminfo->soc_cdev);
+}
+
+/**
+ * is_valid_adc - checks whether the adc code is within the defined range
+ * @min: minimum value for the sensor
+ * @max: maximum value for the sensor
+ *
+ * Can sleep
+ */
+static int is_valid_adc(uint16_t adc_val, uint16_t min, uint16_t max)
+{
+	return (adc_val >= min) && (adc_val <= max);
+}
+
+/**
+ * find_adc_code - searches the ADC code using binary search
+ * @val: value to find in the array
+ *
+ * This function does binary search on an array sorted in 'descending' order
+ * Can sleep
+ */
+static int find_adc_code(uint16_t val)
+{
+	int left = 0;
+	int right = TABLE_LENGTH - 1;
+	int mid;
+	while (left <= right) {
+		mid = (left + right)/2;
+		if (val == adc_code[0][mid] ||
+			(mid > 0 &&
+			val > adc_code[0][mid] && val < adc_code[0][mid-1]))
+			return mid;
+		else if (val > adc_code[0][mid])
+			right = mid - 1;
+		else if (val < adc_code[0][mid])
+			left = mid + 1;
+	}
+	return -1;
+}
+
+/**
+ * linear_interpolate - does interpolation to find temperature
+ * Returns the temperature in milli degree celsius
+ * @adc_val: ADC code(x) at which temperature(y) should be found
+ * @indx: index of the minimum(x0) of the two ADC codes
+ *
+ * Can sleep
+ */
+static int linear_interpolate(int indx, uint16_t adc_val)
+{
+	int x = adc_val;
+	int x0 = adc_code[0][indx];
+	int x1 = adc_code[0][indx - 1];
+	int y0 = adc_code[1][indx];
+	int y1 = adc_code[1][indx - 1];
+
+	/*
+	 * Find y:
+	 * Of course, we can avoid these variables, but keep them
+	 * for readability and maintainability.
+	 */
+	int numerator = (x-x0)*y1 + (x1-x)*y0;
+	int denominator = x1-x0;
+
+	/*
+	 * We have to report the temperature in milli degree celsius.
+	 * So, to reduce the loss of precision, do (Nr*1000)/Dr, instead
+	 * of (Nr/Dr)*1000.
+	 */
+	 return (numerator * 1000)/denominator;
+}
+
+/**
+ * adc_to_temp - converts the ADC code to temperature in C
+ * @direct: true if ths channel is direct index
+ * @adc_val: the adc_val that needs to be converted
+ * @tp: temperature return value
+ *
+ * Can sleep
+ */
+static int adc_to_temp(struct intel_mid_thermal_sensor *sensor,
+		uint16_t adc_val, long *tp)
+{
+	int indx;
+
+	/* Direct conversion for msic die temperature */
+	if (sensor->direct) {
+		if (is_valid_adc(adc_val, MSIC_DIE_ADC_MIN, MSIC_DIE_ADC_MAX)) {
+			*tp = sensor->slope * adc_val - sensor->intercept;
+			return 0;
+		}
+		return -ERANGE;
+	}
+
+	indx = find_adc_code(adc_val);
+	if (indx < 0)
+		return -ERANGE;
+
+	if (adc_code[0][indx] == adc_val) {
+		/* Convert temperature in celsius to milli degree celsius */
+		*tp = adc_code[1][indx] * 1000;
+		return 0;
+	}
+
+	/*
+	 * The ADC code is in between two values directly defined in the
+	 * table. So, do linear interpolation to calculate the temperature.
+	 */
+	*tp = linear_interpolate(indx, adc_val);
+	return 0;
+}
+
+int skin0_temp_correlation(void *info, long temp, long *res)
+{
+	struct intel_mid_thermal_sensor *sensor = info;
+
+	*res = ((temp * sensor->slope) / 1000) + sensor->intercept;
+
+	return 0;
+}
+
+int bptherm_temp_correlation(void *info, long temp, long *res)
+{
+	struct intel_mid_thermal_sensor *sensor = info;
+
+	*res = ((temp * sensor->slope) / 1000) + sensor->intercept;
+
+	return 0;
+}
+
+int skin1_temp_correlation(void *info, long temp, long *res)
+{
+	struct intel_mid_thermal_sensor *sensor = info;
+	struct intel_mid_thermal_sensor *dsensor; /* dependent sensor */
+	struct skin1_private_info *skin_info;
+	long sensor_temp = 0, curr_temp;
+	int ret, index;
+
+	skin_info = sensor->priv;
+
+	*res = ((temp * sensor->slope) / 1000) + sensor->intercept;
+
+	/* If we do not have dependent sensors, just return. Not an error */
+	if (!skin_info || !skin_info->dependent || !skin_info->sensors)
+		return 0;
+
+	for (index = 0; index < skin_info->dependent; index++) {
+		if (!skin_info->sensors[index])
+			continue;
+
+		dsensor = skin_info->sensors[index];
+
+		ret = adc_to_temp(dsensor,
+			platforminfo->cacheinfo.cached_values[dsensor->index],
+			&curr_temp);
+		if (ret)
+			return ret;
+
+		if (dsensor->temp_correlation)
+			dsensor->temp_correlation(dsensor, curr_temp,
+						&sensor_temp);
+
+		if (sensor_temp > *res)
+			*res = sensor_temp;
+	}
+
+	return 0;
+}
+
+/**
+ * mid_read_temp - read sensors for temperature
+ * @temp: holds the current temperature for the sensor after reading
+ *
+ * reads the adc_code from the channel and converts it to real
+ * temperature. The converted value is stored in temp.
+ *
+ * Can sleep
+ */
+static int mid_read_temp(struct thermal_zone_device *tzd, long *temp)
+{
+	struct thermal_device_info *td_info = tzd->devdata;
+	int ret;
+	long curr_temp;
+	int indx = td_info->sensor->index; /* Required Index */
+
+	mutex_lock(&platforminfo->cacheinfo.lock);
+
+	if (!platforminfo->cacheinfo.is_cached_data_initialized ||
+	time_after(jiffies, platforminfo->cacheinfo.last_updated + HZ)) {
+		ret = get_gpadc_sample(platforminfo->therm_adc_handle, 1,
+					platforminfo->cacheinfo.cached_values);
+		if (ret)
+			goto exit;
+		platforminfo->cacheinfo.last_updated = jiffies;
+		platforminfo->cacheinfo.is_cached_data_initialized = true;
+	}
+
+	/* Convert ADC value to temperature */
+	ret = adc_to_temp(td_info->sensor,
+		platforminfo->cacheinfo.cached_values[indx], &curr_temp);
+	if (ret)
+		goto exit;
+
+	if (td_info->sensor->temp_correlation)
+		ret = td_info->sensor->temp_correlation(td_info->sensor,
+							curr_temp, temp);
+	else
+		*temp = curr_temp;
+
+exit:
+	mutex_unlock(&platforminfo->cacheinfo.lock);
+	return ret;
+}
+
+/**
+ * initialize_sensor - Initializes ADC information for each sensor.
+ * @index: index of the sensor
+ *
+ * Context: can sleep
+ */
+static struct thermal_device_info *initialize_sensor(
+			struct intel_mid_thermal_sensor *sensor)
+{
+	struct thermal_device_info *td_info =
+		kzalloc(sizeof(struct thermal_device_info), GFP_KERNEL);
+
+	if (!td_info)
+		return NULL;
+
+	td_info->sensor = sensor;
+
+	return td_info;
+}
+
+/**
+ * mid_thermal_resume - resume routine
+ * @dev: device structure
+ */
+static int mid_thermal_resume(struct device *dev)
+{
+	return 0;
+}
+
+/**
+ * mid_thermal_suspend - suspend routine
+ * @dev: device structure
+ */
+static int mid_thermal_suspend(struct device *dev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_DEBUG_THERMAL
+static int read_slope(struct thermal_zone_device *tzd, long *slope)
+{
+	struct thermal_device_info *td_info = tzd->devdata;
+
+	*slope = td_info->sensor->slope;
+
+	return 0;
+}
+
+static int update_slope(struct thermal_zone_device *tzd, long slope)
+{
+	struct thermal_device_info *td_info = tzd->devdata;
+
+	td_info->sensor->slope = slope;
+
+	return 0;
+}
+
+static int read_intercept(struct thermal_zone_device *tzd, long *intercept)
+{
+	struct thermal_device_info *td_info = tzd->devdata;
+
+	*intercept = td_info->sensor->intercept;
+
+	return 0;
+}
+
+static int update_intercept(struct thermal_zone_device *tzd, long intercept)
+{
+	struct thermal_device_info *td_info = tzd->devdata;
+
+	td_info->sensor->intercept = intercept;
+
+	return 0;
+}
+#endif
+
+/**
+ * read_curr_temp - reads the current temperature and stores in temp
+ * @temp: holds the current temperature value after reading
+ *
+ * Can sleep
+ */
+static int read_curr_temp(struct thermal_zone_device *tzd, long *temp)
+{
+	return (tzd) ? mid_read_temp(tzd, temp) : -EINVAL;
+}
+
+/* Can't be const */
+static struct thermal_zone_device_ops tzd_ops = {
+	.get_temp = read_curr_temp,
+#ifdef CONFIG_DEBUG_THERMAL
+	.get_slope = read_slope,
+	.set_slope = update_slope,
+	.get_intercept = read_intercept,
+	.set_intercept = update_intercept,
+#endif
+};
+
+/**
+ * mid_thermal_probe - mfld thermal initialize
+ * @pdev: platform device structure
+ *
+ * mid thermal probe initializes the hardware and registers
+ * all the sensors with the generic thermal framework. Can sleep.
+ */
+static int mid_thermal_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	int i;
+	int *adc_channel_info;
+	struct intel_mid_thermal_platform_data *pdata;
+
+	pdata = pdev->dev.platform_data;
+
+	if (!pdata)
+		return -EINVAL;
+
+	platforminfo = kzalloc(sizeof(struct platform_info), GFP_KERNEL);
+
+	if (!platforminfo)
+		return -ENOMEM;
+
+	platforminfo->num_sensors = pdata->num_sensors;
+	platforminfo->soc_cooling = pdata->soc_cooling;
+	platforminfo->sensors = pdata->sensors;
+
+	platforminfo->tzd = kzalloc(
+	(sizeof(struct thermal_zone_device *) * platforminfo->num_sensors),
+		 GFP_KERNEL);
+
+	if (!platforminfo->tzd)
+		goto platforminfo_alloc_fail;
+
+	platforminfo->cacheinfo.cached_values =
+		kzalloc((sizeof(int) * platforminfo->num_sensors), GFP_KERNEL);
+
+	if (!platforminfo->cacheinfo.cached_values)
+		goto tzd_alloc_fail;
+
+	adc_channel_info = kzalloc((sizeof(int) * platforminfo->num_sensors),
+			GFP_KERNEL);
+
+	if (!adc_channel_info)
+		goto cachedinfo_alloc_fail;
+
+	/* initialize mutex locks */
+	mutex_init(&platforminfo->cacheinfo.lock);
+
+
+	if (platforminfo->soc_cooling)
+		mutex_init(&soc_cdev_info.lock_cool_state);
+
+	for (i = 0; i < platforminfo->num_sensors; i++)
+		adc_channel_info[i] = platforminfo->sensors[i].adc_channel;
+
+	/* Allocate ADC channels for all sensors */
+	platforminfo->therm_adc_handle = gpadc_alloc_channels(
+				platforminfo->num_sensors, adc_channel_info);
+
+	if (!platforminfo->therm_adc_handle) {
+		ret = -ENOMEM;
+		goto adc_channel_alloc_fail;
+	}
+
+	/* Register each sensor with the generic thermal framework*/
+	for (i = 0; i < platforminfo->num_sensors; i++) {
+		platforminfo->tzd[i] = thermal_zone_device_register(
+				platforminfo->sensors[i].name, 0, 0,
+				initialize_sensor(&platforminfo->sensors[i]),
+				&tzd_ops, NULL, 0, 0);
+		if (IS_ERR(platforminfo->tzd[i]))
+			goto reg_fail;
+	}
+
+	platforminfo->pdev = pdev;
+
+	platform_set_drvdata(pdev, platforminfo);
+
+	/* Register SoC as a cooling device */
+	if (platforminfo->soc_cooling) {
+		ret = register_soc_as_cdev();
+		/* Log this, but keep the driver loaded */
+		if (ret) {
+			dev_err(&pdev->dev,
+				"register_soc_as_cdev failed:%d\n", ret);
+		}
+	}
+
+	kfree(adc_channel_info);
+
+	return 0;
+
+reg_fail:
+	ret = PTR_ERR(platforminfo->tzd[i]);
+	while (--i >= 0)
+		thermal_zone_device_unregister(platforminfo->tzd[i]);
+adc_channel_alloc_fail:
+	kfree(adc_channel_info);
+cachedinfo_alloc_fail:
+	kfree(platforminfo->cacheinfo.cached_values);
+tzd_alloc_fail:
+	kfree(platforminfo->tzd);
+platforminfo_alloc_fail:
+	kfree(platforminfo);
+	return ret;
+}
+
+/**
+ * mid_thermal_remove - mfld thermal finalize
+ * @dev: platform device structure
+ *
+ * MLFD thermal remove unregisters all the sensors from the generic
+ * thermal framework. Can sleep.
+ */
+static int mid_thermal_remove(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < platforminfo->num_sensors; i++)
+		thermal_zone_device_unregister(platforminfo->tzd[i]);
+
+	/* Unregister SoC as cooling device */
+	if (platforminfo->soc_cooling)
+		unregister_soc_as_cdev();
+
+	/* Free the allocated ADC channels */
+	if (platforminfo->therm_adc_handle)
+		intel_mid_gpadc_free(platforminfo->therm_adc_handle);
+
+	kfree(platforminfo->cacheinfo.cached_values);
+	kfree(platforminfo->tzd);
+	kfree(platforminfo);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+/*********************************************************************
+ *		Driver initialisation and finalization
+ *********************************************************************/
+
+
+/* Platfrom device functionality */
+
+static const struct dev_pm_ops msic_thermal_pm_ops = {
+	.suspend = mid_thermal_suspend,
+	.resume = mid_thermal_resume,
+};
+
+static const struct platform_device_id mid_therm_table[] = {
+	{ DRIVER_NAME, 1 },
+};
+
+static struct platform_driver mid_therm_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.pm = &msic_thermal_pm_ops,
+	},
+	.probe = mid_thermal_probe,
+	.remove = mid_thermal_remove,
+	.id_table = mid_therm_table,
+};
+
+static int mid_therm_module_init(void)
+{
+	return platform_driver_register(&mid_therm_driver);
+}
+
+static void mid_therm_module_exit(void)
+{
+	platform_driver_unregister(&mid_therm_driver);
+}
+
+
+/* RPMSG related functionality */
+
+static int mid_therm_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed mid_therm rpmsg device\n");
+
+	ret = mid_therm_module_init();
+out:
+	return ret;
+}
+
+static void mid_therm_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	mid_therm_module_exit();
+	dev_info(&rpdev->dev, "Removed mid_therm rpmsg device\n");
+}
+
+static void mid_therm_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+			int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+				data, len, true);
+}
+
+static struct rpmsg_device_id mid_therm_id_table[] = {
+	{ .name = "rpmsg_mid_thermal" },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(rpmsg, mid_therm_id_table);
+
+static struct rpmsg_driver mid_therm_rpmsg_driver = {
+	.drv.name	= DRIVER_NAME,
+	.drv.owner	= THIS_MODULE,
+	.probe		= mid_therm_rpmsg_probe,
+	.callback	= mid_therm_rpmsg_cb,
+	.remove		= mid_therm_rpmsg_remove,
+	.id_table	= mid_therm_id_table,
+};
+
+static int __init mid_therm_rpmsg_init(void)
+{
+	return register_rpmsg_driver(&mid_therm_rpmsg_driver);
+}
+
+static void __exit mid_therm_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&mid_therm_rpmsg_driver);
+}
+
+
+/* Changing _init call to make the thermal driver
+ * load _after_ the GPADC driver
+ * module_init(mid_therm_rpmsg_init);
+ */
+late_initcall(mid_therm_rpmsg_init);
+module_exit(mid_therm_rpmsg_exit);
+
+MODULE_AUTHOR("Durgadoss R <durgadoss.r@intel.com>");
+MODULE_DESCRIPTION("Intel Medfield Platform Thermal Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/thermal/thermal_core.c b/drivers/thermal/thermal_core.c
index 65cb6056fab2..29f533a65a3a 100644
--- a/drivers/thermal/thermal_core.c
+++ b/drivers/thermal/thermal_core.c
@@ -706,6 +706,82 @@ passive_show(struct device *dev, struct device_attribute *attr,
 	return sprintf(buf, "%d\n", tz->forced_passive);
 }
 
+static ssize_t
+slope_store(struct device *dev, struct device_attribute *attr,
+		    const char *buf, size_t count)
+{
+	int ret;
+	long slope;
+	struct thermal_zone_device *tz = to_thermal_zone(dev);
+
+	if (!tz->ops->set_slope)
+		return -EPERM;
+
+	if (kstrtol(buf, 10, &slope))
+		return -EINVAL;
+
+	ret = tz->ops->set_slope(tz, slope);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t
+slope_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret;
+	long slope;
+	struct thermal_zone_device *tz = to_thermal_zone(dev);
+
+	if (!tz->ops->get_slope)
+		return -EINVAL;
+
+	ret = tz->ops->get_slope(tz, &slope);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%ld\n", slope);
+}
+
+static ssize_t
+intercept_store(struct device *dev, struct device_attribute *attr,
+		    const char *buf, size_t count)
+{
+	int ret;
+	long intercept;
+	struct thermal_zone_device *tz = to_thermal_zone(dev);
+
+	if (!tz->ops->set_intercept)
+		return -EPERM;
+
+	if (kstrtol(buf, 10, &intercept))
+		return -EINVAL;
+
+	ret = tz->ops->set_intercept(tz, intercept);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t
+intercept_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret;
+	long intercept;
+	struct thermal_zone_device *tz = to_thermal_zone(dev);
+
+	if (!tz->ops->get_intercept)
+		return -EINVAL;
+
+	ret = tz->ops->get_intercept(tz, &intercept);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%ld\n", intercept);
+}
+
 static ssize_t
 policy_store(struct device *dev, struct device_attribute *attr,
 		    const char *buf, size_t count)
@@ -765,6 +841,9 @@ static DEVICE_ATTR(type, 0444, type_show, NULL);
 static DEVICE_ATTR(temp, 0444, temp_show, NULL);
 static DEVICE_ATTR(mode, 0644, mode_show, mode_store);
 static DEVICE_ATTR(passive, S_IRUGO | S_IWUSR, passive_show, passive_store);
+static DEVICE_ATTR(slope, S_IRUGO | S_IWUSR, slope_show, slope_store);
+static DEVICE_ATTR(intercept,
+		S_IRUGO | S_IWUSR, intercept_show, intercept_store);
 static DEVICE_ATTR(policy, S_IRUGO | S_IWUSR, policy_show, policy_store);
 
 /* sys I/F for cooling device */
diff --git a/include/linux/thermal.h b/include/linux/thermal.h
index cc43bd75d762..509b23b47485 100644
--- a/include/linux/thermal.h
+++ b/include/linux/thermal.h
@@ -125,6 +125,10 @@ struct thermal_zone_device_ops {
 			      unsigned long *);
 	int (*set_trip_hyst) (struct thermal_zone_device *, int,
 			      unsigned long);
+	int (*get_slope) (struct thermal_zone_device *, long *);
+	int (*set_slope) (struct thermal_zone_device *, long);
+	int (*get_intercept) (struct thermal_zone_device *, long *);
+	int (*set_intercept) (struct thermal_zone_device *, long);
 	int (*get_crit_temp) (struct thermal_zone_device *, unsigned long *);
 	int (*set_emul_temp) (struct thermal_zone_device *, unsigned long);
 	int (*get_trend) (struct thermal_zone_device *, int,
-- 
2.37.3

