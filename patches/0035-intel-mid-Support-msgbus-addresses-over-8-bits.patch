From 527838af8adfaf135d0be950b5ffaf8cb572afc5 Mon Sep 17 00:00:00 2001
From: Dale Stimson <dale.b.stimson@intel.com>
Date: Thu, 1 Nov 2012 08:55:07 -0700
Subject: [PATCH 035/429] intel-mid: Support msgbus addresses over 8 bits.

The msgbus access functions in intel_mid.c supported only 8-bit
msgbus addresses.  Add support for 32-bit addresses.

Kernel 3.0 - http://android.intel.com:8080/72488
Kernel 3.4 - http://android.intel.com:8080/91599

Signed-off-by: Dale Stimson <dale.b.stimson@intel.com>
---
 arch/x86/include/asm/intel-mid.h        | 14 ++++---
 arch/x86/platform/intel-mid/intel-mid.c | 49 +++++++++++++++++++++----
 2 files changed, 50 insertions(+), 13 deletions(-)

diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h
index 52f99eb8f059..14303ae334b6 100644
--- a/arch/x86/include/asm/intel-mid.h
+++ b/arch/x86/include/asm/intel-mid.h
@@ -28,18 +28,21 @@ static inline int get_gpio_by_name(const char *name) { return -1; }
 #endif
 
 /*
- * Access to message bus through these 2 registers
+ * Access to message bus through three registers
  * in CUNIT(0:0:0) PCI configuration space.
  * MSGBUS_CTRL_REG(0xD0):
  *   31:24	= message bus opcode
  *   23:16	= message bus port
- *   15:8	= message bus address
+ *   15:8	= message bus address, low 8 bits.
  *   7:4	= message bus byte enables
- * MSGBUS_DTAT_REG(0xD4):
+ * MSGBUS_CTRL_EXT_REG(0xD8):
+ *   31:8	= message bus address, high 24 bits.
+ * MSGBUS_DATA_REG(0xD4):
  *   hold the data for write or read
  */
 #define PCI_ROOT_MSGBUS_CTRL_REG	0xD0
 #define PCI_ROOT_MSGBUS_DATA_REG	0xD4
+#define PCI_ROOT_MSGBUS_CTRL_EXT_REG	0xD8
 #define PCI_ROOT_MSGBUS_READ		0x10
 #define PCI_ROOT_MSGBUS_WRITE		0x11
 #define PCI_ROOT_MSGBUS_DWORD_ENABLE	0xf0
@@ -55,8 +58,9 @@ extern int sfi_mrtc_num;
 extern struct sfi_rtc_table_entry sfi_mrtc_array[];
 extern u32 intel_mid_msgbus_read32_raw(u32 cmd);
 extern void intel_mid_msgbus_write32_raw(u32 cmd, u32 data);
-extern u32 intel_mid_msgbus_read32(u8 port, u8 addr);
-extern void intel_mid_msgbus_write32(u8 port, u8 addr, u32 data);
+extern u32 intel_mid_msgbus_read32(u8 port, u32 addr);
+extern void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data);
+extern void register_rpmsg_service(char *name, int id, u32 addr);
 extern int sdhci_pci_request_regulators(void);
 
 /* OEMB table */
diff --git a/arch/x86/platform/intel-mid/intel-mid.c b/arch/x86/platform/intel-mid/intel-mid.c
index dcadefe622a8..51cbf5875799 100644
--- a/arch/x86/platform/intel-mid/intel-mid.c
+++ b/arch/x86/platform/intel-mid/intel-mid.c
@@ -123,21 +123,54 @@ void intel_mid_msgbus_write32_raw(u32 cmd, u32 data)
 }
 EXPORT_SYMBOL(intel_mid_msgbus_write32_raw);
 
-u32 intel_mid_msgbus_read32(u8 port, u8 addr)
+u32 intel_mid_msgbus_read32(u8 port, u32 addr)
 {
-	u32 cmd = (PCI_ROOT_MSGBUS_READ << 24) | (port << 16) |
-		  (addr << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+	unsigned long irq_flags;
+	u32 data;
+	u32 cmd;
+	u32 cmdext;
+
+	cmd = (PCI_ROOT_MSGBUS_READ << 24) | (port << 16) |
+		((addr & 0xff) << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+	cmdext = addr & 0xffffff00;
+
+	spin_lock_irqsave(&msgbus_lock, irq_flags);
+
+	if (cmdext) {
+		/* This resets to 0 automatically, no need to write 0 */
+		pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_EXT_REG,
+			cmdext);
+	}
+
+	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+	pci_read_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, &data);
+	spin_unlock_irqrestore(&msgbus_lock, irq_flags);
 
-	return intel_mid_msgbus_read32_raw(cmd);
+	return data;
 }
 EXPORT_SYMBOL(intel_mid_msgbus_read32);
 
-void intel_mid_msgbus_write32(u8 port, u8 addr, u32 data)
+void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data)
 {
-	u32 cmd = (PCI_ROOT_MSGBUS_WRITE << 24) | (port << 16) |
-		  (addr << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+	unsigned long irq_flags;
+	u32 cmd;
+	u32 cmdext;
+
+	cmd = (PCI_ROOT_MSGBUS_WRITE << 24) | (port << 16) |
+		((addr & 0xFF) << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+	cmdext = addr & 0xffffff00;
+
+	spin_lock_irqsave(&msgbus_lock, irq_flags);
+	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
+
+	if (cmdext) {
+		/* This resets to 0 automatically, no need to write 0 */
+		pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_EXT_REG,
+			cmdext);
+	}
 
-	intel_mid_msgbus_write32_raw(cmd, data);
+	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+	spin_unlock_irqrestore(&msgbus_lock, irq_flags);
 }
 EXPORT_SYMBOL(intel_mid_msgbus_write32);
 
-- 
2.37.3

