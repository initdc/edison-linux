From dac4a8170a6ba23869bc952124f02622fc4f0307 Mon Sep 17 00:00:00 2001
From: Axel Haslam <axelx.haslam@intel.com>
Date: Tue, 9 Jul 2013 17:30:16 +0200
Subject: [PATCH 027/429] wl12xx: registering wl12xx platform data

Adding arch dependent code to enable wl12xx driver on medfield and
clovertrail for kernel 3.4.

Signed-off-by: Aymen Zayet <aymen.zayet@intel.com>
Signed-off-by: Sathyanarayanan Kuppuswamy <sathyanarayanan.kuppuswamy@intel.com>
Signed-off-by: Axel Haslam <axelx.haslam@intel.com>

Conflicts:

	arch/x86/platform/intel-mid/device_libs/Makefile

Signed-off-by: David Cohen <david.a.cohen@intel.com>
---
 arch/x86/include/asm/intel-mid.h              |   1 +
 arch/x86/platform/intel-mid/board.c           |   7 +
 .../platform/intel-mid/device_libs/Makefile   |   4 +-
 .../intel-mid/device_libs/platform_wl12xx.c   | 182 ++++++++++++++++++
 .../intel-mid/device_libs/platform_wl12xx.h   |  21 ++
 include/linux/wl12xx.h                        |   5 +
 6 files changed, 219 insertions(+), 1 deletion(-)
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_wl12xx.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_wl12xx.h

diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h
index f447c6680ef9..52f99eb8f059 100644
--- a/arch/x86/include/asm/intel-mid.h
+++ b/arch/x86/include/asm/intel-mid.h
@@ -57,6 +57,7 @@ extern u32 intel_mid_msgbus_read32_raw(u32 cmd);
 extern void intel_mid_msgbus_write32_raw(u32 cmd, u32 data);
 extern u32 intel_mid_msgbus_read32(u8 port, u8 addr);
 extern void intel_mid_msgbus_write32(u8 port, u8 addr, u32 data);
+extern int sdhci_pci_request_regulators(void);
 
 /* OEMB table */
 struct sfi_table_oemb {
diff --git a/arch/x86/platform/intel-mid/board.c b/arch/x86/platform/intel-mid/board.c
index 5f47a289df10..b4d897af213b 100644
--- a/arch/x86/platform/intel-mid/board.c
+++ b/arch/x86/platform/intel-mid/board.c
@@ -71,12 +71,19 @@
  */
 #include "device_libs/platform_max3111.h"
 
+/* WIFI devices */
+#include "device_libs/platform_wl12xx.h"
+
 static void __init *no_platform_data(void *info)
 {
 	return NULL;
 }
 
 struct devs_id __initconst device_ids[] = {
+	/* SD devices */
+	{"wl12xx_clk_vmmc", SFI_DEV_TYPE_SD, 0, &wl12xx_platform_data, NULL},
+
+	/* SPI devices */
 	{"bma023", SFI_DEV_TYPE_I2C, 1, &no_platform_data, NULL},
 	{"pmic_gpio", SFI_DEV_TYPE_SPI, 1, &pmic_gpio_platform_data, NULL},
 	{"pmic_gpio", SFI_DEV_TYPE_IPC, 1, &pmic_gpio_platform_data,
diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile
index e4a1a1755b2d..3534e1882f78 100644
--- a/arch/x86/platform/intel-mid/device_libs/Makefile
+++ b/arch/x86/platform/intel-mid/device_libs/Makefile
@@ -21,4 +21,6 @@ obj-$(subst m,y,$(CONFIG_SERIAL_MRST_MAX3110)) += platform_max3111.o
 # MISC Devices
 obj-$(subst m,y,$(CONFIG_KEYBOARD_GPIO)) += platform_gpio_keys.o
 # UART Devices
-obj-$(subst m,y,$(CONFIG_SERIAL_MFD_HSU))				+= platform_hsu.o
\ No newline at end of file
+obj-$(subst m,y,$(CONFIG_SERIAL_MFD_HSU)) += platform_hsu.o
+# SD Devices
+obj-$(subst m,y,$(CONFIG_WILINK_PLATFORM_DATA)) += platform_wl12xx.o
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_wl12xx.c b/arch/x86/platform/intel-mid/device_libs/platform_wl12xx.c
new file mode 100644
index 000000000000..53b8544fe131
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_wl12xx.c
@@ -0,0 +1,182 @@
+/*
+ * platform_wl12xx.c: wl12xx platform data initilization file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/gpio.h>
+#include <linux/lnw_gpio.h>
+#include <linux/wl12xx.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/fixed.h>
+#include <asm/intel-mid.h>
+#include "platform_wl12xx.h"
+
+static int wl12xx_platform_init(struct wl12xx_platform_data *platform_data);
+static void wl12xx_platform_deinit(struct wl12xx_platform_data *platform_data);
+
+static struct wl12xx_platform_data mid_wifi_control = {
+	.board_ref_clock = 1,
+	.irq = 2,
+	.gpio = -EINVAL,
+	.board_tcxo_clock = 1,
+	.platform_quirks = WL12XX_PLATFORM_QUIRK_EDGE_IRQ,
+	.hw_init = wl12xx_platform_init,
+	.hw_deinit = wl12xx_platform_deinit,
+};
+
+static struct regulator_consumer_supply wl12xx_vmmc3_supply = {
+	.supply		= "vmmc",
+	.dev_name	= "0000:00:00.0", /*default value*/
+};
+
+static struct regulator_init_data wl12xx_vmmc3 = {
+	.constraints = {
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies = &wl12xx_vmmc3_supply,
+};
+
+static struct fixed_voltage_config wl12xx_vwlan = {
+	.supply_name		= "vwl1271",
+	.microvolts		= 1800000,
+	.gpio			= 75,
+	.startup_delay		= 70000,
+	.enable_high		= 1,
+	.enabled_at_boot	= 0,
+	.init_data		= &wl12xx_vmmc3,
+};
+
+static struct platform_device wl12xx_vwlan_device = {
+	.name		= "reg-fixed-voltage",
+	.id		= 1,
+	.dev = {
+		.platform_data	= &wl12xx_vwlan,
+	},
+};
+
+void __init wl12xx_platform_data_init(void *info)
+{
+	struct sd_board_info *sd_info = info;
+	int err;
+
+	/*Get GPIO numbers from the SFI table*/
+	mid_wifi_control.gpio = get_gpio_by_name(WL12XX_SFI_GPIO_IRQ_NAME);
+	if (mid_wifi_control.gpio == -1) {
+		pr_err("%s: Unable to find WLAN-interrupt GPIO in the SFI table\n",
+				__func__);
+		return;
+	}
+
+	/* Set our board_ref_clock from SFI SD board info */
+	if (sd_info->board_ref_clock == ICDK_BOARD_REF_CLK)
+		/*iCDK board*/
+		/*26Mhz TCXO clock ref*/
+		mid_wifi_control.board_ref_clock = 1;
+	else if (sd_info->board_ref_clock == NCDK_BOARD_REF_CLK)
+		/*nCDK board*/
+		/*38,4Mhz TCXO clock ref*/
+		mid_wifi_control.board_ref_clock = 2;
+	err = wl12xx_set_platform_data(&mid_wifi_control);
+	if (err < 0)
+		pr_err("error setting wl12xx data\n");
+
+	/* this is the fake regulator that mmc stack use to power of the
+	   wifi sdio card via runtime_pm apis */
+	wl12xx_vwlan.gpio = get_gpio_by_name(WL12XX_SFI_GPIO_ENABLE_NAME);
+	if (wl12xx_vwlan.gpio == -1) {
+		pr_err("%s: Unable to find WLAN-enable GPIO in the SFI table\n",
+		       __func__);
+		return;
+	}
+	/* format vmmc reg address from sfi table */
+	sprintf((char *)wl12xx_vmmc3_supply.dev_name, "0000:00:%02x.%01x",
+		(sd_info->addr)>>8, sd_info->addr&0xFF);
+
+	err = platform_device_register(&wl12xx_vwlan_device);
+	if (err < 0)
+		pr_err("error platform_device_register\n");
+
+}
+
+void __init *wl12xx_platform_data(void *info)
+{
+	wl12xx_platform_data_init(info);
+
+	return &mid_wifi_control;
+}
+
+static int wl12xx_platform_init(struct wl12xx_platform_data *platform_data)
+{
+	int err = 0;
+
+	if (IS_ERR(platform_data)) {
+		err = PTR_ERR(platform_data);
+		pr_err("%s: missing wlan platform data: %d\n", __func__, err);
+		goto out;
+	}
+
+	/* gpio must be set to -EINVAL by platform code if
+	   gpio based irq is not used*/
+
+	if (gpio_is_valid(platform_data->gpio)) {
+		if (!platform_data->gpio)
+			pr_warn("using GPIO %d for wl12xx\n",
+						platform_data->gpio);
+
+		/* Request gpio */
+		err = gpio_request(platform_data->gpio, "wl12xx");
+		if (err < 0) {
+			pr_err("%s: Unable to request GPIO:%d, err:%d\n",
+					__func__, platform_data->gpio, err);
+			goto out;
+		}
+
+		/* set gpio direction */
+		err = gpio_direction_input(platform_data->gpio);
+		if (err < 0) {
+			pr_err("%s: Unable to set GPIO:%d direction, err:%d\n",
+			 __func__, platform_data->gpio, err);
+			goto out;
+		}
+
+		/* convert gpio to irq */
+		platform_data->irq = gpio_to_irq(platform_data->gpio);
+		if (platform_data->irq < 0) {
+			pr_err("%s: Error gpio_to_irq:%d->%d\n", __func__,
+					platform_data->gpio,
+					platform_data->irq);
+			goto out;
+		}
+	}
+
+	sdhci_pci_request_regulators();
+
+	pr_info("%s done\n", __func__);
+out:
+	return err;
+}
+
+static void wl12xx_platform_deinit(struct wl12xx_platform_data *pdata)
+{
+	/* get platform data and free the gpio */
+	if (IS_ERR(pdata)) {
+		pr_err("%s: missing wlan platform data\n", __func__);
+		goto out;
+	}
+
+	if (gpio_is_valid(pdata->gpio)) {
+		if (!pdata->gpio)
+			pr_warn("using GPIO %d for wl12xx\n", pdata->gpio);
+		gpio_free(pdata->gpio);
+	}
+out:
+	return ;
+}
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_wl12xx.h b/arch/x86/platform/intel-mid/device_libs/platform_wl12xx.h
new file mode 100644
index 000000000000..909f697bb35a
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_wl12xx.h
@@ -0,0 +1,21 @@
+/*
+ * platform_wl12xx.h: wl12xx platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_WL12XX_H_
+#define _PLATFORM_WL12XX_H_
+
+#define WL12XX_SFI_GPIO_IRQ_NAME "WLAN-interrupt"
+#define WL12XX_SFI_GPIO_ENABLE_NAME "WLAN-enable"
+#define ICDK_BOARD_REF_CLK 26000000
+#define NCDK_BOARD_REF_CLK 38400000
+
+extern void __init *wl12xx_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/include/linux/wl12xx.h b/include/linux/wl12xx.h
index a54fe82e704b..5020662ff404 100644
--- a/include/linux/wl12xx.h
+++ b/include/linux/wl12xx.h
@@ -50,8 +50,13 @@ enum {
 
 struct wl12xx_platform_data {
 	void (*set_power)(bool enable);
+	int (*hw_init)(struct wl12xx_platform_data *pdata);
+	void (*hw_deinit)(struct wl12xx_platform_data *pdata);
 	/* SDIO only: IRQ number if WLAN_IRQ line is used, 0 for SDIO IRQs */
 	int irq;
+	/* gpio must be set to -EINVAL by platform code if gpio based irq is
+	not used */
+	int gpio;
 	bool use_eeprom;
 	int board_ref_clock;
 	int board_tcxo_clock;
-- 
2.37.3

