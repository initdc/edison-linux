From 8c8288377b1e847c8ef1d48bbe9b8642d22f55fe Mon Sep 17 00:00:00 2001
From: "Li, Ning" <ning.li@intel.com>
Date: Tue, 8 Oct 2013 07:08:28 +0800
Subject: [PATCH 100/429] FLIS: Adds Tangier FLIS suppport

This patch adds Tangier FLIS support.
1. Based on MMIO Flis access,
   API fully compatible with CTP.
2. Unify the flis access in FLIS driver,
   remove the flis in GPIO driver by calling FLIS driver APIs.

Signed-off-by: Li, Ning <ning.li@intel.com>
---
 arch/x86/include/asm/intel_scu_flis.h         | 294 +++++++-
 .../intel-mid/device_libs/platform_scu_flis.c | 249 ++++++-
 .../intel-mid/device_libs/platform_scu_flis.h |   1 -
 arch/x86/platform/intel-mid/intel_mid_scu.c   |   1 +
 drivers/gpio/gpio-langwell.c                  | 680 +++++++++++++++++-
 drivers/platform/x86/Kconfig                  |   2 +-
 drivers/platform/x86/intel_scu_flis.c         | 283 +++++---
 7 files changed, 1408 insertions(+), 102 deletions(-)

diff --git a/arch/x86/include/asm/intel_scu_flis.h b/arch/x86/include/asm/intel_scu_flis.h
index 9b084951e9d1..75a00ff33c99 100644
--- a/arch/x86/include/asm/intel_scu_flis.h
+++ b/arch/x86/include/asm/intel_scu_flis.h
@@ -7,6 +7,8 @@ enum flis_param_t {
 	OPEN_DRAIN,
 };
 
+#ifndef CONFIG_X86_MRFLD
+/* For CTP */
 /*
  * Config value for PULL
  */
@@ -41,7 +43,40 @@ enum flis_param_t {
 #define MUX_MASK		0xF
 #define OPEN_DRAIN_MASK		0x1
 
-enum pinname_t {
+#else
+/* For MERR */
+
+#define PULL_MASK	((7 << 4) | (3 << 8))
+#define MUX_MASK	(0xF << 12)
+#define OPEN_DRAIN_MASK	BIT(21)
+
+#define PULL_UP		(1 << 8)
+#define PULL_DOWN	(2 << 8)
+#define R2Kohms		(0 << 4)
+#define R20Kohms	(1 << 4)
+#define R50Kohms	(2 << 4)
+#define R910ohms	(3 << 4)
+
+#define UP_2K		(PULL_UP | R2Kohms)
+#define UP_20K		(PULL_UP | R20Kohms)
+#define UP_50K		(PULL_UP | R50Kohms)
+#define UP_910		(PULL_UP | R910ohms)
+#define DOWN_2K		(PULL_DOWN | R2Kohms)
+#define DOWN_20K	(PULL_DOWN | R20Kohms)
+#define DOWN_50K	(PULL_DOWN | R50Kohms)
+#define DOWN_910	(PULL_DOWN | R910ohms)
+
+#define OD_DISABLE	(0 << 21)
+#define OD_ENABLE	(1 << 21)
+
+#define MUX_EN_INPUT_EN		(2 << 12)
+#define INPUT_EN		(1 << 12)
+#define MUX_EN_OUTPUT_EN	(8 << 12)
+#define OUTPUT_EN		(4 << 12)
+
+#endif
+
+enum ctp_pinname_t {
 	i2s_2_clk = 0,
 	i2s_2_fs = 1,
 	i2s_2_rxd = 2,
@@ -259,6 +294,244 @@ enum pinname_t {
 	spi_1_ss2 = 214,
 	spi_1_ss3 = 215,
 	spi_1_ss4 = 216,
+	CTP_PIN_NUM,
+};
+
+/* Add prefix "tng_" to avoid name duplication with ctp pins */
+enum tng_pinname_t {
+	tng_usb_ulpi_0_clk = 0,
+	tng_usb_ulpi_0_data_0 = 1,
+	tng_usb_ulpi_0_data_1 = 2,
+	tng_usb_ulpi_0_data_2 = 3,
+	tng_usb_ulpi_0_data_3 = 4,
+	tng_usb_ulpi_0_data_4 = 5,
+	tng_usb_ulpi_0_data_5 = 6,
+	tng_usb_ulpi_0_data_6 = 7,
+	tng_usb_ulpi_0_data_7 = 8,
+	tng_usb_ulpi_0_dir = 9,
+	tng_usb_ulpi_0_nxt = 10,
+	tng_usb_ulpi_0_refclk = 11,
+	tng_usb_ulpi_0_stp = 12,
+	tng_emmc_0_clk = 13,
+	tng_emmc_0_cmd = 14,
+	tng_emmc_0_d_0 = 15,
+	tng_emmc_0_d_1 = 16,
+	tng_emmc_0_d_2 = 17,
+	tng_emmc_0_d_3 = 18,
+	tng_emmc_0_d_4 = 19,
+	tng_emmc_0_d_5 = 20,
+	tng_emmc_0_d_6 = 21,
+	tng_emmc_0_d_7 = 22,
+	tng_emmc_0_rst_b = 23,
+	tng_gp_emmc_1_clk = 24,
+	tng_gp_emmc_1_cmd = 25,
+	tng_gp_emmc_1_d_0 = 26,
+	tng_gp_emmc_1_d_1 = 27,
+	tng_gp_emmc_1_d_2 = 28,
+	tng_gp_emmc_1_d_3 = 29,
+	tng_gp_emmc_1_d_4 = 30,
+	tng_gp_emmc_1_d_5 = 31,
+	tng_gp_emmc_1_d_6 = 32,
+	tng_gp_emmc_1_d_7 = 33,
+	tng_gp_emmc_1_rst_b = 34,
+	tng_gp_28 = 35,
+	tng_gp_29 = 36,
+	tng_gp_sdio_0_cd_b = 37,
+	tng_gp_sdio_0_clk = 38,
+	tng_gp_sdio_0_cmd = 39,
+	tng_gp_sdio_0_dat_0 = 40,
+	tng_gp_sdio_0_dat_1 = 41,
+	tng_gp_sdio_0_dat_2 = 42,
+	tng_gp_sdio_0_dat_3 = 43,
+	tng_gp_sdio_0_lvl_clk_fb = 44,
+	tng_gp_sdio_0_lvl_cmd_dir = 45,
+	tng_gp_sdio_0_lvl_dat_dir = 46,
+	tng_gp_sdio_0_lvl_sel = 47,
+	tng_gp_sdio_0_powerdown_b = 48,
+	tng_gp_sdio_0_wp = 49,
+	tng_gp_sdio_1_clk = 50,
+	tng_gp_sdio_1_cmd = 51,
+	tng_gp_sdio_1_dat_0 = 52,
+	tng_gp_sdio_1_dat_1 = 53,
+	tng_gp_sdio_1_dat_2 = 54,
+	tng_gp_sdio_1_dat_3 = 55,
+	tng_gp_sdio_1_powerdown_b = 56,
+	tng_mhsi_acdata = 57,
+	tng_mhsi_acflag = 58,
+	tng_mhsi_acready = 59,
+	tng_mhsi_acwake = 60,
+	tng_mhsi_cadata = 61,
+	tng_mhsi_caflag = 62,
+	tng_mhsi_caready = 63,
+	tng_mhsi_cawake = 64,
+	tng_gp_mslim_0_bclk = 65,
+	tng_gp_mslim_0_bdat = 66,
+	tng_gp_ssp_0_clk = 67,
+	tng_gp_ssp_0_fs = 68,
+	tng_gp_ssp_0_rxd = 69,
+	tng_gp_ssp_0_txd = 70,
+	tng_gp_ssp_1_clk = 71,
+	tng_gp_ssp_1_fs = 72,
+	tng_gp_ssp_1_rxd = 73,
+	tng_gp_ssp_1_txd = 74,
+	tng_gp_ssp_2_clk = 75,
+	tng_gp_ssp_2_fs = 76,
+	tng_gp_ssp_2_rxd = 77,
+	tng_gp_ssp_2_txd = 78,
+	tng_gp_ssp_3_clk = 79,
+	tng_gp_ssp_3_fs = 80,
+	tng_gp_ssp_3_rxd = 81,
+	tng_gp_ssp_3_txd = 82,
+	tng_gp_ssp_4_clk = 83,
+	tng_gp_ssp_4_fs_0 = 84,
+	tng_gp_ssp_4_fs_1 = 85,
+	tng_gp_ssp_4_fs_2 = 86,
+	tng_gp_ssp_4_fs_3 = 87,
+	tng_gp_ssp_4_rxd = 88,
+	tng_gp_ssp_4_txd = 89,
+	tng_gp_ssp_5_clk = 90,
+	tng_gp_ssp_5_fs_0 = 91,
+	tng_gp_ssp_5_fs_1 = 92,
+	tng_gp_ssp_5_fs_2 = 93,
+	tng_gp_ssp_5_fs_3 = 94,
+	tng_gp_ssp_5_rxd = 95,
+	tng_gp_ssp_5_txd = 96,
+	tng_gp_ssp_6_clk = 97,
+	tng_gp_ssp_6_fs = 98,
+	tng_gp_ssp_6_rxd = 99,
+	tng_gp_ssp_6_txd = 100,
+	tng_gp_i2c_1_scl = 101,
+	tng_gp_i2c_1_sda = 102,
+	tng_gp_i2c_2_scl = 103,
+	tng_gp_i2c_2_sda = 104,
+	tng_gp_i2c_3_scl = 105,
+	tng_gp_i2c_3_sda = 106,
+	tng_gp_i2c_4_scl = 107,
+	tng_gp_i2c_4_sda = 108,
+	tng_gp_i2c_5_scl = 109,
+	tng_gp_i2c_5_sda = 110,
+	tng_gp_i2c_6_scl = 111,
+	tng_gp_i2c_6_sda = 112,
+	tng_gp_i2c_7_scl = 113,
+	tng_gp_i2c_7_sda = 114,
+	tng_gp_uart_0_cts = 115,
+	tng_gp_uart_0_rts = 116,
+	tng_gp_uart_0_rx = 117,
+	tng_gp_uart_0_tx = 118,
+	tng_gp_uart_1_cts = 119,
+	tng_gp_uart_1_rts = 120,
+	tng_gp_uart_1_rx = 121,
+	tng_gp_uart_1_tx = 122,
+	tng_gp_uart_2_cts = 123,
+	tng_gp_uart_2_rts = 124,
+	tng_gp_uart_2_rx = 125,
+	tng_gp_uart_2_tx = 126,
+	tng_gp_13 = 127,
+	tng_gp_14 = 128,
+	tng_gp_15 = 129,
+	tng_gp_16 = 130,
+	tng_gp_17 = 131,
+	tng_gp_18 = 132,
+	tng_gp_19 = 133,
+	tng_gp_20 = 134,
+	tng_gp_21 = 135,
+	tng_gp_22 = 136,
+	tng_gp_23 = 137,
+	tng_gp_24 = 138,
+	tng_gp_25 = 139,
+	tng_gp_fast_int_0 = 140,
+	tng_gp_fast_int_1 = 141,
+	tng_gp_fast_int_2 = 142,
+	tng_gp_fast_int_3 = 143,
+	tng_gp_pwm_0 = 144,
+	tng_gp_pwm_1 = 145,
+	tng_gp_camerasb_0 = 146,
+	tng_gp_camerasb_1 = 147,
+	tng_gp_camerasb_2 = 148,
+	tng_gp_camerasb_3 = 149,
+	tng_gp_camerasb_4 = 150,
+	tng_gp_camerasb_5 = 151,
+	tng_gp_camerasb_6 = 152,
+	tng_gp_camerasb_7 = 153,
+	tng_gp_camerasb_8 = 154,
+	tng_gp_camerasb_9 = 155,
+	tng_gp_camerasb_10 = 156,
+	tng_gp_camerasb_11 = 157,
+	tng_gp_clkph_0 = 158,
+	tng_gp_clkph_1 = 159,
+	tng_gp_clkph_2 = 160,
+	tng_gp_clkph_3 = 161,
+	tng_gp_clkph_4 = 162,
+	tng_gp_clkph_5 = 163,
+	tng_gp_hdmi_hpd = 164,
+	tng_gp_intd_dsi_te1 = 165,
+	tng_gp_intd_dsi_te2 = 166,
+	tng_osc_clk_ctrl_0 = 167,
+	tng_osc_clk_ctrl_1 = 168,
+	tng_osc_clk_out_0 = 169,
+	tng_osc_clk_out_1 = 170,
+	tng_osc_clk_out_2 = 171,
+	tng_osc_clk_out_3 = 172,
+	tng_osc_clk_out_4 = 173,
+	tng_resetout_b = 174,
+	tng_xxpmode = 175,
+	tng_xxprdy = 176,
+	tng_xxpreq_b = 177,
+	tng_gp_26 = 178,
+	tng_gp_27 = 179,
+	tng_i2c_0_scl = 180,
+	tng_i2c_0_sda = 181,
+	tng_ierr_b = 182,
+	tng_jtag_tckc = 183,
+	tng_jtag_tdic = 184,
+	tng_jtag_tdoc = 185,
+	tng_jtag_tmsc = 186,
+	tng_jtag_trst_b = 187,
+	tng_prochot_b = 188,
+	tng_rtc_clk = 189,
+	tng_svid_vclk = 190,
+	tng_svid_vdio = 191,
+	tng_thermtrip_b = 192,
+	tng_standby = 193,
+	tng_gp_kbd_dkin_0 = 194,
+	tng_gp_kbd_dkin_1 = 195,
+	tng_gp_kbd_dkin_2 = 196,
+	tng_gp_kbd_dkin_3 = 197,
+	tng_gp_kbd_mkin_0 = 198,
+	tng_gp_kbd_mkin_1 = 199,
+	tng_gp_kbd_mkin_2 = 200,
+	tng_gp_kbd_mkin_3 = 201,
+	tng_gp_kbd_mkin_4 = 202,
+	tng_gp_kbd_mkin_5 = 203,
+	tng_gp_kbd_mkin_6 = 204,
+	tng_gp_kbd_mkin_7 = 205,
+	tng_gp_kbd_mkout_0 = 206,
+	tng_gp_kbd_mkout_1 = 207,
+	tng_gp_kbd_mkout_2 = 208,
+	tng_gp_kbd_mkout_3 = 209,
+	tng_gp_kbd_mkout_4 = 210,
+	tng_gp_kbd_mkout_5 = 211,
+	tng_gp_kbd_mkout_6 = 212,
+	tng_gp_kbd_mkout_7 = 213,
+	tng_gp_0 = 214,
+	tng_gp_1 = 215,
+	tng_gp_2 = 216,
+	tng_gp_3 = 217,
+	tng_gp_4 = 218,
+	tng_gp_5 = 219,
+	tng_gp_6 = 220,
+	tng_gp_7 = 221,
+	tng_gp_8 = 222,
+	tng_gp_9 = 223,
+	tng_gp_10 = 224,
+	tng_gp_11 = 225,
+	tng_gp_12 = 226,
+	tng_gp_mpti_clk = 227,
+	tng_gp_mpti_data_0 = 228,
+	tng_gp_mpti_data_1 = 229,
+	tng_gp_mpti_data_2 = 230,
+	tng_gp_mpti_data_3 = 231,
+	TNG_PIN_NUM,
 };
 
 struct pinstruct_t {
@@ -272,9 +545,22 @@ struct pinstruct_t {
 	u8 open_drain_bit;
 };
 
+enum ACCESS_CTRL {
+	readonly = (1 << 0),
+	writable = (1 << 1),
+};
+
+struct pin_mmio_flis_t {
+	u8 access_ctrl; /* mmio flis access control */
+	u32 offset;	/* pin offset from flis base address */
+};
+
 struct intel_scu_flis_platform_data {
 	struct pinstruct_t *pin_t;
 	int pin_num;
+	u32 flis_base;
+	u32 flis_len;
+	struct pin_mmio_flis_t *mmio_flis_t;
 };
 
 #define OPS_STR_LEN 10
@@ -292,8 +578,10 @@ enum {
 int intel_scu_ipc_write_shim(u32 data, u32 flis_addr, u32 offset);
 int intel_scu_ipc_read_shim(u32 *data, u32 flis_addr, u32 offset);
 int intel_scu_ipc_update_shim(u32 data, u32 mask, u32 flis_addr, u32 offset);
-int config_pin_flis(enum pinname_t name, enum flis_param_t param, u8 val);
-int get_pin_flis(enum pinname_t name, enum flis_param_t param, u8 *val);
+int config_pin_flis(unsigned int name, enum flis_param_t param, u32 val);
+int get_pin_flis(unsigned int name, enum flis_param_t param, u32 *val);
+u32 get_flis_value(u32 offset);
+void set_flis_value(u32 value, u32 offset);
 
 extern struct pinstruct_t ctp_pin_table[];
 #endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_scu_flis.c b/arch/x86/platform/intel-mid/device_libs/platform_scu_flis.c
index dc3b418eb243..7b640d0c752a 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_scu_flis.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_scu_flis.c
@@ -1,8 +1,8 @@
 /*
  * platform_scu_flis.c: scu_flis platform data initilization file
  *
- * (C) Copyright 2012 Intel Corporation
- * Author:
+ * (C) Copyright 2013 Intel Corporation
+ * Author: Ning Li <ning.li@intel.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -240,6 +240,240 @@ struct pinstruct_t ctp_pin_table[CTP_PIN_NUM] = {
 	[spi_1_ss4]			 = { true,	0x15,	0x32,	18,	0x11,	20,	0x51,    13 }
 };
 
+static struct pin_mmio_flis_t tng_pin_mmio_flis_table[TNG_PIN_NUM] = {
+	[tng_usb_ulpi_0_clk] = { writable, 0x0500 },
+	[tng_usb_ulpi_0_data_0] = { writable, 0x0504 },
+	[tng_usb_ulpi_0_data_1] = { writable, 0x0508 },
+	[tng_usb_ulpi_0_data_2] = { writable, 0x050C },
+	[tng_usb_ulpi_0_data_3] = { writable, 0x0510 },
+	[tng_usb_ulpi_0_data_4] = { writable, 0x0514 },
+	[tng_usb_ulpi_0_data_5] = { writable, 0x0518 },
+	[tng_usb_ulpi_0_data_6] = { writable, 0x051C },
+	[tng_usb_ulpi_0_data_7] = { writable, 0x0520 },
+	[tng_usb_ulpi_0_dir] = { writable, 0x0524 },
+	[tng_usb_ulpi_0_nxt] = { writable, 0x0528 },
+	[tng_usb_ulpi_0_refclk] = { writable, 0x052C },
+	[tng_usb_ulpi_0_stp] = { writable, 0x0530 },
+	[tng_emmc_0_clk] = { writable, 0x0900 },
+	[tng_emmc_0_cmd] = { writable, 0x0904 },
+	[tng_emmc_0_d_0] = { writable, 0x0908 },
+	[tng_emmc_0_d_1] = { writable, 0x090C },
+	[tng_emmc_0_d_2] = { writable, 0x0910 },
+	[tng_emmc_0_d_3] = { writable, 0x0914 },
+	[tng_emmc_0_d_4] = { writable, 0x0918 },
+	[tng_emmc_0_d_5] = { writable, 0x091C },
+	[tng_emmc_0_d_6] = { writable, 0x0920 },
+	[tng_emmc_0_d_7] = { writable, 0x0924 },
+	[tng_emmc_0_rst_b] = { writable, 0x0928 },
+	[tng_gp_emmc_1_clk] = { writable, 0x092C },
+	[tng_gp_emmc_1_cmd] = { writable, 0x0930 },
+	[tng_gp_emmc_1_d_0] = { writable, 0x0934 },
+	[tng_gp_emmc_1_d_1] = { writable, 0x0938 },
+	[tng_gp_emmc_1_d_2] = { writable, 0x093C },
+	[tng_gp_emmc_1_d_3] = { writable, 0x0940 },
+	[tng_gp_emmc_1_d_4] = { writable, 0x0944 },
+	[tng_gp_emmc_1_d_5] = { writable, 0x0948 },
+	[tng_gp_emmc_1_d_6] = { writable, 0x094C },
+	[tng_gp_emmc_1_d_7] = { writable, 0x0950 },
+	[tng_gp_emmc_1_rst_b] = { writable, 0x0954 },
+	[tng_gp_28] = { writable, 0x0958 },
+	[tng_gp_29] = { writable, 0x095C },
+	[tng_gp_sdio_0_cd_b] = { writable, 0x0D00 },
+	[tng_gp_sdio_0_clk] = { writable, 0x0D04 },
+	[tng_gp_sdio_0_cmd] = { writable, 0x0D08 },
+	[tng_gp_sdio_0_dat_0] = { writable, 0x0D0C },
+	[tng_gp_sdio_0_dat_1] = { writable, 0x0D10 },
+	[tng_gp_sdio_0_dat_2] = { writable, 0x0D14 },
+	[tng_gp_sdio_0_dat_3] = { writable, 0x0D18 },
+	[tng_gp_sdio_0_lvl_clk_fb] = { writable, 0x0D1C },
+	[tng_gp_sdio_0_lvl_cmd_dir] = { writable, 0x0D20 },
+	[tng_gp_sdio_0_lvl_dat_dir] = { writable, 0x0D24 },
+	[tng_gp_sdio_0_lvl_sel] = { writable, 0x0D28 },
+	[tng_gp_sdio_0_powerdown_b] = { writable, 0x0D2C },
+	[tng_gp_sdio_0_wp] = { writable, 0x0D30 },
+	[tng_gp_sdio_1_clk] = { writable, 0x0D34 },
+	[tng_gp_sdio_1_cmd] = { writable, 0x0D38 },
+	[tng_gp_sdio_1_dat_0] = { writable, 0x0D3C },
+	[tng_gp_sdio_1_dat_1] = { writable, 0x0D40 },
+	[tng_gp_sdio_1_dat_2] = { writable, 0x0D44 },
+	[tng_gp_sdio_1_dat_3] = { writable, 0x0D48 },
+	[tng_gp_sdio_1_powerdown_b] = { writable, 0x0D4C },
+	[tng_mhsi_acdata] = { writable, 0x1100 },
+	[tng_mhsi_acflag] = { writable, 0x1104 },
+	[tng_mhsi_acready] = { writable, 0x1108 },
+	[tng_mhsi_acwake] = { writable, 0x110C },
+	[tng_mhsi_cadata] = { writable, 0x1110 },
+	[tng_mhsi_caflag] = { writable, 0x1114 },
+	[tng_mhsi_caready] = { writable, 0x1118 },
+	[tng_mhsi_cawake] = { writable, 0x111C },
+	[tng_gp_mslim_0_bclk] = { writable, 0x1500 },
+	[tng_gp_mslim_0_bdat] = { writable, 0x1504 },
+	[tng_gp_ssp_0_clk] = { writable, 0x1508 },
+	[tng_gp_ssp_0_fs] = { writable, 0x150C },
+	[tng_gp_ssp_0_rxd] = { writable, 0x1510 },
+	[tng_gp_ssp_0_txd] = { writable, 0x1514 },
+	[tng_gp_ssp_1_clk] = { writable, 0x1518 },
+	[tng_gp_ssp_1_fs] = { writable, 0x151C },
+	[tng_gp_ssp_1_rxd] = { writable, 0x1520 },
+	[tng_gp_ssp_1_txd] = { writable, 0x1524 },
+	[tng_gp_ssp_2_clk] = { writable, 0x1528 },
+	[tng_gp_ssp_2_fs] = { writable, 0x152C },
+	[tng_gp_ssp_2_rxd] = { writable, 0x1530 },
+	[tng_gp_ssp_2_txd] = { writable, 0x1534 },
+	[tng_gp_ssp_3_clk] = { writable, 0x1900 },
+	[tng_gp_ssp_3_fs] = { writable, 0x1904 },
+	[tng_gp_ssp_3_rxd] = { writable, 0x1908 },
+	[tng_gp_ssp_3_txd] = { writable, 0x190C },
+	[tng_gp_ssp_4_clk] = { writable, 0x1910 },
+	[tng_gp_ssp_4_fs_0] = { writable, 0x1914 },
+	[tng_gp_ssp_4_fs_1] = { writable, 0x1918 },
+	[tng_gp_ssp_4_fs_2] = { writable, 0x191C },
+	[tng_gp_ssp_4_fs_3] = { writable, 0x1920 },
+	[tng_gp_ssp_4_rxd] = { writable, 0x1924 },
+	[tng_gp_ssp_4_txd] = { writable, 0x1928 },
+	[tng_gp_ssp_5_clk] = { writable, 0x192C },
+	[tng_gp_ssp_5_fs_0] = { writable, 0x1930 },
+	[tng_gp_ssp_5_fs_1] = { writable, 0x1934 },
+	[tng_gp_ssp_5_fs_2] = { writable, 0x1938 },
+	[tng_gp_ssp_5_fs_3] = { writable, 0x193C },
+	[tng_gp_ssp_5_rxd] = { writable, 0x1940 },
+	[tng_gp_ssp_5_txd] = { writable, 0x1944 },
+	[tng_gp_ssp_6_clk] = { writable, 0x1948 },
+	[tng_gp_ssp_6_fs] = { writable, 0x194C },
+	[tng_gp_ssp_6_rxd] = { writable, 0x1950 },
+	[tng_gp_ssp_6_txd] = { writable, 0x1954 },
+	[tng_gp_i2c_1_scl] = { writable, 0x1D00 },
+	[tng_gp_i2c_1_sda] = { writable, 0x1D04 },
+	[tng_gp_i2c_2_scl] = { writable, 0x1D08 },
+	[tng_gp_i2c_2_sda] = { writable, 0x1D0C },
+	[tng_gp_i2c_3_scl] = { writable, 0x1D10 },
+	[tng_gp_i2c_3_sda] = { writable, 0x1D14 },
+	[tng_gp_i2c_4_scl] = { writable, 0x1D18 },
+	[tng_gp_i2c_4_sda] = { writable, 0x1D1C },
+	[tng_gp_i2c_5_scl] = { writable, 0x1D20 },
+	[tng_gp_i2c_5_sda] = { writable, 0x1D24 },
+	[tng_gp_i2c_6_scl] = { writable, 0x1D28 },
+	[tng_gp_i2c_6_sda] = { writable, 0x1D2C },
+	[tng_gp_i2c_7_scl] = { writable, 0x1D30 },
+	[tng_gp_i2c_7_sda] = { writable, 0x1D34 },
+	[tng_gp_uart_0_cts] = { writable, 0x2100 },
+	[tng_gp_uart_0_rts] = { writable, 0x2104 },
+	[tng_gp_uart_0_rx] = { writable, 0x2108 },
+	[tng_gp_uart_0_tx] = { writable, 0x210C },
+	[tng_gp_uart_1_cts] = { writable, 0x2110 },
+	[tng_gp_uart_1_rts] = { writable, 0x2114 },
+	[tng_gp_uart_1_rx] = { writable, 0x2118 },
+	[tng_gp_uart_1_tx] = { writable, 0x211C },
+	[tng_gp_uart_2_cts] = { writable, 0x2120 },
+	[tng_gp_uart_2_rts] = { writable, 0x2124 },
+	[tng_gp_uart_2_rx] = { writable, 0x2128 },
+	[tng_gp_uart_2_tx] = { writable, 0x212C },
+	[tng_gp_13] = { writable, 0x2500 },
+	[tng_gp_14] = { writable, 0x2504 },
+	[tng_gp_15] = { writable, 0x2508 },
+	[tng_gp_16] = { writable, 0x250C },
+	[tng_gp_17] = { writable, 0x2510 },
+	[tng_gp_18] = { writable, 0x2514 },
+	[tng_gp_19] = { writable, 0x2518 },
+	[tng_gp_20] = { writable, 0x251C },
+	[tng_gp_21] = { writable, 0x2520 },
+	[tng_gp_22] = { writable, 0x2524 },
+	[tng_gp_23] = { writable, 0x2528 },
+	[tng_gp_24] = { writable, 0x252C },
+	[tng_gp_25] = { writable, 0x2530 },
+	[tng_gp_fast_int_0] = { writable, 0x2534 },
+	[tng_gp_fast_int_1] = { writable, 0x2538 },
+	[tng_gp_fast_int_2] = { writable, 0x253C },
+	[tng_gp_fast_int_3] = { writable, 0x2540 },
+	[tng_gp_pwm_0] = { writable, 0x2544 },
+	[tng_gp_pwm_1] = { writable, 0x2548 },
+	[tng_gp_camerasb_0] = { writable, 0x2900 },
+	[tng_gp_camerasb_1] = { writable, 0x2904 },
+	[tng_gp_camerasb_2] = { writable, 0x2908 },
+	[tng_gp_camerasb_3] = { writable, 0x290C },
+	[tng_gp_camerasb_4] = { writable, 0x2910 },
+	[tng_gp_camerasb_5] = { writable, 0x2914 },
+	[tng_gp_camerasb_6] = { writable, 0x2918 },
+	[tng_gp_camerasb_7] = { writable, 0x291C },
+	[tng_gp_camerasb_8] = { writable, 0x2920 },
+	[tng_gp_camerasb_9] = { writable, 0x2924 },
+	[tng_gp_camerasb_10] = { writable, 0x2928 },
+	[tng_gp_camerasb_11] = { writable, 0x292C },
+	[tng_gp_clkph_0] = { writable, 0x2D00 },
+	[tng_gp_clkph_1] = { writable, 0x2D04 },
+	[tng_gp_clkph_2] = { writable, 0x2D08 },
+	[tng_gp_clkph_3] = { writable, 0x2D0C },
+	[tng_gp_clkph_4] = { writable, 0x2D10 },
+	[tng_gp_clkph_5] = { writable, 0x2D14 },
+	[tng_gp_hdmi_hpd] = { writable, 0x2D18 },
+	[tng_gp_intd_dsi_te1] = { writable, 0x2D1C },
+	[tng_gp_intd_dsi_te2] = { writable, 0x2D20 },
+	[tng_osc_clk_ctrl_0] = { writable, 0x2D24 },
+	[tng_osc_clk_ctrl_1] = { writable, 0x2D28 },
+	[tng_osc_clk_out_0] = { writable, 0x2D2C },
+	[tng_osc_clk_out_1] = { writable, 0x2D30 },
+	[tng_osc_clk_out_2] = { writable, 0x2D34 },
+	[tng_osc_clk_out_3] = { writable, 0x2D38 },
+	[tng_osc_clk_out_4] = { writable, 0x2D3C },
+	[tng_resetout_b] = { writable, 0x2D40 },
+	[tng_xxpmode] = { writable, 0x2D44 },
+	[tng_xxprdy] = { writable, 0x2D48 },
+	[tng_xxpreq_b] = { writable, 0x2D4C },
+	[tng_gp_26] = { writable, 0x2D50 },
+	[tng_gp_27] = { writable, 0x2D54 },
+	[tng_i2c_0_scl] = { writable, 0x3100 },
+	[tng_i2c_0_sda] = { writable, 0x3104 },
+	[tng_ierr_b] = { writable, 0x3108 },
+	[tng_jtag_tckc] = { writable, 0x310C },
+	[tng_jtag_tdic] = { writable, 0x3110 },
+	[tng_jtag_tdoc] = { writable, 0x3114 },
+	[tng_jtag_tmsc] = { writable, 0x3118 },
+	[tng_jtag_trst_b] = { writable, 0x311C },
+	[tng_prochot_b] = { writable, 0x3120 },
+	[tng_rtc_clk] = { writable, 0x3124 },
+	[tng_svid_vclk] = { writable, 0x3128 },
+	[tng_svid_vdio] = { writable, 0x3130 },
+	[tng_thermtrip_b] = { writable, 0x3134 },
+	[tng_standby] = { writable, 0x3138 },
+	[tng_gp_kbd_dkin_0] = { writable, 0x3500 },
+	[tng_gp_kbd_dkin_1] = { writable, 0x3504 },
+	[tng_gp_kbd_dkin_2] = { writable, 0x3508 },
+	[tng_gp_kbd_dkin_3] = { writable, 0x350C },
+	[tng_gp_kbd_mkin_0] = { writable, 0x3510 },
+	[tng_gp_kbd_mkin_1] = { writable, 0x3514 },
+	[tng_gp_kbd_mkin_2] = { writable, 0x3518 },
+	[tng_gp_kbd_mkin_3] = { writable, 0x351C },
+	[tng_gp_kbd_mkin_4] = { writable, 0x3520 },
+	[tng_gp_kbd_mkin_5] = { writable, 0x3524 },
+	[tng_gp_kbd_mkin_6] = { writable, 0x3528 },
+	[tng_gp_kbd_mkin_7] = { writable, 0x352C },
+	[tng_gp_kbd_mkout_0] = { writable, 0x3530 },
+	[tng_gp_kbd_mkout_1] = { writable, 0x3534 },
+	[tng_gp_kbd_mkout_2] = { writable, 0x3538 },
+	[tng_gp_kbd_mkout_3] = { writable, 0x353C },
+	[tng_gp_kbd_mkout_4] = { writable, 0x3540 },
+	[tng_gp_kbd_mkout_5] = { writable, 0x3544 },
+	[tng_gp_kbd_mkout_6] = { writable, 0x3548 },
+	[tng_gp_kbd_mkout_7] = { writable, 0x354C },
+	[tng_gp_0] = { writable, 0x3900 },
+	[tng_gp_1] = { writable, 0x3904 },
+	[tng_gp_2] = { writable, 0x3908 },
+	[tng_gp_3] = { writable, 0x390C },
+	[tng_gp_4] = { writable, 0x3910 },
+	[tng_gp_5] = { writable, 0x3914 },
+	[tng_gp_6] = { writable, 0x3918 },
+	[tng_gp_7] = { writable, 0x391C },
+	[tng_gp_8] = { writable, 0x3920 },
+	[tng_gp_9] = { writable, 0x3924 },
+	[tng_gp_10] = { writable, 0x3928 },
+	[tng_gp_11] = { writable, 0x392C },
+	[tng_gp_12] = { writable, 0x3930 },
+	[tng_gp_mpti_clk] = { writable, 0x3D00 },
+	[tng_gp_mpti_data_0] = { writable, 0x3D04 },
+	[tng_gp_mpti_data_1] = { writable, 0x3D08 },
+	[tng_gp_mpti_data_2] = { writable, 0x3D0C },
+	[tng_gp_mpti_data_3] = { writable, 0x3D10 },
+};
 
 static int __init intel_scu_flis_init(void)
 {
@@ -251,8 +485,15 @@ static int __init intel_scu_flis_init(void)
 		INTEL_MID_BOARD(1, TABLET, CLVT)) {
 		flis_pdata.pin_t = ctp_pin_table;
 		flis_pdata.pin_num = CTP_PIN_NUM;
+		flis_pdata.mmio_flis_t = NULL;
+	} else if (INTEL_MID_BOARD(1, PHONE, MRFL)) {
+		flis_pdata.pin_t = NULL;
+		flis_pdata.pin_num = TNG_PIN_NUM;
+		flis_pdata.flis_base = 0xFF0C0000;
+		flis_pdata.flis_len = 0x8000;
+		flis_pdata.mmio_flis_t = tng_pin_mmio_flis_table;
 	} else {
-		/* currently runtime flis config is supported on CLV only */
+		/* Runtime flis config is supported on CLV & TNG only */
 		return -EINVAL;
 	}
 
@@ -272,8 +513,6 @@ static int __init intel_scu_flis_init(void)
 		goto out;
 	}
 
-	register_rpmsg_service("rpmsg_flis", RPROC_SCU, RP_FLIS_ACCESS);
-
 	pr_info("intel_scu_flis platform device created\n");
 out:
 	return ret;
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_scu_flis.h b/arch/x86/platform/intel-mid/device_libs/platform_scu_flis.h
index a0363099a7f2..cf48ae5894a6 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_scu_flis.h
+++ b/arch/x86/platform/intel-mid/device_libs/platform_scu_flis.h
@@ -14,5 +14,4 @@
 
 #define FLIS_DEVICE_NAME "intel_scu_flis"
 
-#define CTP_PIN_NUM	217
 #endif
diff --git a/arch/x86/platform/intel-mid/intel_mid_scu.c b/arch/x86/platform/intel-mid/intel_mid_scu.c
index a99f2946d720..ed40fd381a5f 100644
--- a/arch/x86/platform/intel-mid/intel_mid_scu.c
+++ b/arch/x86/platform/intel-mid/intel_mid_scu.c
@@ -70,6 +70,7 @@ int intel_mid_rproc_init(void)
 					RPROC_SCU, RP_FW_ACCESS);
 	register_rpmsg_service("rpmsg_ipc_util",
 					RPROC_SCU, RP_IPC_UTIL);
+	register_rpmsg_service("rpmsg_flis", RPROC_SCU, RP_FLIS_ACCESS);
 	register_rpmsg_service("rpmsg_watchdog", RPROC_SCU, RP_SET_WATCHDOG);
 	register_rpmsg_service("rpmsg_umip", RPROC_SCU, RP_UMIP_ACCESS);
 	register_rpmsg_service("rpmsg_osip", RPROC_SCU, RP_OSIP_ACCESS);
diff --git a/drivers/gpio/gpio-langwell.c b/drivers/gpio/gpio-langwell.c
index 62ef10a641c4..92851da7457d 100644
--- a/drivers/gpio/gpio-langwell.c
+++ b/drivers/gpio/gpio-langwell.c
@@ -37,6 +37,11 @@
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
 #include <linux/irqdomain.h>
+#include <asm/intel_scu_flis.h>
+#include "gpiodebug.h"
+
+#define IRQ_TYPE_EDGE	(1 << 0)
+#define IRQ_TYPE_LEVEL	(1 << 1)
 
 /*
  * Langwell chip has 64 pins and thus there are 2 32bit registers to control
@@ -61,14 +66,137 @@ enum GPIO_REG {
 	GFER,		/* falling edge detect */
 	GEDR,		/* edge detect result */
 	GAFR,		/* alt function */
+	GFBR = 9,	/* glitch filter bypas */
+	GPIT,		/* interrupt type */
+	GPIP = GFER,	/* level interrupt polarity */
+	GPIM = GRER,	/* level interrupt mask */
+
+	/* the following registers only exist on MRFLD */
+	GFBR_TNG = 6,
+	GIMR,		/* interrupt mask */
+	GISR,		/* interrupt source */
+	GITR = 32,	/* interrupt type */
+	GLPR = 33,	/* level-input polarity */
+};
+
+enum GPIO_CONTROLLERS {
+	LINCROFT_GPIO,
+	PENWELL_GPIO_AON,
+	PENWELL_GPIO_CORE,
+	CLOVERVIEW_GPIO_AON,
+	CLOVERVIEW_GPIO_CORE,
+	TANGIER_GPIO,
+};
+
+/* langwell gpio driver data */
+struct lnw_gpio_ddata_t {
+	u16 ngpio;		/* number of gpio pins */
+	u32 gplr_offset;	/* offset of first GPLR register from base */
+	u32 (*get_flis_offset)(int gpio);
+	u32 chip_irq_type;	/* chip interrupt type */
+};
+
+struct gpio_flis_pair {
+	int gpio;	/* gpio number */
+	int offset;	/* register offset from FLIS base */
+};
+
+/*
+ * The following mapping table lists the pin and flis offset pair
+ * of some key gpio pins, the offset of other gpios can be calculated
+ * from the table.
+ */
+static struct gpio_flis_pair gpio_flis_mapping_table[] = {
+	{ 0,	0x2900 },
+	{ 12,	0x2544 },
+	{ 14,	0x0958 },
+	{ 16,	0x2D18 },
+	{ 17,	0x1D10 },
+	{ 19,	0x1D00 },
+	{ 23,	0x1D18 },
+	{ 31,	-EINVAL }, /* No GPIO 31 in pin list */
+	{ 32,	0x1508 },
+	{ 44,	0x3500 },
+	{ 64,	0x2534 },
+	{ 68,	0x2D1C },
+	{ 70,	0x1500 },
+	{ 72,	0x3D00 },
+	{ 77,	0x0D00 },
+	{ 97,	0x0954 },
+	{ 98,	-EINVAL }, /* No GPIO 98-101 in pin list */
+	{ 102,	0x1910 },
+	{ 120,	0x1900 },
+	{ 124,	0x2100 },
+	{ 136,	-EINVAL }, /* No GPIO 136 in pin list */
+	{ 137,	0x2D00 },
+	{ 143,	-EINVAL }, /* No GPIO 143-153 in pin list */
+	{ 154,	0x092C },
+	{ 164,	0x3900 },
+	{ 177,	0x2500 },
+	{ 190,	0x2D50 },
+};
+
+static u32 get_flis_offset_by_gpio(int gpio)
+{
+	int i;
+	int start;
+	u32 offset = -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(gpio_flis_mapping_table) - 1; i++) {
+		if (gpio >= gpio_flis_mapping_table[i].gpio
+			&& gpio < gpio_flis_mapping_table[i + 1].gpio)
+			break;
+	}
+
+	start = gpio_flis_mapping_table[i].gpio;
+
+	if (gpio_flis_mapping_table[i].offset != -EINVAL) {
+		offset = gpio_flis_mapping_table[i].offset
+				+ (gpio - start) * 4;
+	}
+
+	return offset;
+}
+
+static struct lnw_gpio_ddata_t lnw_gpio_ddata[] = {
+	[LINCROFT_GPIO] = {
+		.ngpio = 64,
+	},
+	[PENWELL_GPIO_AON] = {
+		.ngpio = 96,
+		.chip_irq_type = IRQ_TYPE_EDGE,
+	},
+	[PENWELL_GPIO_CORE] = {
+		.ngpio = 96,
+		.chip_irq_type = IRQ_TYPE_EDGE,
+	},
+	[CLOVERVIEW_GPIO_AON] = {
+		.ngpio = 96,
+		.chip_irq_type = IRQ_TYPE_EDGE | IRQ_TYPE_LEVEL,
+	},
+	[CLOVERVIEW_GPIO_CORE] = {
+		.ngpio = 96,
+		.chip_irq_type = IRQ_TYPE_EDGE,
+	},
+	[TANGIER_GPIO] = {
+		.ngpio = 192,
+		.gplr_offset = 4,
+		.get_flis_offset = get_flis_offset_by_gpio,
+		.chip_irq_type = IRQ_TYPE_EDGE | IRQ_TYPE_LEVEL,
+	},
 };
 
 struct lnw_gpio {
-	struct gpio_chip		chip;
-	void				*reg_base;
-	spinlock_t			lock;
-	struct pci_dev			*pdev;
-	struct irq_domain		*domain;
+	struct gpio_chip	chip;
+	void			*reg_base;
+	void			*reg_gplr;
+	spinlock_t		lock;
+	struct pci_dev		*pdev;
+	struct irq_domain	*domain;
+	u32			(*get_flis_offset)(int gpio);
+	u32			chip_irq_type;
+	int			type;
+	struct gpio_debug	*debug;
 };
 
 #define to_lnw_priv(chip)	container_of(chip, struct lnw_gpio, chip)
@@ -81,10 +209,156 @@ static void __iomem *gpio_reg(struct gpio_chip *chip, unsigned offset,
 	u8 reg = offset / 32;
 	void __iomem *ptr;
 
-	ptr = (void __iomem *)(lnw->reg_base + reg_type * nreg * 4 + reg * 4);
+	/**
+	 * On TNG B0, GITR[0]'s address is 0xFF008300, while GPLR[0]'s address
+	 * is 0xFF008004. To count GITR[0]'s address, it's easier to count
+	 * from 0xFF008000. So for GITR,GLPR... we switch the base to reg_base.
+	 * This does not affect PNW/CLV, since the reg_gplr is the reg_base,
+	 * while on TNG, the reg_gplr has an offset of 0x4.
+	 */
+	base = reg_type < GITR ? lnw->reg_gplr : lnw->reg_base;
+	ptr = (void __iomem *)(base + reg_type * nreg * 4 + reg * 4);
 	return ptr;
 }
 
+void lnw_gpio_set_alt(int gpio, int alt)
+{
+	struct lnw_gpio *lnw;
+	u32 __iomem *mem;
+	int reg;
+	int bit;
+	u32 offset;
+	u32 value;
+	unsigned long flags;
+
+	/* use this trick to get memio */
+	lnw = irq_get_chip_data(gpio_to_irq(gpio));
+	if (!lnw) {
+		pr_err("langwell_gpio: can not find pin %d\n", gpio);
+		return;
+	}
+	if (gpio < lnw->chip.base || gpio >= lnw->chip.base + lnw->chip.ngpio) {
+		dev_err(lnw->chip.dev, "langwell_gpio: wrong pin %d to config alt\n", gpio);
+		return;
+	}
+#if 0
+	if (lnw->irq_base + gpio - lnw->chip.base != gpio_to_irq(gpio)) {
+		dev_err(lnw->chip.dev, "langwell_gpio: wrong chip data for pin %d\n", gpio);
+		return;
+	}
+#endif
+	gpio -= lnw->chip.base;
+
+	if (lnw->type != TANGIER_GPIO) {
+		reg = gpio / 16;
+		bit = gpio % 16;
+
+		mem = gpio_reg(&lnw->chip, 0, GAFR);
+		spin_lock_irqsave(&lnw->lock, flags);
+		value = readl(mem + reg);
+		value &= ~(3 << (bit * 2));
+		value |= (alt & 3) << (bit * 2);
+		writel(value, mem + reg);
+		spin_unlock_irqrestore(&lnw->lock, flags);
+		dev_dbg(lnw->chip.dev, "ALT: writing 0x%x to %p\n",
+			value, mem + reg);
+	} else {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return;
+
+		spin_lock_irqsave(&lnw->lock, flags);
+		value = get_flis_value(offset);
+		value &= ~7;
+		value |= (alt & 7);
+		set_flis_value(value, offset);
+		spin_unlock_irqrestore(&lnw->lock, flags);
+	}
+}
+EXPORT_SYMBOL_GPL(lnw_gpio_set_alt);
+
+int gpio_get_alt(int gpio)
+{
+	struct lnw_gpio *lnw;
+	u32 __iomem *mem;
+	int reg;
+	int bit;
+	u32 value;
+	u32 offset;
+
+	 /* use this trick to get memio */
+	lnw = irq_get_chip_data(gpio_to_irq(gpio));
+	if (!lnw) {
+		pr_err("langwell_gpio: can not find pin %d\n", gpio);
+		return -1;
+	}
+	if (gpio < lnw->chip.base || gpio >= lnw->chip.base + lnw->chip.ngpio) {
+		dev_err(lnw->chip.dev,
+			"langwell_gpio: wrong pin %d to config alt\n", gpio);
+		return -1;
+	}
+#if 0
+	if (lnw->irq_base + gpio - lnw->chip.base != gpio_to_irq(gpio)) {
+		dev_err(lnw->chip.dev,
+			"langwell_gpio: wrong chip data for pin %d\n", gpio);
+		return -1;
+	}
+#endif
+	gpio -= lnw->chip.base;
+
+	if (lnw->type != TANGIER_GPIO) {
+		reg = gpio / 16;
+		bit = gpio % 16;
+
+		mem = gpio_reg(&lnw->chip, 0, GAFR);
+		value = readl(mem + reg);
+		value &= (3 << (bit * 2));
+		value >>= (bit * 2);
+	} else {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -EINVAL;
+
+		value = get_flis_value(offset) & 7;
+	}
+
+	return value;
+}
+EXPORT_SYMBOL_GPL(gpio_get_alt);
+
+static int lnw_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
+				 unsigned debounce)
+{
+	struct lnw_gpio *lnw = to_lnw_priv(chip);
+	void __iomem *gfbr;
+	unsigned long flags;
+	u32 value;
+	enum GPIO_REG reg_type;
+
+	reg_type = (lnw->type == TANGIER_GPIO) ? GFBR_TNG : GFBR;
+	gfbr = gpio_reg(chip, offset, reg_type);
+
+	if (lnw->pdev)
+		pm_runtime_get(&lnw->pdev->dev);
+
+	spin_lock_irqsave(&lnw->lock, flags);
+	value = readl(gfbr);
+	if (debounce) {
+		/* debounce bypass disable */
+		value &= ~BIT(offset % 32);
+	} else {
+		/* debounce bypass enable */
+		value |= BIT(offset % 32);
+	}
+	writel(value, gfbr);
+	spin_unlock_irqrestore(&lnw->lock, flags);
+
+	if (lnw->pdev)
+		pm_runtime_put(&lnw->pdev->dev);
+
+	return 0;
+}
+
 static void __iomem *gpio_reg_2bit(struct gpio_chip *chip, unsigned offset,
 				   enum GPIO_REG reg_type)
 {
@@ -267,6 +541,400 @@ static void lnw_irq_handler(unsigned irq, struct irq_desc *desc)
 	chip->irq_eoi(data);
 }
 
+static char conf_reg_msg[] =
+	"\nGPIO configuration register:\n"
+	"\t[ 2: 0]\tpinmux\n"
+	"\t[ 6: 4]\tpull strength\n"
+	"\t[ 8: 8]\tpullup enable\n"
+	"\t[ 9: 9]\tpulldown enable\n"
+	"\t[10:10]\tslew A, B setting\n"
+	"\t[12:12]\toverride input enable\n"
+	"\t[13:13]\toverride input enable enable\n"
+	"\t[14:14]\toverride output enable\n"
+	"\t[15:15]\toverride output enable enable\n"
+	"\t[16:16]\toverride input value\n"
+	"\t[17:17]\tenable input data override\n"
+	"\t[18:18]\toverride output value\n"
+	"\t[19:19]\tenable output data override\n"
+	"\t[21:21]\topen drain enable\n"
+	"\t[22:22]\tenable OVR_IOSTBY_VAL\n"
+	"\t[23:23]\tOVR_IOSTBY_VAL\n"
+	"\t[24:24]\tSBY_OUTDATAOV_EN\n"
+	"\t[25:25]\tSBY_INDATAOV_EN\n"
+	"\t[26:26]\tSBY_OVOUTEN_EN\n"
+	"\t[27:27]\tSBY_OVINEN_EN\n"
+	"\t[29:28]\tstandby pullmode\n"
+	"\t[30:30]\tstandby open drain mode\n";
+
+static char *pinvalue[] = {"low", "high"};
+static char *pindirection[] = {"in", "out"};
+static char *irqtype[] = {"irq_none", "edge_rising", "edge_falling",
+			"edge_both"};
+static char *pinmux[] = {"mode0", "mode1", "mode2", "mode3", "mode4", "mode5",
+			"mode6", "mode7"};
+static char *pullmode[] = {"nopull", "pullup", "pulldown"};
+static char *pullstrength[] = {"2k", "20k", "50k", "910ohms"};
+static char *enable[] = {"disable", "enable"};
+static char *override_direction[] = {"no-override", "override-enable",
+			"override-disable"};
+static char *override_value[] = {"no-override", "override-high",
+			"override-low"};
+static char *standby_trigger[] = {"no-override", "override-trigger",
+			"override-notrigger"};
+static char *standby_pupd_state[] = {"keep", "pulldown", "pullup", "nopull"};
+
+static int gpio_get_pinvalue(struct gpio_control *control, void *private_data,
+		unsigned gpio)
+{
+	struct lnw_gpio *lnw = private_data;
+	u32 value;
+
+	value = lnw_gpio_get(&lnw->chip, gpio);
+
+	return value ? 1 : 0;
+}
+
+static int gpio_set_pinvalue(struct gpio_control *control, void *private_data,
+		unsigned gpio, unsigned int num)
+{
+	struct lnw_gpio *lnw = private_data;
+
+	lnw_gpio_set(&lnw->chip, gpio, num);
+
+	return 0;
+}
+
+static int gpio_get_normal(struct gpio_control *control, void *private_data,
+		unsigned gpio)
+{
+	struct lnw_gpio *lnw = private_data;
+	u32 __iomem *mem;
+	u32 value;
+
+	mem = gpio_reg(&lnw->chip, gpio, control->reg);
+
+	value = readl(mem);
+	value &= BIT(gpio % 32);
+
+	if (control->invert)
+		return value ? 0 : 1;
+	else
+		return value ? 1 : 0;
+}
+
+static int gpio_set_normal(struct gpio_control *control, void *private_data,
+		unsigned gpio, unsigned int num)
+{
+	struct lnw_gpio *lnw = private_data;
+	u32 __iomem *mem;
+	u32 value;
+	unsigned long flags;
+
+	mem = gpio_reg(&lnw->chip, gpio, control->reg);
+
+	spin_lock_irqsave(&lnw->lock, flags);
+	value = readl(mem);
+	value &= ~BIT(gpio % 32);
+	if (control->invert) {
+		if (num)
+			value &= ~BIT(gpio % 32);
+		else
+			value |= BIT(gpio % 32);
+	} else {
+		if (num)
+			value |= BIT(gpio % 32);
+		else
+			value &= ~BIT(gpio % 32);
+	}
+	writel(value, mem);
+	spin_unlock_irqrestore(&lnw->lock, flags);
+
+	return 0;
+}
+
+static int gpio_get_irqtype(struct gpio_control *control, void *private_data,
+		unsigned gpio)
+{
+	struct lnw_gpio *lnw = private_data;
+	void __iomem *grer = gpio_reg(&lnw->chip, gpio, GRER);
+	void __iomem *gfer = gpio_reg(&lnw->chip, gpio, GFER);
+	u32 value;
+	int num;
+
+	value = readl(grer) & BIT(gpio % 32);
+	num = value ? 1 : 0;
+	value = readl(gfer) & BIT(gpio % 32);
+	if (num)
+		num = value ? 3 : 1;
+	else
+		num = value ? 2 : 0;
+
+	return num;
+}
+
+static int flis_get_normal(struct gpio_control *control, void *private_data,
+		unsigned gpio)
+{
+	struct lnw_gpio *lnw = private_data;
+	u32 offset, value;
+	int num;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -1;
+
+		value = get_flis_value(offset);
+		num = (value >> control->shift) & control->mask;
+		if (num < control->num)
+			return num;
+	}
+
+	return -1;
+}
+
+static int flis_set_normal(struct gpio_control *control, void *private_data,
+		unsigned gpio, unsigned int num)
+{
+	struct lnw_gpio *lnw = private_data;
+	u32 shift = control->shift;
+	u32 mask = control->mask;
+	u32 offset, value;
+	unsigned long flags;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -1;
+
+		spin_lock_irqsave(&lnw->lock, flags);
+		value = get_flis_value(offset);
+		value &= ~(mask << shift);
+		value |= ((num & mask) << shift);
+		set_flis_value(value, offset);
+		spin_unlock_irqrestore(&lnw->lock, flags);
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int flis_get_override(struct gpio_control *control, void *private_data,
+		unsigned gpio)
+{
+	struct lnw_gpio *lnw = private_data;
+	u32 offset, value;
+	u32 val_bit, en_bit;
+	int num;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -1;
+
+		val_bit = 1 << control->shift;
+		en_bit = 1 << control->rshift;
+
+		value = get_flis_value(offset);
+
+		if (value & en_bit)
+			if (value & val_bit)
+				num = 1;
+			else
+				num = 2;
+		else
+			num = 0;
+
+		return num;
+	}
+
+	return -1;
+}
+
+static int flis_set_override(struct gpio_control *control, void *private_data,
+		unsigned gpio, unsigned int num)
+{
+	struct lnw_gpio *lnw = private_data;
+	u32 offset, value;
+	u32 val_bit, en_bit;
+	unsigned long flags;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -1;
+
+		val_bit = 1 << control->shift;
+		en_bit = 1 << control->rshift;
+
+		spin_lock_irqsave(&lnw->lock, flags);
+		value = get_flis_value(offset);
+		switch (num) {
+		case 0:
+			value &= ~(en_bit | val_bit);
+			break;
+		case 1:
+			value |= (en_bit | val_bit);
+			break;
+		case 2:
+			value |= en_bit;
+			value &= ~val_bit;
+			break;
+		default:
+			break;
+		}
+		set_flis_value(value, offset);
+		spin_unlock_irqrestore(&lnw->lock, flags);
+
+		return 0;
+	}
+
+	return -1;
+}
+
+#define GPIO_VALUE_CONTROL(xtype, xinfo, xnum) \
+{	.type = xtype, .pininfo = xinfo, .num = xnum, \
+	.get = gpio_get_pinvalue, .set = gpio_set_pinvalue}
+#define GPIO_NORMAL_CONTROL(xtype, xinfo, xnum, xreg, xinvert) \
+{	.type = xtype, .pininfo = xinfo, .num = xnum, .reg = xreg, \
+	.invert = xinvert, .get = gpio_get_normal, .set = gpio_set_normal}
+#define GPIO_IRQTYPE_CONTROL(xtype, xinfo, xnum) \
+{	.type = xtype, .pininfo = xinfo, .num = xnum, \
+	.get = gpio_get_irqtype, .set = NULL}
+#define FLIS_NORMAL_CONTROL(xtype, xinfo, xnum, xshift, xmask) \
+{	.type = xtype, .pininfo = xinfo, .num = xnum, .shift = xshift, \
+	.mask = xmask, .get = flis_get_normal, .set = flis_set_normal}
+#define FLIS_OVERRIDE_CONTROL(xtype, xinfo, xnum, xshift, xrshift) \
+{	.type = xtype, .pininfo = xinfo, .num = xnum, .shift = xshift, \
+	.rshift = xrshift, .get = flis_get_override, .set = flis_set_override}
+
+static struct gpio_control lnw_gpio_controls[] = {
+GPIO_VALUE_CONTROL(TYPE_PIN_VALUE, pinvalue, 2),
+GPIO_NORMAL_CONTROL(TYPE_DIRECTION, pindirection, 2, GPDR, 0),
+GPIO_IRQTYPE_CONTROL(TYPE_IRQ_TYPE, irqtype, 4),
+GPIO_NORMAL_CONTROL(TYPE_DEBOUNCE, enable, 2, GFBR_TNG, 1),
+FLIS_NORMAL_CONTROL(TYPE_PINMUX, pinmux, 8, 0, 0x7),
+FLIS_NORMAL_CONTROL(TYPE_PULLSTRENGTH, pullstrength, 4, 4, 0x7),
+FLIS_NORMAL_CONTROL(TYPE_PULLMODE, pullmode, 3, 8, 0x3),
+FLIS_NORMAL_CONTROL(TYPE_OPEN_DRAIN, enable, 2, 21, 0x1),
+FLIS_OVERRIDE_CONTROL(TYPE_OVERRIDE_INDIR, override_direction, 3, 12, 13),
+FLIS_OVERRIDE_CONTROL(TYPE_OVERRIDE_OUTDIR, override_direction, 3, 14, 15),
+FLIS_OVERRIDE_CONTROL(TYPE_OVERRIDE_INVAL, override_value, 3, 16, 17),
+FLIS_OVERRIDE_CONTROL(TYPE_OVERRIDE_OUTVAL, override_value, 3, 18, 19),
+FLIS_OVERRIDE_CONTROL(TYPE_SBY_OVR_IO, standby_trigger, 3, 23, 22),
+FLIS_OVERRIDE_CONTROL(TYPE_SBY_OVR_OUTVAL, override_value, 3, 18, 24),
+FLIS_OVERRIDE_CONTROL(TYPE_SBY_OVR_INVAL, override_value, 3, 16, 25),
+FLIS_OVERRIDE_CONTROL(TYPE_SBY_OVR_OUTDIR, override_direction, 3, 14, 26),
+FLIS_OVERRIDE_CONTROL(TYPE_SBY_OVR_INDIR, override_direction, 3, 12, 27),
+FLIS_NORMAL_CONTROL(TYPE_SBY_PUPD_STATE, standby_pupd_state, 4, 28, 0x3),
+FLIS_NORMAL_CONTROL(TYPE_SBY_OD_DIS, enable, 2, 30, 0x1),
+};
+
+static unsigned int lnw_get_conf_reg(struct gpio_debug *debug, unsigned gpio)
+{
+	struct lnw_gpio *lnw = debug->private_data;
+	u32 offset, value = 0;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -EINVAL;
+
+		value = get_flis_value(offset);
+	}
+
+	return value;
+}
+
+static void lnw_set_conf_reg(struct gpio_debug *debug, unsigned gpio,
+		unsigned int value)
+{
+	struct lnw_gpio *lnw = debug->private_data;
+	u32 offset;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return;
+
+		set_flis_value(value, offset);
+	}
+
+	return;
+}
+
+static char **lnw_get_avl_pininfo(struct gpio_debug *debug, unsigned gpio,
+		unsigned int type, unsigned *num)
+{
+	struct gpio_control *control;
+
+	control = find_gpio_control(lnw_gpio_controls,
+			ARRAY_SIZE(lnw_gpio_controls), type);
+	if (control == NULL)
+		return NULL;
+
+	*num = control->num;
+
+	return control->pininfo;
+}
+
+static char *lnw_get_cul_pininfo(struct gpio_debug *debug, unsigned gpio,
+		unsigned int type)
+{
+	struct lnw_gpio *lnw = debug->private_data;
+	struct gpio_control *control;
+	int num;
+
+	control = find_gpio_control(lnw_gpio_controls,
+			ARRAY_SIZE(lnw_gpio_controls), type);
+	if (control == NULL)
+		return NULL;
+
+	num = control->get(control, lnw, gpio);
+	if (num == -1)
+		return NULL;
+
+	return *(control->pininfo + num);
+}
+
+static void lnw_set_pininfo(struct gpio_debug *debug, unsigned gpio,
+		unsigned int type, const char *info)
+{
+	struct lnw_gpio *lnw = debug->private_data;
+	struct gpio_control *control;
+	int num;
+
+	control = find_gpio_control(lnw_gpio_controls,
+			ARRAY_SIZE(lnw_gpio_controls), type);
+	if (control == NULL)
+		return;
+
+	num = find_pininfo_num(control, info);
+	if (num == -1)
+		return;
+
+	if (control->set)
+		control->set(control, lnw, gpio, num);
+}
+
+static int lnw_get_register_msg(char **buf, unsigned long *size)
+{
+	*buf = conf_reg_msg;
+	*size = strlen(conf_reg_msg);
+
+	return 0;
+}
+
+static struct gpio_debug_ops lnw_gpio_debug_ops = {
+	.get_conf_reg = lnw_get_conf_reg,
+	.set_conf_reg = lnw_set_conf_reg,
+	.get_avl_pininfo = lnw_get_avl_pininfo,
+	.get_cul_pininfo = lnw_get_cul_pininfo,
+	.set_pininfo = lnw_set_pininfo,
+	.get_register_msg = lnw_get_register_msg,
+};
+
 static void lnw_irq_init_hw(struct lnw_gpio *lnw)
 {
 	void __iomem *reg;
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 0f1204add4a6..5fb0225c6af1 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -790,7 +790,7 @@ config PVPANIC
 	  (guest) communicate panic events to the host.
 
 config INTEL_SCU_FLIS
-	tristate "scu flis driver config"
+	bool "scu flis driver config"
 	depends on INTEL_SCU_IPC
 	default y
 	help
diff --git a/drivers/platform/x86/intel_scu_flis.c b/drivers/platform/x86/intel_scu_flis.c
index 165110f76d94..c867f3b34bd0 100644
--- a/drivers/platform/x86/intel_scu_flis.c
+++ b/drivers/platform/x86/intel_scu_flis.c
@@ -36,18 +36,52 @@ static u32 shim_data;
 static char shim_ops[OPS_STR_LEN];
 
 static u32 param_type;	/* flis param type: PULL/PIN DIRECTION/OPEN_DRAIN */
-static u8 param_value;	/* value of certain flis param */
-static enum pinname_t pin_name;
+static u32 param_value;	/* value of certain flis param */
+static unsigned int pin_name;
 static char ops[OPS_STR_LEN];
 
 struct intel_scu_flis_info {
 	struct pinstruct_t *pin_t;
+	struct pin_mmio_flis_t *mmio_flis_t;
 	int pin_num;
 	int initialized;
+	void *flis_base;
 };
 
 static struct intel_scu_flis_info flis_info;
 
+static DEFINE_SPINLOCK(mmio_flis_lock);
+
+u32 get_flis_value(u32 offset)
+{
+	struct intel_scu_flis_info *isfi = &flis_info;
+	u32 __iomem *mem;
+
+	if (!isfi->initialized || !isfi->flis_base)
+		return -ENODEV;
+
+	mem = (void __iomem *)(isfi->flis_base + offset);
+
+	return readl(mem);
+}
+EXPORT_SYMBOL(get_flis_value);
+
+void set_flis_value(u32 value, u32 offset)
+{
+	struct intel_scu_flis_info *isfi = &flis_info;
+	u32 __iomem *mem;
+	unsigned long flags;
+
+	if (!isfi->initialized || !isfi->flis_base)
+		return;
+
+	mem = (void __iomem *)(isfi->flis_base + offset);
+	spin_lock_irqsave(&mmio_flis_lock, flags);
+	writel(value, mem);
+	spin_unlock_irqrestore(&mmio_flis_lock, flags);
+}
+EXPORT_SYMBOL(set_flis_value);
+
 /* directly write to flis address */
 int intel_scu_ipc_write_shim(u32 data, u32 flis_addr, u32 offset)
 {
@@ -122,7 +156,7 @@ int intel_scu_ipc_update_shim(u32 data, u32 mask, u32 flis_addr, u32 offset)
 EXPORT_SYMBOL(intel_scu_ipc_update_shim);
 
 /**
- * config_pin_flis -- configure pin direction,
+ * config_pin_flis -- configure pin mux,
  *		      pull direction and strength and open-drain enable.
  *
  * @name: pin name
@@ -134,23 +168,25 @@ EXPORT_SYMBOL(intel_scu_ipc_update_shim);
  *	config_pin_flis(i2s_2_clk, PULL, UP_20K);
  *	config_pin_flis(i2s_2_clk, PULL, DOWN_20K);
  *
- * config pin direction:
- *	config_pin_flis(i2s_2_clk, PIN_DIRECTION, MUX_EN_INPUT_EN);
- *	config_pin_flis(i2s_2_clk, PIN_DIRECTION, INPUT_EN);
- *	config_pin_flis(i2s_2_clk, PIN_DIRECTION, MUX_EN_OUTPUT_EN);
- *	config_pin_flis(i2s_2_clk, PIN_DIRECTION, OUTPUT_EN);
+ * config pin mux:
+ *	config_pin_flis(i2s_2_clk, MUX, MUX_EN_INPUT_EN);
+ *	config_pin_flis(i2s_2_clk, MUX, INPUT_EN);
+ *	config_pin_flis(i2s_2_clk, MUX, MUX_EN_OUTPUT_EN);
+ *	config_pin_flis(i2s_2_clk, MUX, OUTPUT_EN);
  *
  * config pin open-drain:
  *	config_pin_flis(i2s_2_clk, OPEN_DRAIN, OD_ENABLE);
  *	config_pin_flis(i2s_2_clk, OPEN_DRAIN, OD_DISABLE);
  *
  */
-int config_pin_flis(enum pinname_t name, enum flis_param_t param, u8 val)
+int config_pin_flis(unsigned int name, enum flis_param_t param, u32 val)
 {
 	u32 flis_addr, off, data, mask;
 	int ret;
 	int pos;
 	struct intel_scu_flis_info *isfi = &flis_info;
+	struct pin_mmio_flis_t *mmft;
+	u32 old_val;
 
 	if (!isfi->initialized)
 		return -ENODEV;
@@ -158,55 +194,88 @@ int config_pin_flis(enum pinname_t name, enum flis_param_t param, u8 val)
 	if (name < 0 || name >= isfi->pin_num)
 		return -EINVAL;
 
-	/* Check if the pin is configurable */
-	if (isfi->pin_t[name].valid == false)
-		return -EINVAL;
-
-	flis_addr = isfi->pin_t[name].bus_address;
-
-	switch (param) {
-	case PULL:
-		off = isfi->pin_t[name].pullup_offset;
-		pos = isfi->pin_t[name].pullup_lsb_pos;
-		mask = (PULL_MASK << pos);
-		break;
-	case MUX:
-		off = isfi->pin_t[name].direction_offset;
-		pos = isfi->pin_t[name].direction_lsb_pos;
-		mask = (MUX_MASK << pos);
-		break;
-	case OPEN_DRAIN:
-		off = isfi->pin_t[name].open_drain_offset;
-		pos = isfi->pin_t[name].open_drain_bit;
-		mask = (OPEN_DRAIN_MASK << pos);
-		break;
-	default:
-		pr_err("Please specify valid flis param\n");
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CLOVERVIEW) {
+		/* Check if the pin is configurable */
+		if (isfi->pin_t[name].valid == false)
+			return -EINVAL;
+
+		flis_addr = isfi->pin_t[name].bus_address;
+
+		switch (param) {
+		case PULL:
+			off = isfi->pin_t[name].pullup_offset;
+			pos = isfi->pin_t[name].pullup_lsb_pos;
+			mask = (PULL_MASK << pos);
+			break;
+		case MUX:
+			off = isfi->pin_t[name].direction_offset;
+			pos = isfi->pin_t[name].direction_lsb_pos;
+			mask = (MUX_MASK << pos);
+			break;
+		case OPEN_DRAIN:
+			off = isfi->pin_t[name].open_drain_offset;
+			pos = isfi->pin_t[name].open_drain_bit;
+			mask = (OPEN_DRAIN_MASK << pos);
+			break;
+		default:
+			pr_err("Please specify valid flis param\n");
+			return -EINVAL;
+		}
+
+		data = (val << pos);
+		pr_debug("addr = 0x%x, off = 0x%x, pos = %d, mask = 0x%x, data = 0x%x\n",
+				flis_addr, off, pos, mask, data);
+
+		ret = intel_scu_ipc_update_shim(data, mask, flis_addr, off);
+		if (ret) {
+			pr_err("update shim failed\n");
+			return ret;
+		}
+	} else if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) {
+		mmft = isfi->mmio_flis_t;
+		off = mmft[name].offset;
+
+		/* Check if the FLIS is writable by mmio access */
+		if (!(mmft[name].access_ctrl & writable))
+			return -EINVAL;
+
+		old_val = get_flis_value(off);
+
+		switch (param) {
+		case PULL:
+			mask = PULL_MASK;
+			break;
+		case MUX:
+			mask = MUX_MASK;
+			break;
+		case OPEN_DRAIN:
+			mask = OPEN_DRAIN_MASK;
+			break;
+		default:
+			pr_err("Please specify valid flis param\n");
+			return -EINVAL;
+		}
+
+		set_flis_value((old_val & ~mask) | val, off);
+
+	} else
 		return -EINVAL;
-	}
 
-	data = (val << pos);
-	pr_debug("addr = 0x%x, off = 0x%x, pos = %d, mask = 0x%x, data = 0x%x\n",
-			flis_addr, off, pos, mask, data);
-
-	ret = intel_scu_ipc_update_shim(data, mask, flis_addr, off);
-	if (ret) {
-		pr_err("update shim failed\n");
-		return ret;
-	}
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(config_pin_flis);
 
-int get_pin_flis(enum pinname_t name, enum flis_param_t param, u8 *val)
+int get_pin_flis(unsigned int name, enum flis_param_t param, u32 *val)
 {
 	u32 flis_addr, off;
 	u32 data = 0;
 	int ret;
 	int pos;
-	u8 mask;
+	u32 mask;
 	struct intel_scu_flis_info *isfi = &flis_info;
+	struct pin_mmio_flis_t *mmft;
+	u32 old_val;
 
 	if (!isfi->initialized)
 		return -ENODEV;
@@ -214,42 +283,71 @@ int get_pin_flis(enum pinname_t name, enum flis_param_t param, u8 *val)
 	if (name < 0 || name >= isfi->pin_num)
 		return -EINVAL;
 
-	if (isfi->pin_t[name].valid == false)
-		return -EINVAL;
-
-	flis_addr = isfi->pin_t[name].bus_address;
-
-	switch (param) {
-	case PULL:
-		off = isfi->pin_t[name].pullup_offset;
-		pos = isfi->pin_t[name].pullup_lsb_pos;
-		mask = PULL_MASK;
-		break;
-	case MUX:
-		off = isfi->pin_t[name].direction_offset;
-		pos = isfi->pin_t[name].direction_lsb_pos;
-		mask = MUX_MASK;
-		break;
-	case OPEN_DRAIN:
-		off = isfi->pin_t[name].open_drain_offset;
-		pos = isfi->pin_t[name].open_drain_bit;
-		mask = OPEN_DRAIN_MASK;
-		break;
-	default:
-		pr_err("Please specify valid flis param\n");
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CLOVERVIEW) {
+		if (isfi->pin_t[name].valid == false)
+			return -EINVAL;
+
+		flis_addr = isfi->pin_t[name].bus_address;
+
+		switch (param) {
+		case PULL:
+			off = isfi->pin_t[name].pullup_offset;
+			pos = isfi->pin_t[name].pullup_lsb_pos;
+			mask = PULL_MASK;
+			break;
+		case MUX:
+			off = isfi->pin_t[name].direction_offset;
+			pos = isfi->pin_t[name].direction_lsb_pos;
+			mask = MUX_MASK;
+			break;
+		case OPEN_DRAIN:
+			off = isfi->pin_t[name].open_drain_offset;
+			pos = isfi->pin_t[name].open_drain_bit;
+			mask = OPEN_DRAIN_MASK;
+			break;
+		default:
+			pr_err("Please specify valid flis param\n");
+			return -EINVAL;
+		}
+
+		ret = intel_scu_ipc_read_shim(&data, flis_addr, off);
+		if (ret) {
+			pr_err("read shim failed, addr = 0x%x, off = 0x%x\n",
+				flis_addr, off);
+			return ret;
+		}
+
+		*val = (data >> pos) & mask;
+
+		pr_debug("read: data = 0x%x, val = 0x%x\n", data, *val);
+	} else if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) {
+		mmft = isfi->mmio_flis_t;
+		off = mmft[name].offset;
+
+		old_val = get_flis_value(off);
+
+		switch (param) {
+		case PULL:
+			pos = 4;
+			mask = PULL_MASK;
+			break;
+		case MUX:
+			pos = 12;
+			mask = MUX_MASK;
+			break;
+		case OPEN_DRAIN:
+			pos = 21;
+			mask = OPEN_DRAIN_MASK;
+			break;
+		default:
+			pr_err("Please specify valid flis param\n");
+			return -EINVAL;
+		}
+
+		*val = (old_val & mask) >> pos;
+
+	} else
 		return -EINVAL;
-	}
-
-	ret = intel_scu_ipc_read_shim(&data, flis_addr, off);
-	if (ret) {
-		pr_err("read shim failed, addr = 0x%x, off = 0x%x\n",
-			flis_addr, off);
-		return ret;
-	}
-
-	*val = (data >> pos) & mask;
-
-	pr_debug("read: data = 0x%x, val = 0x%x\n", data, *val);
 
 	return 0;
 }
@@ -280,13 +378,13 @@ static void flis_generic_store(const char *buf, int type)
 		shim_data = tmp;
 		break;
 	case DBG_PARAM_VAL:
-		param_value = (u8)tmp;
+		param_value = tmp;
 		break;
 	case DBG_PARAM_TYPE:
 		param_type = tmp;
 		break;
 	case DBG_PIN_NAME:
-		pin_name = (enum pinname_t)tmp;
+		pin_name = tmp;
 		break;
 	default:
 		break;
@@ -484,28 +582,41 @@ static int scu_flis_probe(struct platform_device *pdev)
 
 	isfi->pin_t = pdata->pin_t;
 	isfi->pin_num = pdata->pin_num;
+	isfi->mmio_flis_t = pdata->mmio_flis_t;
+	if (pdata->mmio_flis_t && pdata->flis_base) {
+		isfi->flis_base = ioremap_nocache(pdata->flis_base,
+					pdata->flis_len);
+		if (!isfi->flis_base) {
+			dev_err(&pdev->dev, "error mapping flis base\n");
+			ret = -EFAULT;
+			goto out;
+		}
+	}
 
-	if (isfi->pin_t && isfi->pin_num)
+	if ((isfi->pin_t || isfi->mmio_flis_t)&&isfi->pin_num)
 		isfi->initialized = 1;
 
 	ret = sysfs_create_group(&pdev->dev.kobj, &flis_attr_group);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to create flis sysfs interface\n");
-		goto out;
+		goto err1;
 	}
 
 	ret = sysfs_create_group(&pdev->dev.kobj, &pin_config_attr_group);
 	if (ret) {
 		dev_err(&pdev->dev,
 				"Failed to create pin config sysfs interface\n");
-		goto err1;
+		goto err2;
 	}
 
 	dev_info(&pdev->dev, "scu flis probed\n");
 	return 0;
 
-err1:
+err2:
 	sysfs_remove_group(&pdev->dev.kobj, &flis_attr_group);
+err1:
+	if (pdata->flis_base)
+		iounmap(isfi->flis_base);
 out:
 	isfi->initialized = 0;
 	return ret;
-- 
2.37.3

