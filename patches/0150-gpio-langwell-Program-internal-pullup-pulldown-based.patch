From d1d9c50d09bca1b8ae7a14c6190f024aaca9d0f2 Mon Sep 17 00:00:00 2001
From: Bharath Kumar Veera <bharath.k.veera@intel.com>
Date: Tue, 29 Oct 2013 12:49:03 +0530
Subject: [PATCH 150/429] gpio-langwell: Program internal pullup/pulldown based
 on GPIO output pins value to resolve contention and thereby save power

The GPIO pins that are configured and used as output pins, should have
an internal pullup/pulldown based on the logic that particular output
pin is driving at that moment.
Say if a GPIO output pin is driving logic low, and if there is a pullup,
then there will be contention - wherein there will be a clear path of
current to leak. And if neither pullup nor pulldown is present/configured,
there will still be leakage across SoC. Hence program the pullup or pulldown
dynamically based on the value that output pin is driving.
Also I2C pins are untouched with this patch.

Signed-off-by: Bharath Kumar Veera <bharath.k.veera@intel.com>
---
 drivers/gpio/gpio-langwell.c | 37 +++++++++++++++++++++++++++++++++++-
 1 file changed, 36 insertions(+), 1 deletion(-)

diff --git a/drivers/gpio/gpio-langwell.c b/drivers/gpio/gpio-langwell.c
index 92851da7457d..ae50e931dbf7 100644
--- a/drivers/gpio/gpio-langwell.c
+++ b/drivers/gpio/gpio-langwell.c
@@ -391,10 +391,46 @@ static int lnw_gpio_get(struct gpio_chip *chip, unsigned offset)
 	return readl(gplr) & BIT(offset % 32);
 }
 
+#define PULLUP_ENABLE	(1 << 8)
+#define PULLDOWN_ENABLE	(1 << 9)
+#define PUPD_VAL_2K	(0 << 4)
+#define PUPD_VAL_20K	(1 << 4)
+#define PUPD_VAL_50K	(2 << 4)
+#define PUPD_VAL_910	(3 << 4)
+#define I2C_FLIS_START	0x1D00
+#define I2C_FLIS_END	0x1D34
+
+static int lnw_gpio_set_pull(struct gpio_chip *chip, unsigned gpio, int value)
+{
+	u32 flis_offset, flis_value;
+	struct lnw_gpio *lnw = to_lnw_priv(chip);
+
+	if (lnw->type != TANGIER_GPIO)
+		return 0;
+
+	flis_offset = lnw->get_flis_offset(gpio);
+	if (WARN(flis_offset == -EINVAL, "invalid pin %d\n", gpio))
+		return -1;
+	if (flis_offset >= I2C_FLIS_START && flis_offset <= I2C_FLIS_END)
+		return 0;
+	flis_value = get_flis_value(flis_offset);
+	if (value) {
+		flis_value |= PULLUP_ENABLE;
+		flis_value &= ~PULLDOWN_ENABLE;
+	} else {
+		flis_value |= PULLDOWN_ENABLE;
+		flis_value &= ~PULLUP_ENABLE;
+	}
+	flis_value |= PUPD_VAL_50K;
+	set_flis_value(flis_value, flis_offset);
+}
+
 static void lnw_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 {
 	void __iomem *gpsr, *gpcr;
 
+	lnw_gpio_set_pull(chip, offset, value);
+
 	if (value) {
 		gpsr = gpio_reg(chip, offset, GPSR);
 		writel(BIT(offset % 32), gpsr);
@@ -600,7 +636,6 @@ static int gpio_set_pinvalue(struct gpio_control *control, void *private_data,
 	struct lnw_gpio *lnw = private_data;
 
 	lnw_gpio_set(&lnw->chip, gpio, num);
-
 	return 0;
 }
 
-- 
2.37.3

