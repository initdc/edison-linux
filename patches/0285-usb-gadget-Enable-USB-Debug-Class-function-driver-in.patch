From 9551a888216a46b437c107a4016adbe6df50b732 Mon Sep 17 00:00:00 2001
From: Yann Fouassier <yann.fouassier@intel.com>
Date: Thu, 24 Oct 2013 15:00:39 +0200
Subject: [PATCH 285/429] usb/gadget: Enable USB Debug-Class function driver in
 android gadget

Added USB 3.0 Debug-Class : DvC.DFx and DvC.Trace subclass gadget function driver

Signed-off-by: Yann Fouassier <yann.fouassier@intel.com>
---
 drivers/usb/gadget/epautoconf.c   |  42 ++
 drivers/usb/gadget/f_dvc_dfx.c    | 922 ++++++++++++++++++++++++++++++
 drivers/usb/gadget/f_dvc_trace.c  | 887 ++++++++++++++++++++++++++++
 drivers/usb/gadget/gadget_chips.h |   5 +-
 include/linux/usb/debug.h         | 253 ++++++++
 include/uapi/linux/usb/ch9.h      |   1 +
 6 files changed, 2109 insertions(+), 1 deletion(-)
 create mode 100644 drivers/usb/gadget/f_dvc_dfx.c
 create mode 100644 drivers/usb/gadget/f_dvc_trace.c
 create mode 100644 include/linux/usb/debug.h

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index a777f7bd11b4..3f10698b550c 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -188,6 +188,8 @@ ep_matches (
 	ep->address = desc->bEndpointAddress;
 	return 1;
 }
+EXPORT_SYMBOL_GPL(ep_matches);
+
 
 static struct usb_ep *
 find_ep (struct usb_gadget *gadget, const char *name)
@@ -200,6 +202,7 @@ find_ep (struct usb_gadget *gadget, const char *name)
 	}
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(find_ep);
 
 /**
  * usb_ep_autoconfig_ss() - choose an endpoint matching the ep
@@ -253,7 +256,11 @@ struct usb_ep *usb_ep_autoconfig_ss(
 {
 	struct usb_ep	*ep;
 	u8		type;
+#ifdef CONFIG_USB_DWC3_GADGET
+	u8	       addr;
 
+	addr = desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+#endif
 	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 
 	/* First, apply chip-specific "best usage" knowledge.
@@ -301,10 +308,45 @@ struct usb_ep *usb_ep_autoconfig_ss(
 		if (ep && ep_matches(gadget, ep, desc, ep_comp))
 			goto found_ep;
 #endif
+
+#ifdef CONFIG_USB_DWC3_GADGET
+	} else if (gadget_is_middwc3tng(gadget)) {
+		if (addr == 0x1) {
+			/* statically assigned ebc-ep1 in/out  */
+			if ((desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+			    & USB_DIR_IN)
+				ep = find_ep(gadget, "ep1in");
+			else
+				ep = NULL;
+		} else if (addr == 0x8) {
+			/* statically assigned ebc-ep8 in/out */
+			if ((desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+			    & USB_DIR_IN)
+				ep = find_ep (gadget, "ep8in");
+			else
+				ep = find_ep (gadget, "ep8out");
+		} else
+			ep = NULL;
+		if (ep && ep_matches(gadget, ep, desc, ep_comp))
+			goto found_ep;
+#endif
+
 	}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
+
+#ifdef CONFIG_USB_DWC3_GADGET
+		/* ep1in and ep8in are reserved for DWC3 device controller */
+		if (!strncmp(ep->name, "ep1in", 5) ||
+		    !strncmp(ep->name, "ep8in", 5))
+			continue;
+		if (gadget_is_middwc3tng(gadget))
+			/* ep1out and ep8out are also reserved */
+			if (!strncmp(ep->name, "ep1out", 6) ||
+			    !strncmp(ep->name, "ep8out", 6))
+				continue;
+#endif
 		if (ep_matches(gadget, ep, desc, ep_comp))
 			goto found_ep;
 	}
diff --git a/drivers/usb/gadget/f_dvc_dfx.c b/drivers/usb/gadget/f_dvc_dfx.c
new file mode 100644
index 000000000000..6137e11461d1
--- /dev/null
+++ b/drivers/usb/gadget/f_dvc_dfx.c
@@ -0,0 +1,922 @@
+/*
+ * Gadget Driver for Android DvC.Dfx Debug Capability
+ *
+ * Copyright (C) 2008-2010, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/usb/debug.h>
+#include <linux/sdm.h>
+#include <asm/intel_soc_debug.h>
+
+#define DFX_RX_REQ_MAX 1
+#define DFX_TX_REQ_MAX 2
+#define DFX_BULK_REQ_SIZE 64
+
+#define CONFIG_BOARD_MRFLD_VV
+
+struct dvc_dfx_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	spinlock_t lock;
+	u8	ctrl_id, data_id;
+
+	struct usb_ep *ep_in;
+	struct usb_ep *ep_out;
+
+	int transfering;
+	int online;
+	int online_ctrl;
+	int online_data;
+	int error;
+
+	atomic_t read_excl;
+	atomic_t write_excl;
+	atomic_t open_excl;
+
+	wait_queue_head_t read_wq;
+	wait_queue_head_t write_wq;
+
+	struct usb_request *rx_req[DFX_RX_REQ_MAX];
+
+	struct list_head tx_idle;
+	struct list_head tx_xfer;
+};
+
+static struct usb_interface_assoc_descriptor dfx_iad_desc = {
+	.bLength		= sizeof(dfx_iad_desc),
+	.bDescriptorType	= USB_DT_INTERFACE_ASSOCIATION,
+	/* .bFirstInterface	= DYNAMIC, */
+	.bInterfaceCount	= 2, /* debug control + data */
+	.bFunctionClass		= USB_CLASS_DEBUG,
+	.bFunctionSubClass	= USB_SUBCLASS_DVC_DFX,
+	/* .bFunctionProtocol	= DC_PROTOCOL_VENDOR, */
+	/* .iFunction		= 0, */
+};
+
+static struct usb_interface_descriptor dfx_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bNumEndpoints          = 0,
+	.bInterfaceClass        = USB_CLASS_DEBUG,
+	.bInterfaceSubClass     = USB_SUBCLASS_DEBUG_CONTROL,
+	/* .bInterfaceProtocol     = DC_PROTOCOL_VENDOR, */
+};
+
+#define DC_DBG_ATTRI_LENGTH	DC_DBG_ATTRI_SIZE(2, 32)
+/* 1 input terminal, 1 output terminal and 1 feature unit */
+#define DC_DBG_TOTAL_LENGTH (DC_DBG_ATTRI_LENGTH)
+
+DECLARE_DC_DEBUG_ATTR_DESCR(DVCD, 2, 32);
+
+static struct DC_DEBUG_ATTR_DESCR(DVCD) dfx_debug_attri_desc = {
+	.bLength		= DC_DBG_ATTRI_LENGTH,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= DC_DEBUG_ATTRIBUTES,
+	.bcdDC			= __constant_cpu_to_le16(0x0100),
+	.wTotalLength		= __constant_cpu_to_le16(DC_DBG_TOTAL_LENGTH),
+	.bmSupportedFeatures	= 0, /* Debug Event Supported, per SAS */
+	.bControlSize		= 2,
+	.bmControl		= {	/* per SAS */
+		[0]		= 0xFF,
+		[1]		= 0x3F,
+	},
+	.wAuxDataSize		= __constant_cpu_to_le16(0x20),
+/* per SAS v0.3*/
+	.dInputBufferSize	= __constant_cpu_to_le32(0x40),
+	.dOutputBufferSize	= __constant_cpu_to_le32(0x80),
+	.qBaseAddress		= 0, /* revision */
+	.hGlobalID		= { /* revision */
+		[0]		= 0,
+		[1]		= 0,
+	}
+};
+
+static struct usb_interface_descriptor dfx_data_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bAlternateSetting	= 0,
+	.bNumEndpoints          = 2,
+	.bInterfaceClass        = USB_CLASS_DEBUG,
+	.bInterfaceSubClass     = USB_SUBCLASS_DVC_DFX,
+	/* .bInterfaceProtocol     = DC_PROTOCOL_VENDOR, */
+};
+
+static struct usb_endpoint_descriptor dfx_fullspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor dfx_fullspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor dfx_highspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor dfx_highspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor dfx_superspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor dfx_superspeed_in_comp_desc = {
+	.bLength		= USB_DT_SS_EP_COMP_SIZE,
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	.bMaxBurst		= 0,
+	.bmAttributes		= 0,
+};
+
+static struct usb_endpoint_descriptor dfx_superspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor dfx_superspeed_out_comp_desc = {
+	.bLength		= USB_DT_SS_EP_COMP_SIZE,
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	.bMaxBurst		= 0,
+	.bmAttributes		= 0,
+};
+
+/* no INPUT/OUTPUT CONNECTION and UNIT descriptors for DvC.DFx */
+static struct usb_descriptor_header *fs_dfx_descs[] = {
+	(struct usb_descriptor_header *) &dfx_iad_desc,
+	(struct usb_descriptor_header *) &dfx_data_interface_desc,
+	(struct usb_descriptor_header *) &dfx_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &dfx_fullspeed_out_desc,
+
+	(struct usb_descriptor_header *) &dfx_interface_desc,
+	(struct usb_descriptor_header *) &dfx_debug_attri_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_dfx_descs[] = {
+	(struct usb_descriptor_header *) &dfx_iad_desc,
+	(struct usb_descriptor_header *) &dfx_data_interface_desc,
+	(struct usb_descriptor_header *) &dfx_highspeed_in_desc,
+	(struct usb_descriptor_header *) &dfx_highspeed_out_desc,
+
+	(struct usb_descriptor_header *) &dfx_interface_desc,
+	(struct usb_descriptor_header *) &dfx_debug_attri_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *ss_dfx_descs[] = {
+	(struct usb_descriptor_header *) &dfx_iad_desc,
+	(struct usb_descriptor_header *) &dfx_data_interface_desc,
+	(struct usb_descriptor_header *) &dfx_superspeed_in_desc,
+	(struct usb_descriptor_header *) &dfx_superspeed_in_comp_desc,
+	(struct usb_descriptor_header *) &dfx_superspeed_out_desc,
+	(struct usb_descriptor_header *) &dfx_superspeed_out_comp_desc,
+
+	(struct usb_descriptor_header *) &dfx_interface_desc,
+	(struct usb_descriptor_header *) &dfx_debug_attri_desc,
+	NULL,
+};
+
+/* string descriptors: */
+
+#define DVCDFX_CTRL_IDX	0
+#define DVCDFX_DATA_IDX	1
+#define DVCDFX_IAD_IDX	2
+
+/* static strings, in UTF-8 */
+static struct usb_string dfx_string_defs[] = {
+	[DVCDFX_CTRL_IDX].s = "Debug Sub-Class DvC.DFx (Control)",
+	[DVCDFX_DATA_IDX].s = "Debug Sub-Class DvC.DFx (Data)",
+	[DVCDFX_IAD_IDX].s = "Debug Sub-Class DvC.DFx",
+	{  /* ZEROES END LIST */ },
+};
+
+static struct usb_gadget_strings dfx_string_table = {
+	.language =		0x0409,	/* en-us */
+	.strings =		dfx_string_defs,
+};
+
+static struct usb_gadget_strings *dfx_strings[] = {
+	&dfx_string_table,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* temporary variable used between dvc_dfx_open() and dvc_dfx_gadget_bind() */
+static struct dvc_dfx_dev *_dvc_dfx_dev;
+
+static inline struct dvc_dfx_dev *func_to_dvc_dfx(struct usb_function *f)
+{
+	return container_of(f, struct dvc_dfx_dev, function);
+}
+
+static int dvc_dfx_is_enabled(void)
+{
+	if ((!cpu_has_debug_feature(DEBUG_FEATURE_USB3DFX)) ||
+	    (!stm_is_enabled())) {
+		pr_info("%s STM and/or USB3DFX is not enabled\n", __func__);
+		return 0;
+	}
+	return 1;
+}
+
+static struct usb_request *dvc_dfx_request_new(struct usb_ep *ep,
+					       int buffer_size, dma_addr_t dma)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+
+	req->dma = dma;
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void dvc_dfx_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+/* add a request to the tail of a list */
+static void dvc_dfx_req_put(struct dvc_dfx_dev *dev, struct list_head *head,
+		struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* remove a request from the head of a list */
+static struct usb_request *dvc_dfx_req_get(struct dvc_dfx_dev *dev,
+					   struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return req;
+}
+
+static void dvc_dfx_set_disconnected(struct dvc_dfx_dev *dev)
+{
+	dev->transfering = 0;
+}
+
+static void dvc_dfx_complete_in(struct usb_ep *ep, struct usb_request *req)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+
+	if (req->status != 0)
+		dvc_dfx_set_disconnected(dev);
+
+	dvc_dfx_req_put(dev, &dev->tx_idle, req);
+
+	wake_up(&dev->write_wq);
+}
+
+static void dvc_dfx_complete_out(struct usb_ep *ep, struct usb_request *req)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+
+	if (req->status != 0)
+		dvc_dfx_set_disconnected(dev);
+	wake_up(&dev->read_wq);
+}
+
+
+static inline int dvc_dfx_lock(atomic_t *excl)
+{
+	if (atomic_inc_return(excl) == 1) {
+		return 0;
+	} else {
+		atomic_dec(excl);
+		return -1;
+	}
+}
+
+static inline void dvc_dfx_unlock(atomic_t *excl)
+{
+	atomic_dec(excl);
+}
+
+static int dfx_create_bulk_endpoints(struct dvc_dfx_dev *dev,
+				     struct usb_endpoint_descriptor *in_desc,
+				     struct usb_endpoint_descriptor *out_desc,
+				     struct usb_ss_ep_comp_descriptor *in_comp_desc,
+				     struct usb_ss_ep_comp_descriptor *out_comp_desc
+	)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	struct usb_ep *ep;
+	int i;
+
+	pr_debug("%s dev: %p\n", __func__, dev);
+
+	in_desc->bEndpointAddress |= 0x8;
+	ep = usb_ep_autoconfig_ss(cdev->gadget, in_desc, in_comp_desc);
+	if (!ep) {
+		pr_debug("%s for ep_in failed\n", __func__);
+		return -ENODEV;
+	}
+	pr_debug("%s for ep_in got %s\n", __func__, ep->name);
+
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_in = ep;
+
+	out_desc->bEndpointAddress |= 0x8;
+	ep = usb_ep_autoconfig_ss(cdev->gadget, out_desc, out_comp_desc);
+	if (!ep) {
+		pr_debug("%s for ep_out failed\n", __func__);
+		return -ENODEV;
+	}
+	pr_debug("%s for ep_out got %s\n", __func__, ep->name);
+
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_out = ep;
+
+	/* now allocate requests for our endpoints */
+	for (i = 0; i < DFX_TX_REQ_MAX; i++) {
+		if (!(i % 2))
+			req = dvc_dfx_request_new(dev->ep_in,
+				DFX_BULK_BUFFER_SIZE,
+				(dma_addr_t)DFX_BULK_IN_BUFFER_ADDR);
+		else
+			req = dvc_dfx_request_new(dev->ep_in,
+				DFX_BULK_BUFFER_SIZE,
+				(dma_addr_t)DFX_BULK_IN_BUFFER_ADDR_2);
+		if (!req)
+			goto fail;
+		req->complete = dvc_dfx_complete_in;
+		dvc_dfx_req_put(dev, &dev->tx_idle, req);
+	}
+	for (i = 0; i < DFX_RX_REQ_MAX; i++) {
+		req = dvc_dfx_request_new(dev->ep_out, DFX_BULK_BUFFER_SIZE,
+			(dma_addr_t)DFX_BULK_OUT_BUFFER_ADDR);
+		if (!req)
+			goto fail;
+		req->complete = dvc_dfx_complete_out;
+		dev->rx_req[i] = req;
+	}
+
+	return 0;
+
+fail:
+	pr_err("%s could not allocate requests\n", __func__);
+	while ((req = dvc_dfx_req_get(dev, &dev->tx_idle)))
+		dvc_dfx_request_free(req, dev->ep_out);
+	for (i = 0; i < DFX_RX_REQ_MAX; i++)
+		dvc_dfx_request_free(dev->rx_req[i], dev->ep_out);
+	return -1;
+}
+
+static ssize_t dvc_dfx_start_transfer(size_t count)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+	struct usb_request *req;
+	int r = count, xfer;
+	int ret = -ENODEV;
+
+
+	pr_info("%s start\n", __func__);
+	if (!_dvc_dfx_dev)
+		return ret;
+
+	if (dvc_dfx_lock(&dev->read_excl)
+	    && dvc_dfx_lock(&dev->write_excl))
+		return -EBUSY;
+
+	/* we will block until enumeration completes */
+	while (!(dev->online || dev->error)) {
+		pr_debug("%s waiting for online state\n", __func__);
+		ret = wait_event_interruptible(dev->read_wq,
+				(dev->online || dev->error));
+
+		if (ret < 0) {
+			/* not at CONFIGURED state */
+			pr_info("%s USB not at CONFIGURED\n", __func__);
+			dvc_dfx_unlock(&dev->read_excl);
+			dvc_dfx_unlock(&dev->write_excl);
+			return ret;
+		}
+	}
+
+	/* queue a ep_in endless request */
+	while (r > 0) {
+		if (dev->error) {
+			pr_debug("%s dev->error\n", __func__);
+			r = -EIO;
+			break;
+		}
+
+		if (!dev->online) {
+			pr_debug("%s !dev->online issue\n", __func__);
+			r = -EIO;
+			break;
+		}
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+				dev->error || !dev->online ||
+				(req = dvc_dfx_req_get(dev, &dev->tx_idle)));
+
+		if (ret < 0) {
+			r = ret;
+			break;
+		}
+
+		if (req != 0) {
+			if (count > DFX_BULK_BUFFER_SIZE)
+				xfer = DFX_BULK_BUFFER_SIZE;
+			else
+				xfer = count;
+
+			req->no_interrupt = 1;
+			req->context = &dev->function;
+			req->length = xfer;
+			pr_debug("%s queue tx_idle list req to dev->ep_in\n",
+				__func__);
+			ret = usb_ep_queue(dev->ep_in, req, GFP_ATOMIC);
+			if (ret < 0) {
+				pr_err("%s xfer error %d\n", __func__, ret);
+					dev->error = 1;
+				r = -EIO;
+				break;
+			}
+			pr_debug("%s xfer=%d/%d  queued req/%x\n", __func__,
+				xfer, r, (uint)req);
+			dvc_dfx_req_put(dev, &dev->tx_xfer, req);
+			r -= xfer;
+
+			/* zero this so we don't try to free it on error exit */
+			req = 0;
+		}
+	}
+	if (req) {
+		pr_debug("%s req re-added to tx_idle on error\n", __func__);
+		dvc_dfx_req_put(dev, &dev->tx_idle, req);
+	}
+
+	pr_debug("%s rx_req to dev->ep_out\n", __func__);
+	/* queue a ep_out endless request */
+	req = dev->rx_req[0];
+	req->length = DFX_BULK_BUFFER_SIZE;
+	req->no_interrupt = 1;
+	req->context = &dev->function;
+	ret = usb_ep_queue(dev->ep_out, req, GFP_ATOMIC);
+	if (ret < 0) {
+		pr_err("%s failed to queue out req %p (%d)\n",
+		       __func__, req, req->length);
+		r = -EIO;
+	} else {
+		dev->transfering = 1;
+	}
+
+	dvc_dfx_unlock(&dev->read_excl);
+	dvc_dfx_unlock(&dev->write_excl);
+	pr_debug("%s returning\n", __func__);
+	return r;
+}
+
+static int dvc_dfx_disable_transfer(void)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+	struct usb_request *req;
+	int r = 1;
+	int ret;
+
+
+	pr_info("%s start\n", __func__);
+	if (!_dvc_dfx_dev)
+		return -ENODEV;
+
+	if (dvc_dfx_lock(&dev->read_excl)
+	    && dvc_dfx_lock(&dev->write_excl))
+		return -EBUSY;
+
+	if (dev->error) {
+		pr_debug("%s dev->error\n", __func__);
+		r = -EIO;
+		goto end;
+	}
+
+	if ((!dev->online) || (!dev->transfering)) {
+		pr_debug("%s !dev->online OR !dev->transfering\n", __func__);
+		r = -EIO;
+		goto end;
+	}
+
+	/* get an xfer tx request to use */
+	while ((req = dvc_dfx_req_get(dev, &dev->tx_xfer))) {
+		ret = usb_ep_dequeue(dev->ep_in, req);
+		if (ret < 0) {
+			pr_err("%s dequeue error %d\n", __func__, ret);
+			dev->error = 1;
+			r = -EIO;
+			goto end;
+		}
+		pr_debug("%s dequeued tx req/%x\n", __func__, (uint)req);
+	}
+	ret = usb_ep_dequeue(dev->ep_out, dev->rx_req[0]);
+	if (ret < 0) {
+		pr_err("%s dequeue rx error %d\n", __func__, ret);
+		dev->error = 1;
+		r = -EIO;
+		goto end;
+	}
+
+end:
+	dvc_dfx_unlock(&dev->read_excl);
+	dvc_dfx_unlock(&dev->write_excl);
+	return r;
+}
+
+static int dvc_dfx_open(struct inode *ip, struct file *fp)
+{
+	pr_info("%s\n", __func__);
+	if (!_dvc_dfx_dev)
+		return -ENODEV;
+
+	if (dvc_dfx_lock(&_dvc_dfx_dev->open_excl))
+		return -EBUSY;
+
+	fp->private_data = _dvc_dfx_dev;
+
+	/* clear the error latch */
+	_dvc_dfx_dev->error = 0;
+	_dvc_dfx_dev->transfering = 0;
+
+	return 0;
+}
+
+static int dvc_dfx_release(struct inode *ip, struct file *fp)
+{
+	pr_info("%s\n", __func__);
+
+	dvc_dfx_unlock(&_dvc_dfx_dev->open_excl);
+	return 0;
+}
+
+/* file operations for DvC.Dfx device /dev/usb_dvc_dfx */
+static const struct file_operations dvc_dfx_fops = {
+	.owner = THIS_MODULE,
+	.open = dvc_dfx_open,
+	.release = dvc_dfx_release,
+};
+
+static struct miscdevice dvc_dfx_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "usb_dvc_dfx",
+	.fops = &dvc_dfx_fops,
+};
+
+static int dvc_dfx_ctrlrequest(struct usb_composite_dev *cdev,
+				const struct usb_ctrlrequest *ctrl)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+	int	value = -EOPNOTSUPP;
+	u16	w_index = le16_to_cpu(ctrl->wIndex);
+	u16	w_value = le16_to_cpu(ctrl->wValue);
+	u16	w_length = le16_to_cpu(ctrl->wLength);
+
+	pr_debug("%s %02x.%02x v%04x i%04x l%u\n", __func__,
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+
+	switch ((ctrl->bRequestType << 8) | ctrl->bRequest) {
+
+	/* DC_REQUEST_SET_RESET ... stop active transfer */
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+		| DC_REQUEST_SET_RESET:
+		if (w_index != dev->data_id)
+			goto invalid;
+
+		pr_info("%s DC_REQUEST_SET_RESET v%04x i%04x l%u\n", __func__,
+			w_value, w_index, w_length);
+
+		dvc_dfx_disable_transfer();
+		value = 0;
+		break;
+
+	default:
+invalid:
+		pr_debug("unknown class-specific control req "
+			 "%02x.%02x v%04x i%04x l%u\n",
+			 ctrl->bRequestType, ctrl->bRequest,
+			 w_value, w_index, w_length);
+	}
+
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		cdev->req->zero = 0;
+		cdev->req->length = value;
+		value = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+		if (value < 0)
+			pr_err("%s setup response queue error\n", __func__);
+	}
+
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+
+static int
+dvc_dfx_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev	*cdev = c->cdev;
+	struct dvc_dfx_dev		*dev = func_to_dvc_dfx(f);
+	int			id;
+	int			ret;
+
+	dev->cdev = cdev;
+	pr_info("%s dev: %p\n", __func__, dev);
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	dev->data_id = id;
+	dfx_data_interface_desc.bInterfaceNumber = id;
+	dfx_iad_desc.bFirstInterface = id;
+
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	dev->ctrl_id = id;
+	dfx_interface_desc.bInterfaceNumber = id;
+
+	/* allocate endpoints */
+	ret = dfx_create_bulk_endpoints(dev, &dfx_fullspeed_in_desc,
+					&dfx_fullspeed_out_desc,
+					&dfx_superspeed_in_comp_desc,
+					&dfx_superspeed_out_comp_desc
+		);
+	if (ret)
+		return ret;
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		dfx_highspeed_in_desc.bEndpointAddress =
+			dfx_fullspeed_in_desc.bEndpointAddress;
+		dfx_highspeed_out_desc.bEndpointAddress =
+			dfx_fullspeed_out_desc.bEndpointAddress;
+	}
+
+	if (gadget_is_superspeed(c->cdev->gadget)) {
+		dfx_superspeed_in_desc.bEndpointAddress =
+			dfx_fullspeed_in_desc.bEndpointAddress;
+
+		dfx_superspeed_out_desc.bEndpointAddress =
+			dfx_fullspeed_out_desc.bEndpointAddress;
+	}
+
+	pr_info("%s speed %s: IN/%s, OUT/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			f->name, dev->ep_in->name, dev->ep_out->name);
+	return 0;
+}
+
+static void
+dvc_dfx_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct dvc_dfx_dev	*dev = func_to_dvc_dfx(f);
+	struct usb_request *req;
+	int i;
+
+	dev->online = 0;
+	dev->online_ctrl = 0;
+	dev->online_data = 0;
+	dev->transfering = 0;
+	dev->error = 0;
+
+	dfx_string_defs[DVCDFX_CTRL_IDX].id = 0;
+
+	wake_up(&dev->read_wq);
+
+	for (i = 0; i < DFX_RX_REQ_MAX; i++)
+		dvc_dfx_request_free(dev->rx_req[i], dev->ep_out);
+	while ((req = dvc_dfx_req_get(dev, &dev->tx_idle)))
+		dvc_dfx_request_free(req, dev->ep_in);
+
+}
+
+static int dvc_dfx_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct dvc_dfx_dev	*dev = func_to_dvc_dfx(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	pr_info("%s intf: %d alt: %d\n", __func__, intf, alt);
+	if (intf == dfx_data_interface_desc.bInterfaceNumber) {
+		ret = config_ep_by_speed(cdev->gadget, f, dev->ep_in);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_by_speed in error %d\n",
+				__func__, intf, alt, ret);
+			return ret;
+		}
+		ret = usb_ep_enable(dev->ep_in);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_enable in err %d\n",
+				__func__, intf, alt, ret);
+			return ret;
+		}
+
+		ret = config_ep_by_speed(cdev->gadget, f, dev->ep_out);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_enable out error %d\n",
+				__func__, intf, alt, ret);
+			return ret;
+		}
+
+		ret = usb_ep_enable(dev->ep_out);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_enable out err %d\n",
+				__func__, intf, alt, ret);
+			usb_ep_disable(dev->ep_in);
+			return ret;
+		}
+		dev->online_data = 1;
+	}
+	if (intf == dfx_interface_desc.bInterfaceNumber)
+		dev->online_ctrl = 1;
+
+	if (dev->online_data && dev->online_ctrl) {
+		dev->online = 1;
+		dev->error = 0;
+	}
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+	return 0;
+}
+
+static void dvc_dfx_function_disable(struct usb_function *f)
+{
+	struct dvc_dfx_dev	*dev = func_to_dvc_dfx(f);
+	struct usb_composite_dev	*cdev = dev->cdev;
+
+	pr_info("%s cdev %p\n", __func__, cdev);
+
+	if (dev->transfering)
+		dvc_dfx_disable_transfer();
+
+	dev->online = 0;
+	dev->online_ctrl = 0;
+	dev->online_data = 0;
+	dev->error = 0;
+	usb_ep_disable(dev->ep_in);
+	usb_ep_disable(dev->ep_out);
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+
+	pr_debug("%s disabled\n", dev->function.name);
+}
+
+static int dvc_dfx_bind_config(struct usb_configuration *c)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+	int status;
+
+	pr_info("%s\n", __func__);
+
+	if (dfx_string_defs[DVCDFX_CTRL_IDX].id == 0) {
+		status = usb_string_id(c->cdev);
+		if (status < 0)
+			return status;
+		dfx_string_defs[DVCDFX_CTRL_IDX].id = status;
+
+		dfx_interface_desc.iInterface = status;
+
+		status = usb_string_id(c->cdev);
+		if (status < 0)
+			return status;
+		dfx_string_defs[DVCDFX_DATA_IDX].id = status;
+
+		dfx_data_interface_desc.iInterface = status;
+
+		status = usb_string_id(c->cdev);
+		if (status < 0)
+			return status;
+		dfx_string_defs[DVCDFX_IAD_IDX].id = status;
+
+		dfx_iad_desc.iFunction = status;
+	}
+
+	dev->cdev = c->cdev;
+	dev->function.name = "dvcdfx";
+	dev->function.fs_descriptors = fs_dfx_descs;
+	dev->function.hs_descriptors = hs_dfx_descs;
+	dev->function.ss_descriptors = ss_dfx_descs;
+	dev->function.strings = dfx_strings;
+	dev->function.bind = dvc_dfx_function_bind;
+	dev->function.unbind = dvc_dfx_function_unbind;
+	dev->function.set_alt = dvc_dfx_function_set_alt;
+	dev->function.disable = dvc_dfx_function_disable;
+
+	return usb_add_function(c, &dev->function);
+}
+
+static int dvc_dfx_setup(void)
+{
+	struct dvc_dfx_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	spin_lock_init(&dev->lock);
+
+	init_waitqueue_head(&dev->read_wq);
+	init_waitqueue_head(&dev->write_wq);
+
+	INIT_LIST_HEAD(&dev->tx_idle);
+	INIT_LIST_HEAD(&dev->tx_xfer);
+
+	atomic_set(&dev->open_excl, 0);
+	atomic_set(&dev->read_excl, 0);
+	atomic_set(&dev->write_excl, 0);
+
+	_dvc_dfx_dev = dev;
+
+	ret = misc_register(&dvc_dfx_device);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	kfree(dev);
+	pr_err("DvC.Dfx gadget driver failed to initialize\n");
+	return ret;
+}
+
+static void dvc_dfx_cleanup(void)
+{
+	misc_deregister(&dvc_dfx_device);
+
+	kfree(_dvc_dfx_dev);
+	_dvc_dfx_dev = NULL;
+}
diff --git a/drivers/usb/gadget/f_dvc_trace.c b/drivers/usb/gadget/f_dvc_trace.c
new file mode 100644
index 000000000000..4837bf18d931
--- /dev/null
+++ b/drivers/usb/gadget/f_dvc_trace.c
@@ -0,0 +1,887 @@
+/*
+ * Gadget Driver for Android DvC.Trace Debug Capability
+ *
+ * Copyright (C) 2008-2010, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/usb/debug.h>
+#include <linux/sdm.h>
+
+#define TRACE_TX_REQ_MAX 3
+
+#define CONFIG_BOARD_MRFLD_VV
+
+struct dvc_trace_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	spinlock_t lock;
+	u8	ctrl_id, data_id;
+	u8	class_id, subclass_id;
+
+	struct usb_ep *ep_in;
+
+	int online;
+	int online_data;
+	int online_ctrl;
+	int transfering;
+	int error;
+
+	atomic_t write_excl;
+	atomic_t open_excl;
+
+	wait_queue_head_t write_wq;
+
+	struct list_head tx_idle;
+	struct list_head tx_xfer;
+};
+
+static struct usb_interface_assoc_descriptor trace_iad_desc = {
+	.bLength		= sizeof(trace_iad_desc),
+	.bDescriptorType	= USB_DT_INTERFACE_ASSOCIATION,
+	/* .bFirstInterface	= DYNAMIC, */
+	.bInterfaceCount	= 2, /* debug control + data */
+	.bFunctionClass		= USB_CLASS_DEBUG,
+	.bFunctionSubClass	= USB_SUBCLASS_DVC_TRACE,
+	/* .bFunctionProtocol	= 0, */
+	/* .iFunction		= DYNAMIC, */
+};
+
+static struct usb_interface_descriptor trace_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bNumEndpoints          = 0,
+	.bInterfaceClass        = USB_CLASS_DEBUG,
+	.bInterfaceSubClass     = USB_SUBCLASS_DEBUG_CONTROL,
+	/* .bInterfaceProtocol     = 0, */
+};
+
+#define DC_DVCTRACE_ATTRI_LENGTH	DC_DBG_ATTRI_SIZE(2, 32)
+/* 1 input terminal, 1 output terminal and 1 feature unit */
+#define DC_DVCTRACE_TOTAL_LENGTH (DC_DVCTRACE_ATTRI_LENGTH \
+	+ DC_OUTPUT_CONNECTION_SIZE \
+	+ DC_OUTPUT_CONNECTION_SIZE \
+	+ DC_DBG_UNIT_SIZE(STM_NB_IN_PINS, 2, 2, 24))
+
+DECLARE_DC_DEBUG_ATTR_DESCR(DVCT, 2, 32);
+
+static struct DC_DEBUG_ATTR_DESCR(DVCT) trace_debug_attri_desc = {
+	.bLength		= DC_DVCTRACE_ATTRI_LENGTH,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= DC_DEBUG_ATTRIBUTES,
+	.bcdDC			= __constant_cpu_to_le16(0x0100),
+	.wTotalLength	= __constant_cpu_to_le16(DC_DVCTRACE_TOTAL_LENGTH),
+	.bmSupportedFeatures	= 0, /* Debug Event Supported, per SAS */
+	.bControlSize		= 2,
+	.bmControl		= {	/* per SAS */
+		[0]		= 0xFF,
+		[1]		= 0x3F,
+	},
+	.wAuxDataSize		= __constant_cpu_to_le16(0x20),
+	.dInputBufferSize	= __constant_cpu_to_le32(0x00), /* per SAS */
+	.dOutputBufferSize = __constant_cpu_to_le32(TRACE_BULK_BUFFER_SIZE),
+	.qBaseAddress		= 0, /* revision */
+	.hGlobalID		= { /* revision */
+		[0]		= 0,
+		[1]		= 0,
+	}
+};
+
+static struct dc_output_connection_descriptor trace_output_conn_usb_desc = {
+	.bLength		= DC_OUTPUT_CONNECTION_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= DC_OUTPUT_CONNECTION,
+	.bConnectionID		= 0x01, /* USB */
+	.bConnectionType	= DC_CONNECTION_USB,
+	.bAssocConnection	= 0, /* No related input-connection */
+	.wSourceID		= __constant_cpu_to_le16(0x01),
+	/* .iConnection		= DYNAMIC, */
+};
+
+static struct dc_output_connection_descriptor trace_output_conn_pti_desc = {
+	.bLength		= DC_OUTPUT_CONNECTION_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= DC_OUTPUT_CONNECTION,
+	.bConnectionID		= 0, /* PTI */
+	.bConnectionType	= DC_CONNECTION_DEBUG_DATA,
+	.bAssocConnection	= 0, /* No related input-connection */
+	.wSourceID		= __constant_cpu_to_le16(0x01),
+	/* .iConnection		= DYNAMIC, */
+};
+
+#define DC_DVCTRACE_UNIT_LENGTH	DC_DBG_UNIT_SIZE(STM_NB_IN_PINS, 2, 2, 24)
+
+DECLARE_DC_DEBUG_UNIT_DESCRIPTOR(STM_NB_IN_PINS, 2, 2, 24);
+
+static struct DC_DEBUG_UNIT_DESCRIPTOR(STM_NB_IN_PINS, 2, 2, 24)
+		trace_debug_unit_stm_desc = {
+	.bLength		= DC_DVCTRACE_UNIT_LENGTH,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= DC_DEBUG_UNIT,
+	.bUnitID		= 0x01, /* per SAS */
+/* STM Trace Unit processor: revision */
+	.bDebugUnitType		= DC_UNIT_TYPE_TRACE_PROC,
+ /* STM: Trace compressor controller */
+	.bDebugSubUnitType	= DC_UNIT_SUBTYPE_TRACEZIP,
+	.bAliasUnitID		= 0, /* no associated debug unit */
+	.bNrInPins		= STM_NB_IN_PINS, /* p */
+/* wSourceID  contains STM_NB_IN_PINS elements */
+/*	.wSourceID		= {0}, */
+	.bNrOutPins		= 0x02,	/* q */
+	.dTraceFormat		= {
+		[0]	= __constant_cpu_to_le32(DC_TRACE_MIPI_FORMATED_STPV1),
+		[1]	= __constant_cpu_to_le32(DC_TRACE_MIPI_FORMATED_STPV1),
+	},
+	.dStreamID		= __constant_cpu_to_le32(0xFFFFFFFF),
+	.bControlSize		= 0x02,	/* n */
+	.bmControl		= {
+		[0]		= 0xFF,
+		[1]		= 0x3F,
+	},
+	.wAuxDataSize		= __constant_cpu_to_le16(24), /* m */
+	.qBaseAddress		= 0, /* revision */
+	.hIPID			= {
+		[0]		= 0,
+		[1]		= 0,
+	},
+	/* .iDebugUnitType		= DYNAMIC, */
+};
+
+static struct usb_interface_descriptor trace_data_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bAlternateSetting	= 0,
+	.bNumEndpoints          = 1,
+	.bInterfaceClass        = USB_CLASS_DEBUG,
+	.bInterfaceSubClass     = USB_SUBCLASS_DVC_TRACE,
+	/* .bInterfaceProtocol     = 0, */
+};
+
+static struct usb_endpoint_descriptor trace_fullspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor trace_highspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor trace_superspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor trace_superspeed_in_comp_desc = {
+	.bLength		= USB_DT_SS_EP_COMP_SIZE,
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	.bMaxBurst		= 0,
+	.bmAttributes		= 0,
+};
+
+static struct usb_descriptor_header *fs_trace_descs[] = {
+	(struct usb_descriptor_header *) &trace_iad_desc,
+	(struct usb_descriptor_header *) &trace_data_interface_desc,
+	(struct usb_descriptor_header *) &trace_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &trace_interface_desc,
+	(struct usb_descriptor_header *) &trace_debug_attri_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_pti_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_usb_desc,
+	(struct usb_descriptor_header *) &trace_debug_unit_stm_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_trace_descs[] = {
+	(struct usb_descriptor_header *) &trace_iad_desc,
+	(struct usb_descriptor_header *) &trace_data_interface_desc,
+	(struct usb_descriptor_header *) &trace_highspeed_in_desc,
+	(struct usb_descriptor_header *) &trace_interface_desc,
+	(struct usb_descriptor_header *) &trace_debug_attri_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_pti_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_usb_desc,
+	(struct usb_descriptor_header *) &trace_debug_unit_stm_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *ss_trace_descs[] = {
+	(struct usb_descriptor_header *) &trace_iad_desc,
+	(struct usb_descriptor_header *) &trace_data_interface_desc,
+	(struct usb_descriptor_header *) &trace_superspeed_in_desc,
+	(struct usb_descriptor_header *) &trace_superspeed_in_comp_desc,
+	(struct usb_descriptor_header *) &trace_interface_desc,
+	(struct usb_descriptor_header *) &trace_debug_attri_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_pti_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_usb_desc,
+	(struct usb_descriptor_header *) &trace_debug_unit_stm_desc,
+	NULL,
+};
+
+/* string descriptors: */
+#define DVCTRACE_CTRL_IDX	0
+#define DVCTRACE_DATA_IDX	1
+#define DVCTRACE_IAD_IDX	2
+#define DVCTRACE_CONN_PTI_IDX	3
+#define DVCTRACE_CONN_USB_IDX	4
+#define DVCTRACE_UNIT_STM_IDX	5
+
+/* static strings, in UTF-8 */
+static struct usb_string trace_string_defs[] = {
+	[DVCTRACE_CTRL_IDX].s = "Debug Sub-Class DvC.Trace (Control)",
+	[DVCTRACE_DATA_IDX].s = "Debug Sub-Class DvC.Trace (Data)",
+	[DVCTRACE_IAD_IDX].s = "Debug Sub-Class DvC.Trace",
+	[DVCTRACE_CONN_PTI_IDX].s = "MIPI PTIv1 output Connector ",
+	[DVCTRACE_CONN_USB_IDX].s = "USB Device output connector",
+	[DVCTRACE_UNIT_STM_IDX].s = "MIPI STM Debug Unit",
+	{  /* ZEROES END LIST */ },
+};
+
+static struct usb_gadget_strings trace_string_table = {
+	.language =		0x0409,	/* en-us */
+	.strings =		trace_string_defs,
+};
+
+static struct usb_gadget_strings *trace_strings[] = {
+	&trace_string_table,
+	NULL,
+};
+
+/* temporary var used between dvc_trace_open() and dvc_trace_gadget_bind() */
+static struct dvc_trace_dev *_dvc_trace_dev;
+
+static inline struct dvc_trace_dev *func_to_dvc_trace(struct usb_function *f)
+{
+	return container_of(f, struct dvc_trace_dev, function);
+}
+
+static int dvc_trace_is_enabled(void)
+{
+	if (!stm_is_enabled()) {
+		pr_info("%s STM/PTI block is not enabled\n", __func__);
+		return 0;
+	}
+	return 1;
+}
+
+static struct usb_request *dvc_trace_request_new(struct usb_ep *ep,
+					 int buffer_size, dma_addr_t dma)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+	req->dma = dma;
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void dvc_trace_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+/* add a request to the tail of a list */
+static void dvc_trace_req_put(struct dvc_trace_dev *dev, struct list_head *head,
+		struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* remove a request from the head of a list */
+static struct usb_request *dvc_trace_req_get(struct dvc_trace_dev *dev,
+			struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return req;
+}
+
+static void dvc_trace_set_disconnected(struct dvc_trace_dev *dev)
+{
+	dev->transfering = 0;
+}
+
+static void dvc_trace_complete_in(struct usb_ep *ep, struct usb_request *req)
+{
+	struct dvc_trace_dev *dev = _dvc_trace_dev;
+
+	if (req->status != 0)
+		dvc_trace_set_disconnected(dev);
+
+	dvc_trace_req_put(dev, &dev->tx_idle, req);
+
+	wake_up(&dev->write_wq);
+}
+
+static inline int dvc_trace_lock(atomic_t *excl)
+{
+	if (atomic_inc_return(excl) == 1) {
+		return 0;
+	} else {
+		atomic_dec(excl);
+		return -1;
+	}
+}
+
+static inline void dvc_trace_unlock(atomic_t *excl)
+{
+	atomic_dec(excl);
+}
+
+static int trace_create_bulk_endpoints(struct dvc_trace_dev *dev,
+				       struct usb_endpoint_descriptor *in_desc,
+				       struct usb_ss_ep_comp_descriptor *in_comp_desc
+	)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	struct usb_ep *ep;
+	int i;
+
+	pr_debug("%s dev: %p\n", __func__, dev);
+
+	in_desc->bEndpointAddress |= 0x1;
+	ep = usb_ep_autoconfig_ss(cdev->gadget, in_desc, in_comp_desc);
+	if (!ep) {
+		pr_err("%s usb_ep_autoconfig for ep_in failed\n", __func__);
+		return -ENODEV;
+	}
+	pr_debug("%s usb_ep_autoconfig for ep_in got %s\n", __func__, ep->name);
+
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_in = ep;
+
+	for (i = 0; i < TRACE_TX_REQ_MAX; i++) {
+		req = dvc_trace_request_new(dev->ep_in, TRACE_BULK_BUFFER_SIZE,
+			(dma_addr_t)TRACE_BULK_IN_BUFFER_ADDR);
+		if (!req)
+			goto fail;
+		req->complete = dvc_trace_complete_in;
+		dvc_trace_req_put(dev, &dev->tx_idle, req);
+		pr_debug("%s req= %x : for %s predefined TRB\n", __func__,
+			(uint)req, ep->name);
+	}
+
+	return 0;
+
+fail:
+	pr_err("%s could not allocate requests\n", __func__);
+	return -1;
+}
+
+static ssize_t dvc_trace_start_transfer(size_t count)
+{
+	struct dvc_trace_dev *dev = _dvc_trace_dev;
+	struct usb_request *req = 0;
+	int r = count, xfer;
+	int ret;
+
+	pr_debug("%s\n", __func__);
+	if (!_dvc_trace_dev)
+		return -ENODEV;
+
+	if (dvc_trace_lock(&dev->write_excl))
+		return -EBUSY;
+
+	/* we will block until enumeration completes */
+	while (!(dev->online || dev->error)) {
+		pr_debug("%s: waiting for online state\n", __func__);
+		ret = wait_event_interruptible(dev->write_wq,
+				(dev->online || dev->error));
+
+		if (ret < 0) {
+			/* not at CONFIGURED state */
+			pr_info("%s !dev->online already\n", __func__);
+			dvc_trace_unlock(&dev->write_excl);
+			return ret;
+		}
+	}
+
+	/* queue a ep_in endless request */
+	while (r > 0) {
+		if (dev->error) {
+			pr_debug("%s dev->error\n", __func__);
+			r = -EIO;
+			break;
+		}
+
+		if (!dev->online) {
+			pr_debug("%s !dev->online\n", __func__);
+			r = -EIO;
+			break;
+		}
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+				dev->error || !dev->online ||
+				(req = dvc_trace_req_get(dev, &dev->tx_idle)));
+
+		if (ret < 0) {
+			r = ret;
+			break;
+		}
+
+		if (req != 0) {
+			if (count > TRACE_BULK_BUFFER_SIZE)
+				xfer = TRACE_BULK_BUFFER_SIZE;
+			else
+				xfer = count;
+			pr_debug("%s queue tx_idle list req to dev->ep_in\n",
+				__func__);
+			req->no_interrupt = 1;
+			req->context = &dev->function;
+			req->length = xfer;
+			ret = usb_ep_queue(dev->ep_in, req, GFP_ATOMIC);
+			if (ret < 0) {
+				pr_err("%s: xfer error %d\n", __func__, ret);
+				dev->error = 1;
+				dev->transfering = 0;
+				r = -EIO;
+				break;
+			}
+			pr_debug("%s: xfer=%d/%d  queued req/%x\n", __func__,
+				xfer, r, (uint)req);
+			dvc_trace_req_put(dev, &dev->tx_xfer, req);
+			r -= xfer;
+
+			/* zero this so we don't try to free it on error exit */
+			req = 0;
+		}
+	}
+	if (req) {
+		pr_debug("%s req re-added to tx_idle on error\n", __func__);
+		dvc_trace_req_put(dev, &dev->tx_idle, req);
+	} else {
+		dev->transfering = 1;
+	}
+	dvc_trace_unlock(&dev->write_excl);
+	pr_debug("%s end\n", __func__);
+	return ret;
+}
+
+static int dvc_trace_disable_transfer(void)
+{
+	struct dvc_trace_dev *dev = _dvc_trace_dev;
+	struct usb_request *req = 0;
+	int ret;
+
+	pr_debug("%s\n", __func__);
+	if (!_dvc_trace_dev)
+		return -ENODEV;
+
+	if (dvc_trace_lock(&dev->write_excl))
+		return -EBUSY;
+
+	if (dev->error) {
+		pr_debug("%s dev->error\n", __func__);
+		dvc_trace_unlock(&dev->write_excl);
+		return -EIO;
+	}
+
+	if ((!dev->online) || (!dev->transfering)) {
+		pr_debug("%s !dev->online OR !dev->transfering\n", __func__);
+		dvc_trace_unlock(&dev->write_excl);
+		return -EIO;
+	}
+
+	/* get an xfer tx request to use */
+	while ((req = dvc_trace_req_get(dev, &dev->tx_xfer))) {
+		ret = usb_ep_dequeue(dev->ep_in, req);
+		if (ret < 0) {
+			pr_err("%s: dequeue error %d\n", __func__, ret);
+			dev->error = 1;
+			dvc_trace_unlock(&dev->write_excl);
+			return -EIO;
+		}
+		pr_debug("%s: dequeued req/%x\n", __func__, (uint)req);
+	}
+
+	dvc_trace_unlock(&dev->write_excl);
+	return 1;
+}
+
+static int dvc_trace_open(struct inode *ip, struct file *fp)
+{
+	pr_debug("%s\n", __func__);
+	if (!_dvc_trace_dev)
+		return -ENODEV;
+
+	if (dvc_trace_lock(&_dvc_trace_dev->open_excl))
+		return -EBUSY;
+
+	fp->private_data = _dvc_trace_dev;
+
+	/* clear the error latch */
+	_dvc_trace_dev->error = 0;
+	_dvc_trace_dev->transfering = 0;
+
+	return 0;
+}
+
+static int dvc_trace_release(struct inode *ip, struct file *fp)
+{
+	pr_debug("%s\n", __func__);
+
+	dvc_trace_unlock(&_dvc_trace_dev->open_excl);
+	return 0;
+}
+
+/* file operations for DvC.Trace device /dev/usb_dvc_trace */
+static const struct file_operations dvc_trace_fops = {
+	.owner = THIS_MODULE,
+	.open = dvc_trace_open,
+	.release = dvc_trace_release,
+};
+
+static struct miscdevice dvc_trace_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "usb_dvc_trace",
+	.fops = &dvc_trace_fops,
+};
+
+static int dvc_trace_ctrlrequest(struct usb_composite_dev *cdev,
+				const struct usb_ctrlrequest *ctrl)
+{
+
+	struct dvc_trace_dev *dev = _dvc_trace_dev;
+	int	value = -EOPNOTSUPP;
+	int	ret;
+	u16	w_index = le16_to_cpu(ctrl->wIndex);
+	u16	w_value = le16_to_cpu(ctrl->wValue);
+	u16	w_length = le16_to_cpu(ctrl->wLength);
+
+	pr_debug("%s %02x.%02x v%04x i%04x l%u\n", __func__,
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+
+	switch ((ctrl->bRequestType << 8) | ctrl->bRequest) {
+
+	/* DC_REQUEST_SET_RESET ... stop active transfer */
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+		| DC_REQUEST_SET_RESET:
+		if (w_index != dev->data_id)
+			goto invalid;
+
+		pr_info("%s DC_REQUEST_SET_RESET v%04x i%04x l%u\n", __func__,
+			 w_value, w_index, w_length);
+
+		dvc_trace_disable_transfer();
+		value = 0;
+		break;
+
+	/* DC_REQUEST_SET_TRACE ... start trace transfer */
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+		| DC_REQUEST_SET_TRACE:
+
+		pr_info("%s DC_REQUEST_SET_TRACE v%04x i%04x l%u\n", __func__,
+			 w_value, w_index, w_length);
+
+		if (!w_index)
+			ret = dvc_trace_disable_transfer();
+		else
+			ret = dvc_trace_start_transfer(4096);
+
+		if (ret < 0)
+			value = -EINVAL;
+		else
+			value = (int) w_index;
+		break;
+
+	default:
+invalid:
+		pr_debug("unknown class-specific control req "
+			 "%02x.%02x v%04x i%04x l%u\n",
+			 ctrl->bRequestType, ctrl->bRequest,
+			 w_value, w_index, w_length);
+	}
+
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		cdev->req->zero = 0;
+		cdev->req->length = value;
+		value = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+		if (value < 0)
+			pr_err("%s setup response queue error\n", __func__);
+	}
+
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+
+static int
+dvc_trace_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev	*cdev = c->cdev;
+	struct dvc_trace_dev		*dev = func_to_dvc_trace(f);
+	int			id;
+	int			ret;
+	int status;
+
+	dev->cdev = cdev;
+	pr_debug("%s dev: %p\n", __func__, dev);
+
+	/* maybe allocate device-global string IDs, and patch descriptors */
+	if (trace_string_defs[DVCTRACE_CTRL_IDX].id == 0) {
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_DATA_IDX].id = status;
+		trace_data_interface_desc.iInterface = status;
+
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_CTRL_IDX].id = status;
+		trace_interface_desc.iInterface = status;
+
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_IAD_IDX].id = status;
+		trace_iad_desc.iFunction = status;
+
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_CONN_PTI_IDX].id = status;
+		trace_output_conn_pti_desc.iConnection = status;
+
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_CONN_USB_IDX].id = status;
+		trace_output_conn_usb_desc.iConnection = status;
+
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_UNIT_STM_IDX].id = status;
+		trace_debug_unit_stm_desc.iDebugUnitType = status;
+	}
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	dev->data_id = id;
+	trace_data_interface_desc.bInterfaceNumber = id;
+	trace_iad_desc.bFirstInterface = id;
+
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	dev->ctrl_id = id;
+	trace_interface_desc.bInterfaceNumber = id;
+
+	/* allocate endpoints */
+	ret = trace_create_bulk_endpoints(dev, &trace_fullspeed_in_desc,
+					  &trace_superspeed_in_comp_desc);
+	if (ret)
+		return ret;
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		trace_highspeed_in_desc.bEndpointAddress =
+			trace_fullspeed_in_desc.bEndpointAddress;
+	}
+
+	if (gadget_is_superspeed(c->cdev->gadget)) {
+		trace_superspeed_in_desc.bEndpointAddress =
+			trace_fullspeed_in_desc.bEndpointAddress;
+	}
+
+	pr_debug("%s speed %s: IN/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			f->name, dev->ep_in->name);
+	return 0;
+}
+
+static void
+dvc_trace_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct dvc_trace_dev	*dev = func_to_dvc_trace(f);
+	struct usb_request *req;
+
+	dev->online = 0;
+	dev->online_data = 0;
+	dev->online_ctrl = 0;
+	dev->error = 0;
+	trace_string_defs[DVCTRACE_CTRL_IDX].id = 0;
+
+	wake_up(&dev->write_wq);
+
+	while ((req = dvc_trace_req_get(dev, &dev->tx_idle)))
+		dvc_trace_request_free(req, dev->ep_in);
+}
+
+static int dvc_trace_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct dvc_trace_dev	*dev = func_to_dvc_trace(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	pr_debug("%s intf: %d alt: %d\n", __func__, intf, alt);
+
+	if (intf == trace_interface_desc.bInterfaceNumber)
+		dev->online_ctrl = 1;
+
+	if (intf == trace_data_interface_desc.bInterfaceNumber) {
+		ret = config_ep_by_speed(cdev->gadget, f, dev->ep_in);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_by_speed in err %d\n",
+				__func__, intf, alt, ret);
+			return ret;
+		}
+
+		ret = usb_ep_enable(dev->ep_in);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_enable in err %d\n",
+				__func__, intf, alt, ret);
+			return ret;
+		}
+		dev->online_data = 1;
+	}
+
+	if (dev->online_data && dev->online_ctrl) {
+		dev->online = 1;
+		dev->transfering = 0;
+	}
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->write_wq);
+	return 0;
+}
+
+static void dvc_trace_function_disable(struct usb_function *f)
+{
+	struct dvc_trace_dev	*dev = func_to_dvc_trace(f);
+	struct usb_composite_dev	*cdev = dev->cdev;
+
+	pr_debug("%s dev %p\n", __func__, cdev);
+
+	if (dev->transfering)
+		dvc_trace_disable_transfer();
+
+	dev->online = 0;
+	dev->online_data = 0;
+	dev->online_ctrl = 0;
+	dev->error = 0;
+	usb_ep_disable(dev->ep_in);
+
+	/* writer may be blocked waiting for us to go online */
+	wake_up(&dev->write_wq);
+
+	pr_debug("%s : %s disabled\n", __func__, dev->function.name);
+}
+
+static int dvc_trace_bind_config(struct usb_configuration *c)
+{
+	struct dvc_trace_dev *dev = _dvc_trace_dev;
+
+	pr_debug("%s\n", __func__);
+
+	dev->cdev = c->cdev;
+	dev->function.name = "dvctrace";
+	dev->function.strings = trace_strings;
+	dev->function.fs_descriptors = fs_trace_descs;
+	dev->function.hs_descriptors = hs_trace_descs;
+	dev->function.ss_descriptors = ss_trace_descs;
+	dev->function.bind = dvc_trace_function_bind;
+	dev->function.unbind = dvc_trace_function_unbind;
+	dev->function.set_alt = dvc_trace_function_set_alt;
+	dev->function.disable = dvc_trace_function_disable;
+
+	return usb_add_function(c, &dev->function);
+}
+
+static int dvc_trace_setup(void)
+{
+	struct dvc_trace_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	spin_lock_init(&dev->lock);
+
+	INIT_LIST_HEAD(&dev->tx_idle);
+	INIT_LIST_HEAD(&dev->tx_xfer);
+
+	init_waitqueue_head(&dev->write_wq);
+
+	atomic_set(&dev->open_excl, 0);
+	atomic_set(&dev->write_excl, 0);
+
+	_dvc_trace_dev = dev;
+
+	ret = misc_register(&dvc_trace_device);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	kfree(dev);
+	pr_err("DvC.Trace gadget driver failed to initialize\n");
+	return ret;
+}
+
+static void dvc_trace_cleanup(void)
+{
+	misc_deregister(&dvc_trace_device);
+
+	kfree(_dvc_trace_dev);
+	_dvc_trace_dev = NULL;
+}
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index bcd04bc66b98..a3b44f23df58 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -16,6 +16,7 @@
 #define __GADGET_CHIPS_H
 
 #include <linux/usb/gadget.h>
+#include <asm/intel-mid.h>
 
 /*
  * NOTICE: the entries below are alphabetical and should be kept
@@ -29,11 +30,13 @@
  */
 #define gadget_is_at91(g)		(!strcmp("at91_udc", (g)->name))
 #define gadget_is_goku(g)		(!strcmp("goku_udc", (g)->name))
+#define gadget_is_middwc3tng(g)		((!strcmp("dwc3-gadget", (g)->name)) && \
+					 (intel_mid_identify_cpu() ==	\
+					  INTEL_MID_CPU_CHIP_TANGIER))
 #define gadget_is_musbhdrc(g)		(!strcmp("musb-hdrc", (g)->name))
 #define gadget_is_net2280(g)		(!strcmp("net2280", (g)->name))
 #define gadget_is_pxa(g)		(!strcmp("pxa25x_udc", (g)->name))
 #define gadget_is_pxa27x(g)		(!strcmp("pxa27x_udc", (g)->name))
-
 /**
  * gadget_supports_altsettings - return true if altsettings work
  * @gadget: the gadget in question
diff --git a/include/linux/usb/debug.h b/include/linux/usb/debug.h
new file mode 100644
index 000000000000..2a08e362d44b
--- /dev/null
+++ b/include/linux/usb/debug.h
@@ -0,0 +1,253 @@
+/*
+ * <linux/usb/debug.h> -- USB Debug Class definitions.
+ *
+ * Copyright (C) 2008-2010, Intel Corporation.
+ *
+ * This software is distributed under the terms of the GNU General Public
+ * License ("GPL") version 2, as published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __LINUX_USB_DEBUG_H
+#define __LINUX_USB_DEBUG_H
+
+#include <linux/types.h>
+
+/* Debug Interface Subclass Codes */
+#define USB_SUBCLASS_DVC_GP		0x05
+#define USB_SUBCLASS_DVC_DFX		0x06
+#define USB_SUBCLASS_DVC_TRACE		0x07
+#define USB_SUBCLASS_DEBUG_CONTROL	0x08
+
+/* Debug Interface Function Protocol */
+#define DC_PROTOCOL_VENDOR			0x00
+#define DC_PROTOCOL_LAUTERBACH			0x01
+#define DC_PROTOCOL_ITP			0x02
+
+/* Debug Class-Specific Interface Descriptor Subtypes */
+#define DC_UNDEFINED			0x00
+#define DC_INPUT_CONNECTION		0x01
+#define DC_OUTPUT_CONNECTION		0x02
+#define DC_DEBUG_UNIT			0x03
+#define DC_DEBUG_ATTRIBUTES		0x04 /* revision: per SAS */
+
+/* Debug-Class Input/Output Connection Type */
+#define DC_CONNECTION_USB			0x00
+#define DC_CONNECTION_JTAG			0x01
+#define DC_CONNECTION_DEBUG_DATA_CONTROL	0x02
+#define DC_CONNECTION_DEBUG_DATA		0x03
+#define DC_CONNECTION_DEBUG_CONTROL		0x04
+
+/*
+ * Debug-class (rev 0.88r2) section 4.4.3
+ * Attibute  Descriptor, bmControl
+ */
+#define DC_CTL_SET_CFG_DATA_SG			(1 << 0)
+#define DC_CTL_SET_CFG_DATA			(1 << 1)
+#define DC_CTL_GET_CFG_DATA			(1 << 2)
+#define DC_CTL_SET_CFG_ADDR			(1 << 3)
+#define DC_CTL_GET_CFG_ADDR			(1 << 4)
+#define DC_CTL_SET_ALT_STACK			(1 << 5)
+#define DC_CTL_GET_ALT_STACK			(1 << 6)
+#define DC_CTL_SET_OP_MODE			(1 << 7)
+#define DC_CTL_GET_OP_MODE			(1 << 8)
+#define DC_CTL_SET_TRACE_CFG			(1 << 9)
+#define DC_CTL_GET_TRACE_CFG			(1 << 10)
+#define DC_CTL_SET_BUFF_INFO			(1 << 11)
+#define DC_CTL_GET_BUFF_INFO			(1 << 12)
+#define DC_CTL_SET_RESET			(1 << 13)
+
+/* Debug-class (rev 0.88r2) section 4.4.6
+ * Unit/Input/Output connection Descriptors,
+ * dTraceFormat
+ */
+#define DC_TRACE_NOT_FORMATED_PASSTHROUGH   0x00000000
+#define DC_TRACE_NOT_FORMATED_HEADER        0x00000001
+#define DC_TRACE_NOT_FORMATED_FOOTER        0x00000002
+#define DC_TRACE_NOT_FORMATED_GUID          0x00000005
+#define DC_TRACE_NOT_FORMATED_UTF8          0x00000006
+#define DC_TRACE_INTEL_FORMATED_VENDOR      0x01000000
+#define DC_TRACE_MIPI_FORMATED_STPV1        0x80000000
+#define DC_TRACE_MIPI_FORMATED_STPV2        0x80000001
+#define DC_TRACE_MIPI_FORMATED_TWP          0x80000100
+#define DC_TRACE_MIPI_FORMATED_OST          0x80001000
+#define DC_TRACE_NEXUS_FORMATED             0x81000000
+
+/* Debug-class (rev 0.88r2) section 4.4.6
+ * Unit connection Descriptors, dDebugUnitType
+ */
+#define DC_UNIT_TYPE_DFX		0x00
+#define DC_UNIT_TYPE_SELECT		0x01
+#define DC_UNIT_TYPE_TRACE_ROUTE	0x02
+#define DC_UNIT_TYPE_TRACE_PROC	0x03
+#define DC_UNIT_TYPE_TRACE_GEN		0x04
+#define DC_UNIT_TYPE_TRACE_SINK	0x05
+#define DC_UNIT_TYPE_CONTROL		0x06
+#define DC_UNIT_TYPE_VENDOR		0x40
+
+/* Debug-class (rev 0.88r2) section 4.4.6
+ * Unit connection Descriptors, dDebugUnitSubType
+ */
+#define DC_UNIT_SUBTYPE_NO              0x00
+#define DC_UNIT_SUBTYPE_CPU             0x01
+#define DC_UNIT_SUBTYPE_GFX             0x02
+#define DC_UNIT_SUBTYPE_VIDEO		0x03
+#define DC_UNIT_SUBTYPE_IMAGING	0x04
+#define DC_UNIT_SUBTYPE_AUDIO		0x05
+#define DC_UNIT_SUBTYPE_MODEM		0x06
+#define DC_UNIT_SUBTYPE_BLUETOOTH	0x07
+#define DC_UNIT_SUBTYPE_PWR_MGT	0x08
+#define DC_UNIT_SUBTYPE_SECURITY	0x09
+#define DC_UNIT_SUBTYPE_SENSOR		0x0A
+#define DC_UNIT_SUBTYPE_BUSWATCH	0x0B
+#define DC_UNIT_SUBTYPE_GPS		0x0C
+#define DC_UNIT_SUBTYPE_TRACEZIP	0x0D
+#define DC_UNIT_SUBTYPE_TAPCTL		0x0E
+#define DC_UNIT_SUBTYPE_MEMACC		0x0F
+#define DC_UNIT_SUBTYPE_SWLOGGER	0x40
+#define DC_UNIT_SUBTYPE_SWROUTER	0x41
+#define DC_UNIT_SUBTYPE_SWDRIVER	0x42
+#define DC_UNIT_SUBTYPE_VENDOR		0x80
+
+/* USB DBG requests values */
+#define DC_REQUEST_SET_CONFIG_DATA		0x01
+#define DC_REQUEST_SET_CONFIG_DATA_SINGLE	0x02
+#define DC_REQUEST_SET_CONFIG_ADDRESS		0x03
+#define DC_REQUEST_SET_ALT_STACK		0x04
+#define DC_REQUEST_SET_OPERATING		0x05
+#define DC_REQUEST_SET_TRACE			0x08
+#define DC_REQUEST_SET_BUFFER_INFO		0x09
+#define DC_REQUEST_SET_RESET			0x0A
+#define DC_REQUEST_GET_CONFIG_DATA		0x81
+#define DC_REQUEST_GET_CONFIG_DATA_SINGLE	0x82
+#define DC_REQUEST_GET_CONFIG_ADDRESS		0x83
+#define DC_REQUEST_GET_ALT_STACK		0x84
+#define DC_REQUEST_GET_OPERATING		0x85
+#define DC_REQUEST_GET_TRACE			0x86
+#define DC_REQUEST_GET_INFO			0x87
+#define DC_REQUEST_GET_ERROR			0x88
+#define DC_REQUEST_GET_BUFFER_INFO		0x89
+
+/* Debug-Class Debug-Attributes Descriptor */
+struct dc_debug_attributes_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__le16 bcdDC;
+	__le16 wTotalLength;
+	__u8  bmSupportedFeatures;
+	__u8  bControlSize;		/* n */
+	__u8  bmControl[0];		/* [n] */
+	__le16 wAuxDataSize;		/* m */
+	__le32 dInputBufferSize;
+	__le32 dOutputBufferSize;
+	__le64 qBaseAddress;
+	__le64 hGlobalID[2];
+	__u8  Supplementary[0];		/* [m-32] */
+} __attribute__((__packed__));
+
+#define DC_DEBUG_ATTR_DESCR(name)		 \
+	dc_debug_attributes_descriptor_##name
+
+#define DECLARE_DC_DEBUG_ATTR_DESCR(name, n, m)	\
+struct DC_DEBUG_ATTR_DESCR(name) {		\
+	__u8  bLength;					\
+	__u8  bDescriptorType;				\
+	__u8  bDescriptorSubtype;			\
+	__le16 bcdDC;					\
+	__le16 wTotalLength;				\
+	__u8  bmSupportedFeatures;			\
+	__u8  bControlSize;				\
+	__u8  bmControl[n];				\
+	__le16 wAuxDataSize;				\
+	__le32 dInputBufferSize;			\
+	__le32 dOutputBufferSize;			\
+	__le64 qBaseAddress;				\
+	__le64 hGlobalID[2];				\
+	__u8  Supplementary[m-32];			\
+} __attribute__((__packed__));
+
+#define DC_DBG_ATTRI_SIZE(n, m)		(9 + (n) + 2 + (m))
+
+/* Debug-Class Input Connection Descriptor */
+struct dc_input_connection_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__u8  bConnectionID;
+	__u8  bConnectionType;
+	__u8  bAssocConnection;
+	__u8  iConnection;
+	__le32 dTraceFormat;
+	__le32 dStreamID;
+} __attribute__((__packed__));
+
+#define DC_INPUT_CONNECTION_SIZE	15
+
+/* Debug-Class Output Connection Descriptor */
+struct dc_output_connection_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__u8  bConnectionID;
+	__u8  bConnectionType;
+	__u8  bAssocConnection;
+	__le16 wSourceID;
+	__u8  iConnection;
+} __attribute__((__packed__));
+
+#define DC_OUTPUT_CONNECTION_SIZE	9
+
+/* Debug-Class Debug-Unit Descriptor */
+struct dc_debug_unit_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__u8  bUnitID;
+	__u8  bDebugUnitType;
+	__u8  bDebugSubUnitType;
+	__u8  bAliasUnitID;
+	__u8  bNrInPins;		/* p */
+	__le16 wSourceID[0];		/* [p] */
+	__u8  bNrOutPins;		/* q */
+	__le32 dTraceFormat[0];		/* [q] */
+	__le32 dStreamID;
+	__u8  bControlSize;		/* n */
+	__u8  bmControl[0];		/* [n] */
+	__le16 wAuxDataSize;		/* m */
+	__le64 qBaseAddress;
+	__le64 hIPID[2];
+	__u8  Supplementary[0];		/* [m-24] */
+	__u8  iDebugUnitType;
+} __attribute__((__packed__));
+
+#define DC_DEBUG_UNIT_DESCRIPTOR(p, q, n, m)		\
+	dc_debug_unit_descriptor_##p_##q##n_##m
+
+#define DECLARE_DC_DEBUG_UNIT_DESCRIPTOR(p, q, n, m)	\
+struct DC_DEBUG_UNIT_DESCRIPTOR(p, q, n, m) {		\
+	__u8  bLength;					\
+	__u8  bDescriptorType;				\
+	__u8  bDescriptorSubtype;			\
+	__u8  bUnitID;					\
+	__u8  bDebugUnitType;				\
+	__u8  bDebugSubUnitType;			\
+	__u8  bAliasUnitID;				\
+	__u8  bNrInPins;				\
+	__le16 wSourceID[p];				\
+	__u8  bNrOutPins;				\
+	__le32 dTraceFormat[q];			\
+	__le32 dStreamID;				\
+	__u8  bControlSize;				\
+	__u8  bmControl[n];				\
+	__le16 wAuxDataSize;				\
+	__le64 qBaseAddress;				\
+	__le64 hIPID[2];				\
+	__u8  Supplementary[m-24];			\
+	__u8  iDebugUnitType;				\
+} __attribute__((__packed__));
+
+#define DC_DBG_UNIT_SIZE(p, q, n, m)	\
+(8 + (p * 2) + 1 + (q * 4) + 5 + (n) + 2 + (m) + 1)
+
+#endif /* __LINUX_USB_DEBUG_H */
diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.h
index aa33fd1b2d4f..29860d6e883b 100644
--- a/include/uapi/linux/usb/ch9.h
+++ b/include/uapi/linux/usb/ch9.h
@@ -294,6 +294,7 @@ struct usb_device_descriptor {
 #define USB_CLASS_CSCID			0x0b	/* chip+ smart card */
 #define USB_CLASS_CONTENT_SEC		0x0d	/* content security */
 #define USB_CLASS_VIDEO			0x0e
+#define USB_CLASS_DEBUG			0xdc
 #define USB_CLASS_WIRELESS_CONTROLLER	0xe0
 #define USB_CLASS_MISC			0xef
 #define USB_CLASS_APP_SPEC		0xfe
-- 
2.37.3

