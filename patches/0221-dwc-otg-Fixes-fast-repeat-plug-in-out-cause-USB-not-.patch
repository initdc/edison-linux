From c6c97c7e9f8004d4913bcef05ed3bbe24751b19a Mon Sep 17 00:00:00 2001
From: "Wang, Yu" <yu.y.wang@intel.com>
Date: Thu, 15 Aug 2013 15:11:50 +0800
Subject: [PATCH 221/429] dwc-otg: Fixes fast repeat plug in/out cause USB not
 work issue.

If user plug in/out cable fast, then cause USB can't enumerate success
at the last time. The root cause is OTG driver lost some events sent
from EM driver.

Signed-off-by: Wang, Yu <yu.y.wang@intel.com>
---
 drivers/usb/dwc3/otg.c | 56 ++++++++++++++----------------------------
 1 file changed, 19 insertions(+), 37 deletions(-)

diff --git a/drivers/usb/dwc3/otg.c b/drivers/usb/dwc3/otg.c
index 7dd2bbff3ab1..d76f478e321f 100644
--- a/drivers/usb/dwc3/otg.c
+++ b/drivers/usb/dwc3/otg.c
@@ -100,23 +100,9 @@ static int sleep_main_thread(struct dwc_otg2 *otg)
 	return rc;
 }
 
-static void get_events(struct dwc_otg2 *otg,
-		u32 *otg_events,
-		u32 *user_events)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&otg->lock, flags);
-
-	if (otg_events)
-		*otg_events = otg->otg_events;
-
-	if (user_events)
-		*user_events = otg->user_events;
-	spin_unlock_irqrestore(&otg->lock, flags);
-}
-
 static void get_and_clear_events(struct dwc_otg2 *otg,
+				u32 otg_mask,
+				u32 user_mask,
 				u32 *otg_events,
 				u32 *user_events)
 {
@@ -124,33 +110,34 @@ static void get_and_clear_events(struct dwc_otg2 *otg,
 
 	spin_lock_irqsave(&otg->lock, flags);
 
-	if (otg_events)
+	if (otg_events && (otg->otg_events & otg_mask)) {
 		*otg_events = otg->otg_events;
+		otg->otg_events &= ~otg_mask;
+	}
 
-	if (user_events)
+	if (user_events && (otg->user_events & user_mask)) {
 		*user_events = otg->user_events;
-
-	otg->otg_events = 0;
-	otg->user_events = 0;
+		otg->user_events &= ~user_mask;
+	}
 
 	spin_unlock_irqrestore(&otg->lock, flags);
 }
 
 static int check_event(struct dwc_otg2 *otg,
 		u32 otg_mask,
-		u32 user_mask)
+		u32 user_mask,
+		u32 *otg_events,
+		u32 *user_events)
 {
-	u32 otg_events = 0;
-	u32 user_events = 0;
-
-	get_events(otg, &otg_events, &user_events);
-	if ((otg_events & otg_mask) ||
-			(user_events & user_mask)) {
+	get_and_clear_events(otg, otg_mask, user_mask,
+			otg_events, user_events);
+	if ((*otg_events & otg_mask) ||
+			(*user_events & user_mask)) {
 		otg_dbg(otg, "Event occurred:");
 		otg_dbg(otg, "otg_events=%x, otg_mask=%x,",
-				otg_events, otg_mask);
+				*otg_events, otg_mask);
 		otg_dbg(otg, "user_events=%x, user_mask=%x",
-				user_events, user_mask);
+				*user_events, user_mask);
 		return 1;
 	}
 
@@ -170,12 +157,12 @@ static int sleep_until_event(struct dwc_otg2 *otg,
 		otg_dbg(otg, "Waiting for event (timeout=%d)...\n", timeout);
 		rc = sleep_main_thread_until_condition_timeout(otg,
 				check_event(otg, otg_mask,
-				user_mask), timeout);
+				user_mask, otg_events, user_events), timeout);
 	} else {
 		otg_dbg(otg, "Waiting for event (no timeout)...\n");
 		rc = sleep_main_thread_until_condition(otg,
 				check_event(otg, otg_mask,
-					user_mask));
+					user_mask, otg_events, user_events));
 	}
 	pm_runtime_get_sync(otg->dev);
 
@@ -184,12 +171,7 @@ static int sleep_until_event(struct dwc_otg2 *otg,
 	otg_write(otg, ADPEVTEN, 0);
 
 	otg_dbg(otg, "Woke up rc=%d\n", rc);
-	if (rc < 0)
-		goto done;
-	else
-		get_and_clear_events(otg, otg_events, user_events);
 
-done:
 	return rc;
 }
 
-- 
2.37.3

