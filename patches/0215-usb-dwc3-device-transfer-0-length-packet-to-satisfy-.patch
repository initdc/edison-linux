From a4b5ff0733e6249d134f1e7ce4add3b25ac9d1d3 Mon Sep 17 00:00:00 2001
From: Jiebing Li <jiebing.li@intel.com>
Date: Fri, 30 Aug 2013 17:04:30 +0800
Subject: [PATCH 215/429] usb/dwc3-device: transfer 0-length packet to satisfy
 host request

The current driver may have some issue if the control transfer
length of the data stage is multiple of max packet size.

This patch provides a fix by issuing another Start Transfer in
case that host is trying to move an extra 0-length packet.

Signed-off-by: Jiebing Li <jiebing.li@intel.com>
Signed-off-by: Wang, Yu <yu.y.wang@intel.com>
---
 drivers/usb/dwc3/ep0.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c
index 308daa53dfaa..89999583b4c8 100644
--- a/drivers/usb/dwc3/ep0.c
+++ b/drivers/usb/dwc3/ep0.c
@@ -791,6 +791,9 @@ static void dwc3_ep0_complete_data(struct dwc3 *dwc,
 
 	dwc->ep0_next_event = DWC3_EP0_NRDY_STATUS;
 
+	if (list_empty(&ep0->request_list))
+		return;
+
 	r = next_request(&ep0->request_list);
 	ur = &r->request;
 
@@ -1039,6 +1042,25 @@ static void dwc3_ep0_xfernotready(struct dwc3 *dwc,
 			return;
 		}
 
+		/*
+		 * Per databook, if an XferNotready(Data) is received after
+		 * XferComplete(Data), one possible reason is host is trying
+		 * to complete data stage by moving a 0-length packet.
+		 *
+		 * REVISIT in case of other cases
+		 */
+		if (dwc->ep0_next_event == DWC3_EP0_NRDY_STATUS) {
+			u32		size = 0;
+			struct dwc3_ep *dep = dwc->eps[event->endpoint_number];
+
+			if (dep->number == 0)
+				size = dep->endpoint.maxpacket;
+
+			dwc3_ep0_start_trans(dwc, dep->number,
+				dwc->ctrl_req_addr, size,
+				DWC3_TRBCTL_CONTROL_DATA);
+		}
+
 		break;
 
 	case DEPEVT_STATUS_CONTROL_STATUS:
-- 
2.37.3

