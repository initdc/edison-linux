From 4eb66ba41a6e91e0d7ad62413a1ad2329f4d8bc5 Mon Sep 17 00:00:00 2001
From: Jiebing Li <jiebing.li@intel.com>
Date: Wed, 21 Aug 2013 10:35:15 +0800
Subject: [PATCH 178/429] usb/dwc3-device: add new file to support OTG

A glue layer is added to support OTG structure for device mode.

Signed-off-by: Jiebing Li <jiebing.li@intel.com>
Signed-off-by: Wang, Yu <yu.y.wang@intel.com>
Signed-off-by: Eric Ernst <eric.ernst@intel.com>
---
 drivers/usb/dwc3/Kconfig             |   15 +
 drivers/usb/dwc3/Makefile            |    1 +
 drivers/usb/dwc3/core.h              |    8 +
 drivers/usb/dwc3/dwc3-device-intel.c |  423 +++++++++-
 drivers/usb/dwc3/dwc3-host-intel.c   |  116 ++-
 drivers/usb/dwc3/dwc3-intel-mrfl.c   |  646 +++++++++++++--
 drivers/usb/dwc3/dwc3-pci.c          |    4 +
 drivers/usb/dwc3/gadget.c            | 1090 +++++++++++++++++++++++---
 8 files changed, 2081 insertions(+), 222 deletions(-)

diff --git a/drivers/usb/dwc3/Kconfig b/drivers/usb/dwc3/Kconfig
index d087502d430a..7aaa51fdd778 100644
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@ -40,6 +40,19 @@ config USB_DWC3_DUAL_ROLE
 
 endchoice
 
+comment "Platform Glue Driver Support"
+
+config USB_DWC3_PCI
+	tristate "PCIe-based Platforms"
+	depends on PCI
+	default USB_DWC3
+	help
+	  If you're using the DesignWare Core IP with a PCIe, please say
+	  'Y' or 'M' here.
+
+	  One such PCIe-based platform is Synopsys' PCIe HAPS model of
+	  this IP.
+
 config USB_DWC3_OTG
 	tristate "DWC3 OTG mode support"
 	depends on USB && PCI
@@ -91,6 +104,8 @@ config USB_DWC3_HOST_INTEL
 	  use different design with standard USB_DWC3_HOST. So if you want to
 	  enable host mode on Intel platform, then you have to enable this config.
 
+comment "Debugging features"
+
 config USB_DWC3_DEBUG
 	bool "Enable Debugging Messages"
 	help
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index fdb449f5963a..36a070136ee2 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -23,6 +23,7 @@ endif
 ifneq ($(CONFIG_DEBUG_FS),)
 	dwc3-y				+= debugfs.o
 endif
+endif
 
 ##
 # Platform-specific glue layers go here
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 7ab3c9985253..d6654069f33f 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -495,6 +495,12 @@ enum dwc3_link_state {
 	DWC3_LINK_STATE_MASK		= 0x0f,
 };
 
+enum dwc3_pm_state {
+	PM_DISCONNECTED = 0,
+	PM_ACTIVE,
+	PM_SUSPENDED,
+};
+
 /* TRB Length, PCM and Status */
 #define DWC3_TRB_SIZE_MASK	(0x00ffffff)
 #define DWC3_TRB_SIZE_LENGTH(n)	((n) & DWC3_TRB_SIZE_MASK)
@@ -748,6 +754,8 @@ struct dwc3 {
 	struct dwc3_hwparams	hwparams;
 	struct dentry		*root;
 	struct debugfs_regset32	*regset;
+	enum dwc3_pm_state	pm_state;
+	u8			is_otg;
 
 	u8			test_mode;
 	u8			test_mode_nr;
diff --git a/drivers/usb/dwc3/dwc3-device-intel.c b/drivers/usb/dwc3/dwc3-device-intel.c
index f7e8d40f8e3a..e7af05990987 100644
--- a/drivers/usb/dwc3/dwc3-device-intel.c
+++ b/drivers/usb/dwc3/dwc3-device-intel.c
@@ -22,6 +22,7 @@
 
 #include <linux/usb/dwc3-intel-mid.h>
 #include <linux/usb/phy.h>
+#include <linux/wakelock.h>
 
 #include "core.h"
 #include "gadget.h"
@@ -34,6 +35,209 @@
 #include "ep0.c"
 #include "gadget.c"
 
+/* FLIS register */
+#define APBFC_EXIOTG3_MISC0_REG		0xF90FF85C
+
+/* Global User Control Register Auto Retry bit*/
+#define DWC3_GUCTL_USB_HST_IN_AUTO_RETRY_EN	(1 << 14)
+
+/* Global Configuration Register */
+#define DWC3_GRXTHRCFG_USBRXPKTCNTSEL		(1 << 29)
+#define DWC3_GRXTHRCFG_USBRXPKTCNT(n)		(n << 24)
+#define DWC3_GRXTHRCFG_USBRXPKTCNT_MASK		(0xf << 24)
+#define DWC3_GRXTHRCFG_USBMAXRXBURSTSIZE(n)	(n << 19)
+#define DWC3_GRXTHRCFG_USBMAXRXBURSTSIZE_MASK	(0x1f << 19)
+
+/**
+ * struct dwc3_dev_data - Structure holding platform related
+ *			information
+ * @flis_reg:		FLIS register
+ * @grxthrcfg:		DWC3 GRXTHCFG register
+ */
+struct dwc3_dev_data {
+	struct dwc3		*dwc;
+	void __iomem		*flis_reg;
+	u32			grxthrcfg;
+	struct wake_lock	wake_lock;
+	struct mutex		mutex;
+};
+
+static struct dwc3_dev_data	*_dev_data;
+
+/*
+ * dwc3_set_fils_reg - set FLIS register
+ *
+ * This is a workaround for OTG3 IP bug of using EP #8 for host mode
+ */
+static void dwc3_set_flis_reg(void)
+{
+	u32			reg;
+	void __iomem		*flis_reg;
+
+	flis_reg = _dev_data->flis_reg;
+
+	reg = dwc3_readl(flis_reg, DWC3_GLOBALS_REGS_START);
+	reg &= ~(1 << 3);
+	dwc3_writel(flis_reg, DWC3_GLOBALS_REGS_START, reg);
+}
+
+/*
+ * dwc3_disable_multi_packet - set GRXTHRCFG register to disable
+ * reception multi-packet thresholdingfor DWC2.50a.
+ */
+static void dwc3_disable_multi_packet(struct dwc3 *dwc)
+{
+	u32			reg;
+
+	reg = dwc3_readl(dwc->regs, DWC3_GRXTHRCFG);
+	_dev_data->grxthrcfg = reg;
+	if (reg) {
+		reg &= ~DWC3_GRXTHRCFG_USBRXPKTCNTSEL;
+		reg &= ~DWC3_GRXTHRCFG_USBRXPKTCNT_MASK;
+		reg &= ~DWC3_GRXTHRCFG_USBMAXRXBURSTSIZE_MASK;
+
+		dwc3_writel(dwc->regs, DWC3_GRXTHRCFG, reg);
+	}
+}
+
+/*
+ * dwc3_enable_host_auto_retry - clear Auto Retry Enable bit
+ * for device mode
+ */
+static void dwc3_enable_host_auto_retry(struct dwc3 *dwc, bool enable)
+{
+	u32			reg;
+
+	reg = dwc3_readl(dwc->regs, DWC3_GUCTL);
+
+	if (enable)
+		reg |= DWC3_GUCTL_USB_HST_IN_AUTO_RETRY_EN;
+	else
+		reg &= ~DWC3_GUCTL_USB_HST_IN_AUTO_RETRY_EN;
+
+	dwc3_writel(dwc->regs, DWC3_GUCTL, reg);
+}
+
+static void dwc3_do_extra_change(struct dwc3 *dwc)
+{
+	dwc3_set_flis_reg();
+
+	if (dwc->revision == DWC3_REVISION_250A)
+		dwc3_disable_multi_packet(dwc);
+
+	dwc3_enable_host_auto_retry(dwc, false);
+}
+
+static void dwc3_enable_hibernation(struct dwc3 *dwc)
+{
+	u32 num, reg;
+
+	if (DWC3_GHWPARAMS1_EN_PWROPT(dwc->hwparams.hwparams1)
+		!= DWC3_GHWPARAMS1_EN_PWROPT_HIB) {
+		dev_err(dwc->dev, "Device Mode Hibernation is not supported\n");
+		return;
+	}
+
+	num = DWC3_GHWPARAMS4_HIBER_SCRATCHBUFS(
+		 dwc->hwparams.hwparams4);
+	if (num != 1)
+		dev_err(dwc->dev, "number of scratchpad buffer: %d\n", num);
+
+	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
+	reg |= DWC3_GCTL_GBLHIBERNATIONEN;
+	dwc3_writel(dwc->regs, DWC3_GCTL, reg);
+
+	dwc3_send_gadget_generic_command(dwc, DWC3_DGCMD_SET_SCRATCH_ADDR_LO,
+		dwc->scratch_array_dma & 0xffffffffU);
+}
+
+/*
+ * Re-write irq functions. Not use irq thread. Because irqthread has negative
+ * impact on usb performance, especially for usb network performance, USB3 UDP
+ * download performance will drop from 80MB/s to 40MB/s if irqthread is enabled.
+ */
+static irqreturn_t dwc3_quirks_process_event_buf(struct dwc3 *dwc, u32 buf)
+{
+	struct dwc3_event_buffer *evt;
+	u32 count;
+	u32 reg;
+	int left;
+
+	evt = dwc->ev_buffs[buf];
+
+	count = dwc3_readl(dwc->regs, DWC3_GEVNTCOUNT(buf));
+	count &= DWC3_GEVNTCOUNT_MASK;
+	if (!count)
+		return IRQ_NONE;
+
+	evt->count = count;
+
+	/* WORKAROUND: Add 4 us delay workaround to A-unit issue in A0 stepping.
+	* Can be removed after B0.
+	*/
+	if (dwc->is_otg && dwc->revision == DWC3_REVISION_210A)
+		udelay(4);
+
+	left = evt->count;
+
+	while (left > 0) {
+		union dwc3_event event;
+
+		event.raw = *(u32 *) (evt->buf + evt->lpos);
+
+		dwc3_process_event_entry(dwc, &event);
+
+		/*
+		* FIXME we wrap around correctly to the next entry as
+		* almost all entries are 4 bytes in size. There is one
+		* entry which has 12 bytes which is a regular entry
+		* followed by 8 bytes data. ATM I don't know how
+		* things are organized if we get next to the a
+		* boundary so I worry about that once we try to handle
+		* that.
+		*/
+		evt->lpos = (evt->lpos + 4) % DWC3_EVENT_BUFFERS_SIZE;
+		left -= 4;
+
+		dwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(buf), 4);
+	}
+
+	evt->count = 0;
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t dwc3_quirks_interrupt(int irq, void *_dwc)
+{
+	struct dwc3	*dwc = _dwc;
+	int		i;
+	irqreturn_t	ret = IRQ_NONE;
+
+	spin_lock(&dwc->lock);
+	if (dwc->pm_state != PM_ACTIVE) {
+		if (dwc->pm_state == PM_SUSPENDED) {
+			dev_info(dwc->dev, "u2/u3 pmu is received\n");
+			pm_runtime_get(dwc->dev);
+			dwc->pm_state = PM_RESUMING;
+			ret = IRQ_HANDLED;
+		}
+		goto out;
+	}
+
+	for (i = 0; i < dwc->num_event_buffers; i++) {
+		irqreturn_t status;
+
+		status = dwc3_quirks_process_event_buf(dwc, i);
+		if (status == IRQ_HANDLED)
+			ret = status;
+	}
+
+out:
+	spin_unlock(&dwc->lock);
+
+	return ret;
+}
+
 int dwc3_start_peripheral(struct usb_gadget *g)
 {
 	struct dwc3		*dwc = gadget_to_dwc(g);
@@ -41,37 +245,54 @@ int dwc3_start_peripheral(struct usb_gadget *g)
 	int			irq;
 	int			ret = 0;
 
+	wake_lock(&_dev_data->wake_lock);
 	pm_runtime_get_sync(dwc->dev);
 
-	irq = platform_get_irq(to_platform_device(dwc->dev), 0);
-	ret = request_threaded_irq(irq, dwc3_interrupt, dwc3_thread_interrupt,
-			IRQF_SHARED, "dwc3", dwc);
-	if (ret) {
-		dev_err(dwc->dev, "failed to request irq #%d --> %d\n",
-				irq, ret);
-		return ret;
-	}
-
+	mutex_lock(&_dev_data->mutex);
 	spin_lock_irqsave(&dwc->lock, flags);
 
-	if (dwc->gadget_driver) {
+	if (dwc->gadget_driver && dwc->soft_connected) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
 		dwc3_core_init(dwc);
+		spin_lock_irqsave(&dwc->lock, flags);
+
+		if (dwc->hiber_enabled)
+			dwc3_enable_hibernation(dwc);
+		dwc3_do_extra_change(dwc);
 		dwc3_event_buffers_setup(dwc);
 		ret = dwc3_init_for_enumeration(dwc);
 		if (ret)
-			goto err0;
+			goto err1;
 
-		if (dwc->soft_connected)
-			dwc3_gadget_run_stop(dwc, 1);
+		dwc3_gadget_run_stop(dwc, 1);
+		if (dwc->hiber_enabled)
+			dwc3_gadget_keep_conn(dwc, 1);
 	}
 
+	dwc->pm_state = PM_ACTIVE;
+
 	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	irq = platform_get_irq(to_platform_device(dwc->dev), 0);
+	if (dwc->quirks_disable_irqthread)
+		ret = request_irq(irq, dwc3_quirks_interrupt,
+				IRQF_SHARED, "dwc3", dwc);
+	else
+		ret = request_threaded_irq(irq, dwc3_interrupt, dwc3_thread_interrupt,
+				IRQF_SHARED, "dwc3", dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to request irq #%d --> %d\n",
+				irq, ret);
+		goto err0;
+	}
+	mutex_unlock(&_dev_data->mutex);
+
 	return 0;
 
-err0:
+err1:
 	spin_unlock_irqrestore(&dwc->lock, flags);
-
-	free_irq(irq, dwc);
+err0:
+	mutex_unlock(&_dev_data->mutex);
 
 	return ret;
 }
@@ -83,6 +304,7 @@ int dwc3_stop_peripheral(struct usb_gadget *g)
 	u8			epnum;
 	int			irq;
 
+	mutex_lock(&_dev_data->mutex);
 	spin_lock_irqsave(&dwc->lock, flags);
 
 	dwc3_stop_active_transfers(dwc);
@@ -97,8 +319,7 @@ int dwc3_stop_peripheral(struct usb_gadget *g)
 
 	/* Clear Run/Stop bit */
 	dwc3_gadget_run_stop(dwc, 0);
-
-	dwc->pm_state = PM_DISCONNECTED;
+	dwc3_gadget_keep_conn(dwc, 0);
 
 	for (epnum = 0; epnum < 2; epnum++) {
 		struct dwc3_ep  *dep;
@@ -113,36 +334,124 @@ int dwc3_stop_peripheral(struct usb_gadget *g)
 
 	dwc3_event_buffers_cleanup(dwc);
 
+	if (_dev_data->grxthrcfg && dwc->revision == DWC3_REVISION_250A) {
+		dwc3_writel(dwc->regs, DWC3_GRXTHRCFG, _dev_data->grxthrcfg);
+		_dev_data->grxthrcfg = 0;
+	}
+
+	dwc3_enable_host_auto_retry(dwc, true);
+
+	if (dwc->pm_state != PM_SUSPENDED)
+		pm_runtime_put(dwc->dev);
+
+	dwc->pm_state = PM_DISCONNECTED;
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	irq = platform_get_irq(to_platform_device(dwc->dev), 0);
 	free_irq(irq, dwc);
 
-	pm_runtime_put(dwc->dev);
+	mutex_unlock(&_dev_data->mutex);
+
+	cancel_delayed_work_sync(&dwc->link_work);
+
+	wake_unlock(&_dev_data->wake_lock);
 
 	return 0;
 }
 
-int dwc3_vbus_draw(struct usb_gadget *g, unsigned ma)
+static int dwc3_device_gadget_pullup(struct usb_gadget *g, int is_on)
 {
-	struct dwc3         *dwc = gadget_to_dwc(g);
-	struct usb_phy      *usb_phy;
-	int             ret;
+	struct dwc3		*dwc = gadget_to_dwc(g);
+	unsigned long		flags;
+	int			ret;
+
+	/*
+	 * FIXME If pm_state is PM_RESUMING, we should wait for it to
+	 * become PM_ACTIVE before continue. The chance of hitting
+	 * PM_RESUMING is rare, but if so, we'll return directly.
+	 *
+	 * If some gadget reaches here in atomic context,
+	 * pm_runtime_get_sync will cause a sleep problem.
+	 */
+	if (dwc->pm_state == PM_RESUMING) {
+		dev_err(dwc->dev, "%s: PM_RESUMING, return -EIO\n", __func__);
+		return -EIO;
+	}
 
-	dev_dbg(dwc->dev, "otg_set_power: %d ma\n", ma);
+	if (dwc->pm_state == PM_SUSPENDED)
+		pm_runtime_get_sync(dwc->dev);
 
-	usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
-	if (!usb_phy) {
-		dev_err(dwc->dev, "OTG driver not available\n");
-		return -ENODEV;
+	is_on = !!is_on;
+
+	mutex_lock(&_dev_data->mutex);
+
+	if (dwc->soft_connected == is_on)
+		goto done;
+
+	dwc->soft_connected = is_on;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	if (dwc->pm_state == PM_DISCONNECTED) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		goto done;
 	}
 
-	ret = usb_phy_set_power(usb_phy, ma);
-	usb_put_phy(usb_phy);
+	if (is_on) {
+		/* Per dwc3 databook 2.40a section 8.1.9, re-connection
+		 * should follow steps described section 8.1.1 power on
+		 * or soft reset.
+		 */
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		dwc3_core_init(dwc);
+		spin_lock_irqsave(&dwc->lock, flags);
+
+		if (dwc->hiber_enabled)
+			dwc3_enable_hibernation(dwc);
+		dwc3_do_extra_change(dwc);
+		dwc3_event_buffers_setup(dwc);
+		dwc3_init_for_enumeration(dwc);
+		ret = dwc3_gadget_run_stop(dwc, 1);
+		if (dwc->hiber_enabled)
+			dwc3_gadget_keep_conn(dwc, 1);
+	} else {
+		u8 epnum;
+
+		for (epnum = 0; epnum < 2; epnum++) {
+			struct dwc3_ep  *dep;
+
+			dep = dwc->eps[epnum];
+
+			if (dep->flags & DWC3_EP_ENABLED)
+				__dwc3_gadget_ep_disable(dep);
+		}
+
+		dwc3_stop_active_transfers(dwc);
+		dwc3_gadget_keep_conn(dwc, 0);
+		ret = dwc3_gadget_run_stop(dwc, 0);
+		dwc3_gadget_disable_irq(dwc);
+	}
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+	mutex_unlock(&_dev_data->mutex);
 
 	return ret;
+
+done:
+	mutex_unlock(&_dev_data->mutex);
+
+	return 0;
 }
 
+static const struct usb_gadget_ops dwc3_device_gadget_ops = {
+	.get_frame		= dwc3_gadget_get_frame,
+	.wakeup			= dwc3_gadget_wakeup,
+	.set_selfpowered	= dwc3_gadget_set_selfpowered,
+	.pullup			= dwc3_device_gadget_pullup,
+	.udc_start		= dwc3_gadget_start,
+	.udc_stop		= dwc3_gadget_stop,
+	.vbus_draw		= dwc3_vbus_draw,
+};
+
 static int dwc3_device_intel_probe(struct platform_device *pdev)
 {
 	struct device_node	*node = pdev->dev.of_node;
@@ -163,6 +472,14 @@ static int dwc3_device_intel_probe(struct platform_device *pdev)
 	dwc = PTR_ALIGN(mem, DWC3_ALIGN_MASK + 1);
 	dwc->mem = mem;
 
+	_dev_data = kzalloc(sizeof(*_dev_data), GFP_KERNEL);
+	if (!_dev_data) {
+		dev_err(dev, "not enough memory\n");
+		return -ENOMEM;
+	}
+
+	_dev_data->dwc = dwc;
+
 	pdata = (struct dwc_device_par *)pdev->dev.platform_data;
 	if (!pdata) {
 		dev_err(&pdev->dev, "No platform data for %s.\n",
@@ -208,6 +525,7 @@ static int dwc3_device_intel_probe(struct platform_device *pdev)
 		return -EPROBE_DEFER;
 	}
 
+	mutex_init(&_dev_data->mutex);
 	spin_lock_init(&dwc->lock);
 	platform_set_drvdata(pdev, dwc);
 
@@ -232,13 +550,18 @@ static int dwc3_device_intel_probe(struct platform_device *pdev)
 
 	dwc->needs_fifo_resize = of_property_read_bool(node, "tx-fifo-resize");
 
+	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(dev);
+	pm_runtime_set_suspended(&pdev->dev);
 	pm_runtime_get_sync(dev);
 	pm_runtime_forbid(dev);
 
 	dwc3_cache_hwparams(dwc);
 	dwc3_core_num_eps(dwc);
 
+	_dev_data->flis_reg =
+		ioremap_nocache(APBFC_EXIOTG3_MISC0_REG, 4);
+
 	ret = dwc3_alloc_event_buffers(dwc, DWC3_EVENT_BUFFERS_SIZE);
 	if (ret) {
 		dev_err(dwc->dev, "failed to allocate event buffers\n");
@@ -246,6 +569,12 @@ static int dwc3_device_intel_probe(struct platform_device *pdev)
 		goto err0;
 	}
 
+	/*
+	* Not use irq thread, because irqthread has negative impact
+	* on usb performance, especially for usb network performance.
+	*/
+	dwc->quirks_disable_irqthread = 1;
+
 	usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
 	otg = container_of(usb_phy, struct dwc_otg2, usb2_phy);
 	otg->start_device = dwc3_start_peripheral;
@@ -254,6 +583,8 @@ static int dwc3_device_intel_probe(struct platform_device *pdev)
 	usb_put_phy(usb_phy);
 	dwc->is_otg = 1;
 
+	wake_lock_init(&_dev_data->wake_lock,
+			WAKE_LOCK_SUSPEND, "dwc_wake_lock");
 
 	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_DEVICE);
 	ret = dwc3_gadget_init(dwc);
@@ -261,6 +592,9 @@ static int dwc3_device_intel_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to initialize gadget\n");
 		goto err0;
 	}
+	dwc->gadget.ops = &dwc3_device_gadget_ops;
+	dwc->gadget.is_otg = 1;
+
 	dwc->mode = DWC3_MODE_DEVICE;
 
 	ret = dwc3_debugfs_init(dwc);
@@ -270,6 +604,7 @@ static int dwc3_device_intel_probe(struct platform_device *pdev)
 	}
 
 	pm_runtime_allow(dev);
+	pm_runtime_put(dev);
 
 	return 0;
 
@@ -282,13 +617,37 @@ err0:
 	return ret;
 }
 
+static int dwc3_device_intel_remove(struct platform_device *pdev)
+{
+	iounmap(_dev_data->flis_reg);
+
+	wake_lock_destroy(&_dev_data->wake_lock);
+
+	dwc3_remove(pdev);
+
+	kfree(_dev_data);
+	_dev_data = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static const struct dev_pm_ops dwc3_device_pm_ops = {
+	.runtime_suspend	= dwc3_runtime_suspend,
+	.runtime_resume		= dwc3_runtime_resume,
+};
+#define DWC3_DEVICE_PM_OPS	(&dwc3_device_pm_ops)
+#else
+#define DWC3_DEVICE_PM_OPS	NULL
+#endif
+
 static struct platform_driver dwc3_device_intel_driver = {
 	.probe		= dwc3_device_intel_probe,
-	.remove		= dwc3_remove,
+	.remove		= dwc3_device_intel_remove,
 	.driver		= {
 		.name	= "dwc3-device",
 		.of_match_table	= of_match_ptr(of_dwc3_match),
-		.pm	= DWC3_PM_OPS,
+		.pm	= DWC3_DEVICE_PM_OPS,
 	},
 };
 
diff --git a/drivers/usb/dwc3/dwc3-host-intel.c b/drivers/usb/dwc3/dwc3-host-intel.c
index 28374656e01b..75c80beff6fa 100644
--- a/drivers/usb/dwc3/dwc3-host-intel.c
+++ b/drivers/usb/dwc3/dwc3-host-intel.c
@@ -31,12 +31,44 @@
 #include "core.h"
 #include "otg.h"
 
+#define WAIT_DISC_EVENT_COMPLETE_TIMEOUT 5 /* 100ms */
+
 static int otg_irqnum;
 
 static int dwc3_start_host(struct usb_hcd *hcd);
 static int dwc3_stop_host(struct usb_hcd *hcd);
 static struct platform_driver dwc3_xhci_driver;
 
+static void xhci_dwc3_quirks(struct device *dev, struct xhci_hcd *xhci)
+{
+	/*
+	 * As of now platform drivers don't provide MSI support so we ensure
+	 * here that the generic code does not try to make a pci_dev from our
+	 * dev struct in order to setup MSI
+	 *
+	 * Synopsys DWC3 controller will generate PLC when link transfer to
+	 * compliance/loopback mode.
+	 */
+	xhci->quirks |= XHCI_PLAT | XHCI_COMP_PLC_QUIRK;
+}
+
+/* called during probe() after chip reset completes */
+static int xhci_dwc3_setup(struct usb_hcd *hcd)
+{
+	return xhci_gen_setup(hcd, xhci_dwc3_quirks);
+}
+
+static int xhci_dwc_bus_resume(struct usb_hcd *hcd)
+{
+	int ret;
+
+	/* before resume bus, delay 1ms to waiting core stable */
+	mdelay(1);
+
+	ret = xhci_bus_resume(hcd);
+	return ret;
+}
+
 static const struct hc_driver xhci_dwc_hc_driver = {
 	.description =		"dwc-xhci",
 	.product_desc =		"xHCI Host Controller",
@@ -51,7 +83,7 @@ static const struct hc_driver xhci_dwc_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset =		xhci_plat_setup,
+	.reset =		xhci_dwc3_setup,
 	.start =		xhci_run,
 	.stop =			xhci_stop,
 	.shutdown =		xhci_shutdown,
@@ -83,7 +115,7 @@ static const struct hc_driver xhci_dwc_hc_driver = {
 	.hub_control =		xhci_hub_control,
 	.hub_status_data =	xhci_hub_status_data,
 	.bus_suspend =		xhci_bus_suspend,
-	.bus_resume =		xhci_bus_resume,
+	.bus_resume =		xhci_dwc_bus_resume,
 };
 
 static int if_usb_devices_connected(struct xhci_hcd *xhci)
@@ -121,7 +153,7 @@ static void dwc_xhci_enable_phy_auto_resume(struct usb_hcd *hcd, bool enable)
 		val |= GUSB2PHYCFG_ULPI_AUTO_RESUME;
 	else
 		val &= ~GUSB2PHYCFG_ULPI_AUTO_RESUME;
-	writel(val, hcd->regs + GUSB3PIPECTL0);
+	writel(val, hcd->regs + GUSB2PHYCFG0);
 }
 
 static void dwc_xhci_enable_phy_suspend(struct usb_hcd *hcd, bool enable)
@@ -200,19 +232,20 @@ static void dwc_core_reset(struct usb_hcd *hcd)
 	writel(val, hcd->regs + GCTL);
 }
 
-/* This is a hardware workaround.
- * xHCI RxDetect state is not work well when USB3
- * PHY under P3 state. So force PHY change to P2 when
- * xHCI want to perform receiver detection.
- */
-static void dwc_disable_ssphy_p3(struct usb_hcd *hcd)
+/*
+ * On MERR platform, the suspend clock is 19.2MHz.
+ * Hence PwrDnScale = 19200 / 16 = 1200 (= 0x4B0).
+ * To account for possible jitter of suspend clock and to have margin,
+ * So recommend it to be set to 1250 (= 0x4E2).
+ * */
+static void dwc_set_ssphy_p3_clockrate(struct usb_hcd *hcd)
 {
-	u32 phyval;
-
-	phyval = readl(hcd->regs + GUSB3PIPECTL0);
-	phyval |= GUSB3PIPE_DISRXDETP3;
-	writel(phyval, hcd->regs + GUSB3PIPECTL0);
+	u32 gctl;
 
+	gctl = readl(hcd->regs + GCTL);
+	gctl &= ~GCTL_PWRDNSCALE_MASK;
+	gctl |= GCTL_PWRDNSCALE(0x4E2);
+	writel(gctl, hcd->regs + GCTL);
 }
 
 static ssize_t
@@ -249,6 +282,7 @@ static int dwc3_start_host(struct usb_hcd *hcd)
 {
 	int ret = -EINVAL;
 	struct xhci_hcd *xhci;
+	struct usb_hcd *xhci_shared_hcd;
 
 	if (!hcd)
 		return ret;
@@ -264,7 +298,11 @@ static int dwc3_start_host(struct usb_hcd *hcd)
 	dwc_core_reset(hcd);
 	dwc_silicon_wa(hcd);
 	dwc_set_host_mode(hcd);
-	dwc_disable_ssphy_p3(hcd);
+	dwc_set_ssphy_p3_clockrate(hcd);
+
+	/* Clear the hcd->flags.
+	 * To prevent incorrect flags set during last time. */
+	hcd->flags = 0;
 
 	ret = usb_add_hcd(hcd, otg_irqnum, IRQF_SHARED);
 	if (ret)
@@ -278,6 +316,8 @@ static int dwc3_start_host(struct usb_hcd *hcd)
 		goto dealloc_usb2_hcd;
 	}
 
+	xhci->quirks |= XHCI_PLAT;
+
 	/* Set the xHCI pointer before xhci_pci_setup() (aka hcd_driver.reset)
 	 * is called by usb_add_hcd().
 	 */
@@ -305,8 +345,9 @@ static int dwc3_start_host(struct usb_hcd *hcd)
 
 put_usb3_hcd:
 	if (xhci->shared_hcd) {
-		usb_remove_hcd(xhci->shared_hcd);
-		usb_put_hcd(xhci->shared_hcd);
+		xhci_shared_hcd = xhci->shared_hcd;
+		usb_remove_hcd(xhci_shared_hcd);
+		usb_put_hcd(xhci_shared_hcd);
 	}
 
 dealloc_usb2_hcd:
@@ -324,7 +365,9 @@ dealloc_usb2_hcd:
 
 static int dwc3_stop_host(struct usb_hcd *hcd)
 {
+	int count = 0;
 	struct xhci_hcd *xhci;
+	struct usb_hcd *xhci_shared_hcd;
 
 	if (!hcd)
 		return -EINVAL;
@@ -333,11 +376,24 @@ static int dwc3_stop_host(struct usb_hcd *hcd)
 
 	pm_runtime_get_sync(hcd->self.controller);
 
+	/* When plug out micro A cable, there will be two flows be executed.
+	 * The first one is xHCI controller get disconnect event. The
+	 * second one is PMIC get ID change event. During these events
+	 * handling, they both try to call usb_disconnect. Then met some
+	 * conflicts and cause kernel panic.
+	 * So treat disconnect event as first priority, handle the ID change
+	 * event until disconnect event handled done.*/
+	while (if_usb_devices_connected(xhci)) {
+		msleep(20);
+		if (count++ > WAIT_DISC_EVENT_COMPLETE_TIMEOUT)
+			break;
+	};
 	dwc3_xhci_driver.shutdown = NULL;
 
 	if (xhci->shared_hcd) {
-		usb_remove_hcd(xhci->shared_hcd);
-		usb_put_hcd(xhci->shared_hcd);
+		xhci_shared_hcd = xhci->shared_hcd;
+		usb_remove_hcd(xhci_shared_hcd);
+		usb_put_hcd(xhci_shared_hcd);
 	}
 
 	usb_remove_hcd(hcd);
@@ -414,6 +470,9 @@ static int xhci_dwc_drv_probe(struct platform_device *pdev)
 
 	usb_put_phy(usb_phy);
 
+	/* Enable wakeup irq */
+	hcd->has_wakeup_irq = 1;
+
 	platform_set_drvdata(pdev, hcd);
 	pm_runtime_enable(hcd->self.controller);
 
@@ -594,6 +653,11 @@ static int dwc_hcd_runtime_suspend(struct device *dev)
 static int dwc_hcd_runtime_resume(struct device *dev)
 {
 	int retval;
+	struct platform_device      *pdev = to_platform_device(dev);
+	struct usb_hcd      *hcd = platform_get_drvdata(pdev);
+
+	dwc_xhci_enable_phy_auto_resume(
+			hcd, false);
 
 	retval = dwc_hcd_resume_common(dev);
 	dev_dbg(dev, "hcd_pci_runtime_resume: %d\n", retval);
@@ -610,9 +674,15 @@ static int dwc_hcd_runtime_resume(struct device *dev)
 static int dwc_hcd_suspend(struct device *dev)
 {
 	int retval;
+	struct platform_device      *pdev = to_platform_device(dev);
+	struct usb_hcd      *hcd = platform_get_drvdata(pdev);
 
 	retval = dwc_hcd_suspend_common(dev);
 
+	if (retval)
+		dwc_xhci_enable_phy_auto_resume(
+			hcd, false);
+
 	dev_dbg(dev, "hcd_pci_runtime_suspend: %d\n", retval);
 	return retval;
 }
@@ -620,6 +690,11 @@ static int dwc_hcd_suspend(struct device *dev)
 static int dwc_hcd_resume(struct device *dev)
 {
 	int retval;
+	struct platform_device      *pdev = to_platform_device(dev);
+	struct usb_hcd      *hcd = platform_get_drvdata(pdev);
+
+	dwc_xhci_enable_phy_auto_resume(
+			hcd, false);
 
 	retval = dwc_hcd_resume_common(dev);
 	dev_dbg(dev, "hcd_pci_runtime_resume: %d\n", retval);
@@ -642,8 +717,7 @@ static struct platform_driver dwc3_xhci_driver = {
 	.driver = {
 		.name = "dwc3-host",
 #ifdef CONFIG_PM
-		/* Disable pm now. Will enable PM with other patches */
-		/*.pm = &dwc_usb_hcd_pm_ops */
+		.pm = &dwc_usb_hcd_pm_ops,
 #endif
 	},
 };
diff --git a/drivers/usb/dwc3/dwc3-intel-mrfl.c b/drivers/usb/dwc3/dwc3-intel-mrfl.c
index 2949dd2e27bd..8c2825cdabbc 100644
--- a/drivers/usb/dwc3/dwc3-intel-mrfl.c
+++ b/drivers/usb/dwc3/dwc3-intel-mrfl.c
@@ -23,7 +23,32 @@
 static int otg_id = -1;
 static int enable_usb_phy(struct dwc_otg2 *otg, bool on_off);
 static int dwc3_intel_notify_charger_type(struct dwc_otg2 *otg,
-		enum usb_charger_state state);
+		enum power_supply_charger_event event);
+static struct power_supply_cable_props cap_record;
+static int shady_cove_get_id(struct dwc_otg2 *otg);
+
+static int charger_detect_enable(struct dwc_otg2 *otg)
+{
+	struct intel_dwc_otg_pdata *data;
+
+	if (!otg || !otg->otg_data)
+		return 0;
+
+	data = (struct intel_dwc_otg_pdata *)otg->otg_data;
+
+	return data->charger_detect_enable;
+}
+
+static int is_basin_cove(struct dwc_otg2 *otg)
+{
+	struct intel_dwc_otg_pdata *data;
+	if (!otg || !otg->otg_data)
+		return -EINVAL;
+
+	data = (struct intel_dwc_otg_pdata *)otg->otg_data;
+
+	return data->pmic_type == BASIN_COVE;
+}
 
 static int is_hybridvp(struct dwc_otg2 *otg)
 {
@@ -36,11 +61,69 @@ static int is_hybridvp(struct dwc_otg2 *otg)
 	return data->is_hvp;
 }
 
-static enum usb_charger_type aca_check(struct dwc_otg2 *otg)
+static void usb2phy_eye_optimization(struct dwc_otg2 *otg)
+{
+	struct usb_phy *phy;
+
+	phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (!phy)
+		return;
+
+	/* Set 0x7f for better quality in eye diagram
+	 * It means ZHSDRV = 0b11 and IHSTX = 0b1111*/
+	usb_phy_io_write(phy, 0x7f, TUSB1211_VENDOR_SPECIFIC1_SET);
+
+	usb_put_phy(phy);
+}
+
+
+/* As we use SW mode to do charger detection, need to notify HW
+ * the result SW get, charging port or not */
+static int dwc_otg_charger_hwdet(bool enable)
+{
+	int				retval;
+	struct usb_phy *phy;
+	struct dwc_otg2 *otg = dwc3_get_otg();
+
+	/* Just return if charger detection is not enabled */
+	if (!charger_detect_enable(otg))
+		return 0;
+
+	phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (!phy)
+		return -ENODEV;
+
+	if (enable) {
+		retval = usb_phy_io_write(phy, PWCTRL_HWDETECT,
+				TUSB1211_POWER_CONTROL_SET);
+		if (retval)
+			return retval;
+		otg_dbg(otg, "set HWDETECT\n");
+	} else {
+		retval = usb_phy_io_write(phy, PWCTRL_HWDETECT,
+				TUSB1211_POWER_CONTROL_CLR);
+		if (retval)
+			return retval;
+		otg_dbg(otg, "clear HWDETECT\n");
+	}
+	usb_put_phy(phy);
+
+	return 0;
+}
+
+static enum power_supply_charger_cable_type
+			basin_cove_aca_check(struct dwc_otg2 *otg)
 {
 	u8 rarbrc;
-	enum usb_charger_type type = CHRG_UNKNOWN;
 	int ret;
+	enum power_supply_charger_cable_type type =
+		POWER_SUPPLY_CHARGER_TYPE_NONE;
+
+	ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
+			USBIDCTRL_ACA_DETEN_D1,
+			USBIDCTRL_ACA_DETEN_D1);
+	if (ret)
+		otg_err(otg, "Fail to enable ACA&ID detection logic\n");
 
 	/* Wait >66.1ms (for TCHGD_SERX_DEB) */
 	msleep(66);
@@ -50,21 +133,56 @@ static enum usb_charger_type aca_check(struct dwc_otg2 *otg)
 	if (ret)
 		otg_err(otg, "Fail to read decoded RID value\n");
 	rarbrc &= USBIDSTS_ID_RARBRC_STS(3);
+	rarbrc >>= 1;
 
 	/* If ID_RARBRC_STS==01: ACA-Dock detected
 	 * If ID_RARBRC_STS==00: MHL detected
 	 */
 	if (rarbrc == 1) {
 		/* ACA-Dock */
-		type = CHRG_ACA_DOCK;
+		type = POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK;
 	} else if (!rarbrc) {
 		/* MHL */
-		type = CHRG_MHL;
+		type = POWER_SUPPLY_CHARGER_TYPE_MHL;
 	}
 
+	ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
+			USBIDCTRL_ACA_DETEN_D1,
+			0);
+	if (ret)
+		otg_err(otg, "Fail to enable ACA&ID detection logic\n");
+
 	return type;
 }
 
+static enum power_supply_charger_cable_type
+		shady_cove_aca_check(struct dwc_otg2 *otg)
+{
+
+	if (!otg)
+		return POWER_SUPPLY_CHARGER_TYPE_NONE;
+
+	switch (shady_cove_get_id(otg)) {
+	case RID_A:
+		return POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK;
+	case RID_B:
+		return POWER_SUPPLY_CHARGER_TYPE_ACA_B;
+	case RID_C:
+		return POWER_SUPPLY_CHARGER_TYPE_ACA_C;
+	default:
+		return POWER_SUPPLY_CHARGER_TYPE_NONE;
+	}
+}
+
+static enum power_supply_charger_cable_type
+		dwc3_intel_aca_check(struct dwc_otg2 *otg)
+{
+	if (is_basin_cove(otg))
+		return basin_cove_aca_check(otg);
+	else
+		return shady_cove_aca_check(otg);
+}
+
 static ssize_t store_otg_id(struct device *_dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
@@ -130,6 +248,19 @@ show_otg_id(struct device *_dev, struct device_attribute *attr, char *buf)
 static DEVICE_ATTR(otg_id, S_IRUGO|S_IWUSR|S_IWGRP,
 			show_otg_id, store_otg_id);
 
+static void dwc_a_bus_drop(struct usb_phy *x)
+{
+	struct dwc_otg2 *otg = dwc3_get_otg();
+	unsigned long flags;
+
+	if (otg->usb2_phy.vbus_state == VBUS_DISABLED) {
+		spin_lock_irqsave(&otg->lock, flags);
+		otg->user_events |= USER_A_BUS_DROP;
+		dwc3_wakeup_otg_thread(otg);
+		spin_unlock_irqrestore(&otg->lock, flags);
+	}
+}
+
 static void set_sus_phy(struct dwc_otg2 *otg, int bit)
 {
 	u32 data = 0;
@@ -155,6 +286,10 @@ int dwc3_intel_platform_init(struct dwc_otg2 *otg)
 	u32 gctl;
 	int retval;
 
+	/* Init a_bus_drop callback */
+	otg->usb2_phy.a_bus_drop = dwc_a_bus_drop;
+	otg->usb2_phy.vbus_state = VBUS_ENABLED;
+
 	otg_info(otg, "De-assert USBRST# to enable PHY\n");
 	retval = intel_scu_ipc_iowrite8(PMIC_USBPHYCTRL,
 			PMIC_USBPHYCTRL_D0);
@@ -183,6 +318,18 @@ int dwc3_intel_platform_init(struct dwc_otg2 *otg)
 	return 0;
 }
 
+/* Disable auto-resume feature for USB2 PHY. This is one
+ * silicon workaround. It will cause fabric timeout error
+ * for LS case after resume from hibernation */
+static void disable_phy_auto_resume(struct dwc_otg2 *otg)
+{
+	u32 data = 0;
+
+	data = otg_read(otg, GUSB2PHYCFG0);
+	data &= ~GUSB2PHYCFG_ULPI_AUTO_RESUME;
+	otg_write(otg, GUSB2PHYCFG0, data);
+}
+
 /* This function will control VUSBPHY to power gate/ungate USBPHY */
 static int enable_usb_phy(struct dwc_otg2 *otg, bool on_off)
 {
@@ -205,10 +352,10 @@ static int enable_usb_phy(struct dwc_otg2 *otg, bool on_off)
 	return 0;
 }
 
-int dwc3_intel_get_id(struct dwc_otg2 *otg)
+int basin_cove_get_id(struct dwc_otg2 *otg)
 {
 	int ret, id = RID_UNKNOWN;
-	u8 idsts;
+	u8 idsts, pmic_id;
 
 	ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
 			USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0,
@@ -226,25 +373,148 @@ int dwc3_intel_get_id(struct dwc_otg2 *otg)
 
 	if (idsts & USBIDSTS_ID_FLOAT_STS)
 		id = RID_FLOAT;
-	else if (idsts & USBIDSTS_ID_GND)
-		id = RID_GND;
 	else if (idsts & USBIDSTS_ID_RARBRC_STS(1))
 		id = RID_A;
 	else if (idsts & USBIDSTS_ID_RARBRC_STS(2))
 		id = RID_B;
 	else if (idsts & USBIDSTS_ID_RARBRC_STS(3))
 		id = RID_C;
+	else {
+		/* PMIC A0 reports ID_GND = 0 for RID_GND but PMIC B0 reports
+		*  ID_GND = 1 for RID_GND
+		*/
+		ret = intel_scu_ipc_ioread8(0x00, &pmic_id);
+		if (ret) {
+			otg_err(otg, "Fail to read PMIC ID register\n");
+		} else if (((pmic_id & VENDOR_ID_MASK) == BASIN_COVE_PMIC_ID) &&
+			((pmic_id & PMIC_MAJOR_REV) == PMIC_A0_MAJOR_REV)) {
+				if (idsts & USBIDSTS_ID_GND)
+					id = RID_GND;
+		} else {
+			if (!(idsts & USBIDSTS_ID_GND))
+				id = RID_GND;
+		}
+	}
+
+	ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
+			USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0,
+			0);
+	if (ret)
+		otg_err(otg, "Fail to enable ACA&ID detection logic\n");
 
 	return id;
 }
 
+int shady_cove_get_id(struct dwc_otg2 *otg)
+{
+	int ret, count = 0, id = RID_UNKNOWN;
+	u8 val, id_l, id_h, cursrc, schgrirq1;
+	unsigned long rlsb, rid;
+	unsigned long rlsb_array[] = {
+	0, 260480, 130240, 65120,
+	32560, 16280, 8140, 4070, 2035};
+
+	ret = intel_scu_ipc_ioread8(PMIC_SCHGRIRQ1, &schgrirq1);
+	if (ret) {
+		otg_err(otg, "Fail to read id\n");
+		return id;
+	}
+
+	/* PMIC_SCHGRIRQ1_SUSBIDDET bit definition:
+	 * 0 = RID_A/B/C ; 1 = RID_GND ; 2 = RID_FLOAT */
+	if (schgrirq1 & PMIC_SCHGRIRQ1_SUSBIDDET(2))
+		return RID_FLOAT;
+	else if (schgrirq1 & PMIC_SCHGRIRQ1_SUSBIDDET(1))
+		return RID_GND;
+
+	/* Initiate a USBID resistance check. */
+	ret = intel_scu_ipc_update_register(PMIC_GPADCREQ_REG,
+			PMIC_GPADCREQ_ADC_USBID,
+			PMIC_GPADCREQ_ADC_USBID);
+	if (ret) {
+		otg_err(otg, "Fail to enable USBID resistance\n");
+		goto done;
+	}
+
+	/* Poll whether ADC conversion is finished. */
+	while (1) {
+		count++;
+
+		if (count > 9) {
+			otg_err(otg, "ADC conversion timeout!\n");
+			goto done;
+		}
+		mdelay(1);
+
+		ret = intel_scu_ipc_ioread8(PMIC_ADCIRQ_REG, &val);
+		if (ret) {
+			otg_err(otg, "Fail to read decoded RID value\n");
+			goto done;
+		}
+
+		if (val & PMIC_ADCIRQ_USBID)
+			break;
+	}
+
+	/* Read ADC value lower 8 bits. */
+	ret = intel_scu_ipc_ioread8(PMIC_USBIDRSLTL, &id_l);
+	if (ret) {
+		otg_err(otg, "IPC read PMIC_USBIDRSLTL failed!\n");
+		goto done;
+	}
+	id_l &= PMIC_USBIDRSLTL_USBID_L_MASK;
+
+	/* Read ADC value upper 4 bits.
+	 * Read Current source value 4 bits.*/
+	ret = intel_scu_ipc_ioread8(PMIC_USBIDRSLTH, &id_h);
+	if (ret) {
+		otg_err(otg, "IPC read PMIC_USBIDRSLTL failed!\n");
+		goto done;
+	}
+	cursrc = id_h & PMIC_USBIDRSLTH_USBID_CURSRC_MASK;
+	id_h &= PMIC_USBIDRSLTH_USBID_H_MASK;
+
+	/* @RLSb_array[USBID_CURSRC] = {NULL, 260.48,
+	 * 130.24, 65.12, 32.56, 16.28, 8.14, 4.07, 2.035};
+	 * RLSb = 2.035 * power(2,8-USBID_CURSRC);
+	 * RID = ((USBID_H << 8) + (USBID_L)) * RLSb;*/
+	cursrc >>= 4;
+
+	/* Due to linux kernel can't support float calculate.
+	 * So we multiple 1000 for calculate */
+	rlsb = rlsb_array[cursrc];
+	rid = ((id_h << 8) + (id_l)) * rlsb;
+
+	/* If RID value is within:
+	 * 111.5k to 136.4kΩ: ACA-A/ACA-Dock detected
+	 * 61.2k to 74.8kΩ: ACA-B detected
+	 * 32.85k to 40.15kΩ: ACA-C detected
+	 * else: Unknown detected */
+	do_div(rid, 1000UL);
+
+	if ((rid > 111500) && (rid < 136400))
+		return RID_A;
+	else if ((rid > 61200) && (rid < 74800))
+		return RID_B;
+	else if ((rid > 32850) && (rid < 40150))
+		return RID_C;
+
+done:
+	return RID_UNKNOWN;
+}
+
+int dwc3_intel_get_id(struct dwc_otg2 *otg)
+{
+	if (is_basin_cove(otg))
+		return basin_cove_get_id(otg);
+	else
+		return shady_cove_get_id(otg);
+}
+
 int dwc3_intel_b_idle(struct dwc_otg2 *otg)
 {
 	u32 gctl, tmp;
 
-	if (!is_hybridvp(otg))
-		enable_usb_phy(otg, false);
-
 	/* Disable hibernation mode by default */
 	gctl = otg_read(otg, GCTL);
 	gctl &= ~GCTL_GBL_HIBERNATION_EN;
@@ -269,7 +539,11 @@ int dwc3_intel_b_idle(struct dwc_otg2 *otg)
 	gctl |= GCTL_PRT_CAP_DIR_DEV << GCTL_PRT_CAP_DIR_SHIFT;
 	otg_write(otg, GCTL, gctl);
 
-	enable_usb_phy(otg, true);
+	if (!is_hybridvp(otg)) {
+		dwc_otg_charger_hwdet(false);
+		enable_usb_phy(otg, false);
+	}
+
 	mdelay(100);
 
 	return 0;
@@ -280,30 +554,85 @@ static int dwc3_intel_set_power(struct usb_phy *_otg,
 {
 	unsigned long flags;
 	struct dwc_otg2 *otg = dwc3_get_otg();
+	struct power_supply_cable_props cap;
+	struct intel_dwc_otg_pdata *data;
 
-	if (!otg)
-		return 0;
-
-	/* force 896ma to 900ma
-	 * Beucause the power just can be set as an
-	 * integer multiple of 8 in usb configuration descriptor
-	 */
-	if (ma == 896)
-		ma = 900;
+	data = (struct intel_dwc_otg_pdata *)otg->otg_data;
 
-	if ((ma != 100) &&
-		(ma != 150) &&
-		(ma != 500) &&
-		(ma != 900)) {
-		otg_err(otg, "Device driver set invalid SDP current value!\n");
+	if (otg->charging_cap.chrg_type ==
+			POWER_SUPPLY_CHARGER_TYPE_USB_CDP)
+		return 0;
+	else if (otg->charging_cap.chrg_type !=
+			POWER_SUPPLY_CHARGER_TYPE_USB_SDP) {
+		otg_err(otg, "%s: currently, chrg type is not SDP!\n",
+				__func__);
 		return -EINVAL;
 	}
 
-	if (otg->charging_cap.chrg_type == CHRG_CDP)
+	if (ma == OTG_DEVICE_SUSPEND) {
+		spin_lock_irqsave(&otg->lock, flags);
+		cap.chrg_type = otg->charging_cap.chrg_type;
+		cap.ma = otg->charging_cap.ma;
+		cap.chrg_evt = POWER_SUPPLY_CHARGER_EVENT_SUSPEND;
+		spin_unlock_irqrestore(&otg->lock, flags);
+
+		/* mA is zero mean D+/D- opened cable.
+		 * If SMIP set, then notify 500mA.
+		 * Otherwise, notify 0mA.
+		*/
+		if (!cap.ma) {
+			if (data->charging_compliance) {
+				cap.ma = 500;
+				cap.chrg_evt =
+					POWER_SUPPLY_CHARGER_EVENT_CONNECT;
+			}
+		/* For standard SDP, if SMIP set, then ignore suspend */
+		} else if (data->charging_compliance)
+			return 0;
+		/* Stander SDP(cap.mA != 0) and SMIP not set.
+		 * Should send 0mA with SUSPEND event
+		 */
+		else
+			cap.ma = 0;
+
+		atomic_notifier_call_chain(&otg->usb2_phy.notifier,
+				USB_EVENT_CHARGER, &cap);
+		otg_dbg(otg, "Notify EM");
+		otg_dbg(otg, "POWER_SUPPLY_CHARGER_EVENT_SUSPEND\n");
+
 		return 0;
-	else if (otg->charging_cap.chrg_type != CHRG_SDP) {
-		otg_err(otg, "%s: currently, chrg type is not SDP!\n",
-				__func__);
+	} else if (ma == OTG_DEVICE_RESUME) {
+		otg_dbg(otg, "Notify EM");
+		otg_dbg(otg, "POWER_SUPPLY_CHARGER_EVENT_CONNECT\n");
+		dwc3_intel_notify_charger_type(otg,
+				POWER_SUPPLY_CHARGER_EVENT_CONNECT);
+
+		return 0;
+	}
+
+	/* For SMIP set case, only need to report 500/900mA */
+	if (data->charging_compliance) {
+		if ((ma != OTG_USB2_500MA) &&
+				(ma != OTG_USB3_900MA))
+			return 0;
+	}
+
+	/* Covert macro to integer number*/
+	switch (ma) {
+	case OTG_USB2_100MA:
+		ma = 100;
+		break;
+	case OTG_USB3_150MA:
+		ma = 150;
+		break;
+	case OTG_USB2_500MA:
+		ma = 500;
+		break;
+	case OTG_USB3_900MA:
+		ma = 900;
+		break;
+	default:
+		otg_err(otg, "Device driver set invalid SDP current value!\n");
 		return -EINVAL;
 	}
 
@@ -312,7 +641,7 @@ static int dwc3_intel_set_power(struct usb_phy *_otg,
 	spin_unlock_irqrestore(&otg->lock, flags);
 
 	dwc3_intel_notify_charger_type(otg,
-			OTG_CHR_STATE_CONNECTED);
+			POWER_SUPPLY_CHARGER_EVENT_CONNECT);
 
 	return 0;
 }
@@ -320,25 +649,33 @@ static int dwc3_intel_set_power(struct usb_phy *_otg,
 int dwc3_intel_enable_vbus(struct dwc_otg2 *otg, int enable)
 {
 	atomic_notifier_call_chain(&otg->usb2_phy.notifier,
-			USB_EVENT_DRIVE_VBUS, &cap);
+			USB_EVENT_DRIVE_VBUS, &enable);
 
 	return 0;
 }
 
 static int dwc3_intel_notify_charger_type(struct dwc_otg2 *otg,
-		enum usb_charger_state state)
+		enum power_supply_charger_event event)
 {
-	struct otg_bc_cap cap;
+	struct power_supply_cable_props cap;
 	int ret = 0;
 	unsigned long flags;
 
-	if (state > OTG_CHR_STATE_HOST) {
-		otg_err(otg, "%s: Invalid usb_charger_state!\n", __func__);
+	if (!charger_detect_enable(otg) &&
+		(otg->charging_cap.chrg_type !=
+		POWER_SUPPLY_CHARGER_TYPE_USB_SDP))
+		return 0;
+
+	if (event > POWER_SUPPLY_CHARGER_EVENT_DISCONNECT) {
+		otg_err(otg,
+		"%s: Invalid power_supply_charger_event!\n", __func__);
 		return -EINVAL;
 	}
 
-	if ((otg->charging_cap.chrg_type ==  CHRG_SDP) &&
-			((otg->charging_cap.ma != 100) &&
+	if ((otg->charging_cap.chrg_type ==
+			POWER_SUPPLY_CHARGER_TYPE_USB_SDP) &&
+			((otg->charging_cap.ma != 0) &&
+			 (otg->charging_cap.ma != 100) &&
 			 (otg->charging_cap.ma != 150) &&
 			 (otg->charging_cap.ma != 500) &&
 			 (otg->charging_cap.ma != 900))) {
@@ -349,7 +686,7 @@ static int dwc3_intel_notify_charger_type(struct dwc_otg2 *otg,
 	spin_lock_irqsave(&otg->lock, flags);
 	cap.chrg_type = otg->charging_cap.chrg_type;
 	cap.ma = otg->charging_cap.ma;
-	cap.chrg_state = state;
+	cap.chrg_evt = event;
 	spin_unlock_irqrestore(&otg->lock, flags);
 
 	atomic_notifier_call_chain(&otg->usb2_phy.notifier, USB_EVENT_CHARGER,
@@ -358,37 +695,74 @@ static int dwc3_intel_notify_charger_type(struct dwc_otg2 *otg,
 	return ret;
 }
 
-enum usb_charger_type dwc3_intel_get_charger_type(struct dwc_otg2 *otg)
+static void dwc3_phy_soft_reset(struct dwc_otg2 *otg)
+{
+	u32 val;
+
+	val = otg_read(otg, GCTL);
+	val |= GCTL_CORESOFTRESET;
+	otg_write(otg, GCTL, val);
+
+	val = otg_read(otg, GUSB3PIPECTL0);
+	val |= GUSB3PIPECTL_PHYSOFTRST;
+	otg_write(otg, GUSB3PIPECTL0, val);
+
+	val = otg_read(otg, GUSB2PHYCFG0);
+	val |= GUSB2PHYCFG_PHYSOFTRST;
+	otg_write(otg, GUSB2PHYCFG0, val);
+
+	msleep(50);
+
+	val = otg_read(otg, GUSB3PIPECTL0);
+	val &= ~GUSB3PIPECTL_PHYSOFTRST;
+	otg_write(otg, GUSB3PIPECTL0, val);
+
+	val = otg_read(otg, GUSB2PHYCFG0);
+	val &= ~GUSB2PHYCFG_PHYSOFTRST;
+	otg_write(otg, GUSB2PHYCFG0, val);
+
+	msleep(100);
+
+	val = otg_read(otg, GCTL);
+	val &= ~GCTL_CORESOFTRESET;
+	otg_write(otg, GCTL, val);
+}
+
+static enum power_supply_charger_cable_type
+			dwc3_intel_get_charger_type(struct dwc_otg2 *otg)
 {
-	u8 val, vdat_det, chgd_serx_dm;
-	unsigned long timeout, interval;
 	int ret;
-	enum usb_charger_type type = CHRG_UNKNOWN;
 	struct usb_phy *phy;
+	u8 val, vdat_det, chgd_serx_dm;
+	unsigned long timeout, interval;
+	enum power_supply_charger_cable_type type =
+		POWER_SUPPLY_CHARGER_TYPE_NONE;
+
+	if (!charger_detect_enable(otg))
+		return cap_record.chrg_type;
 
 	phy = usb_get_phy(USB_PHY_TYPE_USB2);
 	if (!phy) {
 		otg_err(otg, "Get USB2 PHY failed\n");
-		return CHRG_UNKNOWN;
+		return POWER_SUPPLY_CHARGER_TYPE_NONE;
 	}
 
 	/* PHY Enable:
 	 * Power on PHY
 	 */
 	enable_usb_phy(otg, true);
-
-	/* Wait 10ms (~5ms before PHY de-asserts DIR,
-	 * XXus for initial Link reg sync-up).*/
-	msleep(20);
-
-	/* Enable ACA:
-	 * Enable ACA & ID detection logic.
-	 */
-	ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
-			USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0,
-			USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0);
-	if (ret)
-		otg_err(otg, "Fail to enable ACA&ID detection logic\n");
+	dwc3_phy_soft_reset(otg);
+
+	if (is_basin_cove(otg)) {
+		/* Enable ACA:
+		 * Enable ACA & ID detection logic.
+		 */
+		ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
+				USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0,
+				USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0);
+		if (ret)
+			otg_err(otg, "Fail to enable ACA&ID detection logic\n");
+	}
 
 	/* DCD Enable: Change OPMODE to 01 (Non-driving),
 	 * TermSel to 0, &
@@ -444,12 +818,8 @@ enum usb_charger_type dwc3_intel_get_charger_type(struct dwc_otg2 *otg)
 	 * Check ID pin state.
 	 */
 	val = dwc3_intel_get_id(otg);
-	if (val)
-		otg_err(otg, "Fail to enable ACA&ID detection logic\n");
-
-	val &= USBIDSTS_ID_FLOAT_STS;
-	if (!val) {
-		type = aca_check(otg);
+	if (val != RID_FLOAT) {
+		type = dwc3_intel_aca_check(otg);
 		goto cleanup;
 	}
 
@@ -467,7 +837,7 @@ enum usb_charger_type dwc3_intel_get_charger_type(struct dwc_otg2 *otg)
 	 * Else: goto 'Pri Det Enable'.
 	 */
 	if (val == 3) {
-		type = CHRG_SE1;
+		type = POWER_SUPPLY_CHARGER_TYPE_SE1;
 		goto cleanup;
 	}
 
@@ -501,7 +871,7 @@ enum usb_charger_type dwc3_intel_get_charger_type(struct dwc_otg2 *otg)
 	 * If VDAT_DET==1 && CHGD_SERX_DM==0: CDP/DCP
 	 */
 	if (vdat_det == 0 || chgd_serx_dm == 1)
-		type = CHRG_SDP;
+		type = POWER_SUPPLY_CHARGER_TYPE_USB_SDP;
 
 	/* Disable VDPSRC. */
 	usb_phy_io_write(phy, PWCTRL_DP_VSRC_EN, TUSB1211_POWER_CONTROL_CLR);
@@ -509,7 +879,7 @@ enum usb_charger_type dwc3_intel_get_charger_type(struct dwc_otg2 *otg)
 	/* If SDP, goto “Cleanup”.
 	 * Else, goto “Sec Det Enable”
 	 */
-	if (type == CHRG_SDP)
+	if (type == POWER_SUPPLY_CHARGER_TYPE_USB_SDP)
 		goto cleanup;
 
 	/* Sec Det Enable:
@@ -539,9 +909,9 @@ enum usb_charger_type dwc3_intel_get_charger_type(struct dwc_otg2 *otg)
 	 * If VDAT_DET==1: DCP detected.
 	 */
 	if (!val)
-		type = CHRG_CDP;
+		type = POWER_SUPPLY_CHARGER_TYPE_USB_CDP;
 	else
-		type = CHRG_DCP;
+		type = POWER_SUPPLY_CHARGER_TYPE_USB_DCP;
 
 	/* Disable VDMSRC. */
 	usb_phy_io_write(phy, PWCTRL_DP_VSRC_EN, TUSB1211_POWER_CONTROL_CLR);
@@ -552,27 +922,43 @@ enum usb_charger_type dwc3_intel_get_charger_type(struct dwc_otg2 *otg)
 cleanup:
 
 	/* If DCP detected, assert VDPSRC. */
-	if (type == CHRG_DCP)
+	if (type == POWER_SUPPLY_CHARGER_TYPE_USB_DCP)
 		usb_phy_io_write(phy, PWCTRL_SW_CONTROL | PWCTRL_DP_VSRC_EN,
 				TUSB1211_POWER_CONTROL_SET);
 
 	usb_put_phy(phy);
 
-	return type;
+	switch (type) {
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_A:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_B:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_C:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+	case POWER_SUPPLY_CHARGER_TYPE_SE1:
+		dwc_otg_charger_hwdet(true);
+		break;
+	default:
+		break;
+	};
 
+	return type;
 }
 
 static int dwc3_intel_handle_notification(struct notifier_block *nb,
 		unsigned long event, void *data)
 {
+	int state;
+	unsigned long flags, valid_chrg_type;
 	struct dwc_otg2 *otg = dwc3_get_otg();
-	int state, val;
-	unsigned long flags;
+	struct power_supply_cable_props *cap;
 
 	if (!otg)
 		return NOTIFY_BAD;
 
-	val = *(int *)data;
+	valid_chrg_type = POWER_SUPPLY_CHARGER_TYPE_USB_SDP |
+		POWER_SUPPLY_CHARGER_TYPE_USB_CDP |
+		POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK;
 
 	spin_lock_irqsave(&otg->lock, flags);
 	switch (event) {
@@ -581,16 +967,50 @@ static int dwc3_intel_handle_notification(struct notifier_block *nb,
 		state = NOTIFY_OK;
 		break;
 	case USB_EVENT_VBUS:
-		if (val)
+		if (*(int *)data) {
 			otg->otg_events |= OEVT_B_DEV_SES_VLD_DET_EVNT;
-		else
+			otg->otg_events &= ~OEVT_A_DEV_SESS_END_DET_EVNT;
+		} else {
+			otg->otg_events |= OEVT_A_DEV_SESS_END_DET_EVNT;
+			otg->otg_events &= ~OEVT_B_DEV_SES_VLD_DET_EVNT;
+		}
+		state = NOTIFY_OK;
+		break;
+	case USB_EVENT_CHARGER:
+		if (charger_detect_enable(otg)) {
+			state = NOTIFY_DONE;
+			goto done;
+		}
+		cap = (struct power_supply_cable_props *)data;
+		if (!(cap->chrg_type & valid_chrg_type)) {
+			otg_err(otg, "Invalid charger type!\n");
+			state = NOTIFY_BAD;
+		}
+		if (cap->chrg_evt == POWER_SUPPLY_CHARGER_EVENT_CONNECT) {
+			otg->otg_events |= OEVT_B_DEV_SES_VLD_DET_EVNT;
+			otg->otg_events &= ~OEVT_A_DEV_SESS_END_DET_EVNT;
+
+			cap_record.chrg_type = cap->chrg_type;
+			cap_record.ma = cap->ma;
+			cap_record.chrg_evt = cap->chrg_evt;
+		} else if (cap->chrg_evt ==
+				POWER_SUPPLY_CHARGER_EVENT_DISCONNECT) {
 			otg->otg_events |= OEVT_A_DEV_SESS_END_DET_EVNT;
+			otg->otg_events &= ~OEVT_B_DEV_SES_VLD_DET_EVNT;
+
+			cap_record.chrg_type = POWER_SUPPLY_CHARGER_TYPE_NONE;
+			cap_record.ma = 0;
+			cap_record.chrg_evt =
+				POWER_SUPPLY_CHARGER_EVENT_DISCONNECT;
+		}
 		state = NOTIFY_OK;
 		break;
 	default:
 		otg_dbg(otg, "DWC OTG Notify unknow notify message\n");
 		state = NOTIFY_DONE;
 	}
+
+done:
 	dwc3_wakeup_otg_thread(otg);
 	spin_unlock_irqrestore(&otg->lock, flags);
 
@@ -600,15 +1020,81 @@ static int dwc3_intel_handle_notification(struct notifier_block *nb,
 
 int dwc3_intel_prepare_start_host(struct dwc_otg2 *otg)
 {
-	if (!is_hybridvp(otg))
+	if (!is_hybridvp(otg)) {
 		enable_usb_phy(otg, true);
+		usb2phy_eye_optimization(otg);
+		disable_phy_auto_resume(otg);
+	}
+
 	return 0;
 }
 
 int dwc3_intel_prepare_start_peripheral(struct dwc_otg2 *otg)
 {
-	if (!is_hybridvp(otg))
+	if (!is_hybridvp(otg)) {
 		enable_usb_phy(otg, true);
+		usb2phy_eye_optimization(otg);
+		disable_phy_auto_resume(otg);
+	}
+
+	return 0;
+}
+
+int dwc3_intel_suspend(struct dwc_otg2 *otg)
+{
+	struct pci_dev *pci_dev;
+	pci_power_t state = PCI_D3cold;
+
+	if (!otg)
+		return 0;
+
+	pci_dev = to_pci_dev(otg->dev);
+
+	if (otg->state == DWC_STATE_B_PERIPHERAL ||
+			otg->state == DWC_STATE_A_HOST)
+		state = PCI_D3hot;
+
+	set_sus_phy(otg, 1);
+
+	if (pci_save_state(pci_dev)) {
+		otg_err(otg, "pci_save_state failed!\n");
+		return -EIO;
+	}
+
+	pci_disable_device(pci_dev);
+	pci_set_power_state(pci_dev, state);
+
+	return 0;
+}
+
+int dwc3_intel_resume(struct dwc_otg2 *otg)
+{
+	struct pci_dev *pci_dev;
+
+	if (!otg)
+		return 0;
+
+	pci_dev = to_pci_dev(otg->dev);
+
+	/* From synopsys spec 12.2.11.
+	 * Software cannot access memory-mapped I/O space
+	 * for 10ms. Delay 5 ms here should be enough. Too
+	 * long a delay causes hibernation exit failure.
+	 */
+	mdelay(5);
+
+	pci_restore_state(pci_dev);
+	if (pci_enable_device(pci_dev) < 0) {
+		otg_err(otg, "pci_enable_device failed.\n");
+		return -EIO;
+	}
+
+	set_sus_phy(otg, 0);
+
+	/* Delay 1ms waiting PHY clock debounce.
+	 * Without this debounce, will met fabric error randomly.
+	 **/
+	mdelay(1);
 
 	return 0;
 }
@@ -625,6 +1111,10 @@ struct dwc3_otg_hw_ops dwc3_intel_otg_pdata = {
 	.otg_notifier_handler = dwc3_intel_handle_notification,
 	.prepare_start_peripheral = dwc3_intel_prepare_start_peripheral,
 	.prepare_start_host = dwc3_intel_prepare_start_host,
+	.notify_charger_type = dwc3_intel_notify_charger_type,
+
+	.suspend = dwc3_intel_suspend,
+	.resume = dwc3_intel_resume,
 };
 
 static int __init dwc3_intel_init(void)
diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c
index 2357c4e5dc43..2a367986c59b 100644
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@ -209,6 +209,10 @@ static DEFINE_PCI_DEVICE_TABLE(dwc3_pci_id_table) = {
 	{
 		PCI_DEVICE(PCI_VENDOR_ID_SYNOPSYS,
 				PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3),
+		/* FIXME: move to pci_ids.h */
+	}, {
+#define PCI_DEVICE_ID_INTEL_DWC_TNG	0x119e
+		PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_DWC_TNG),
 	},
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BYT), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_MRFLD), },
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index 6e70c88b25fb..a1b150cfefd8 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -49,10 +49,16 @@
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
+#include <linux/usb/phy.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/ulpi.h>
 
 #include "core.h"
 #include "gadget.h"
 #include "io.h"
+#include "otg.h"
+
+static LIST_HEAD(ebc_io_ops);
 
 /**
  * dwc3_gadget_set_test_mode - Enables USB2 Test Modes
@@ -267,7 +273,7 @@ void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,
 
 	if (dwc->ep0_bounced && dep->number == 0)
 		dwc->ep0_bounced = false;
-	else
+	else if (!dep->ebc)
 		usb_gadget_unmap_request(&dwc->gadget, &req->request,
 				req->direction);
 
@@ -339,7 +345,7 @@ int dwc3_send_gadget_ep_cmd(struct dwc3 *dwc, unsigned ep,
 		unsigned cmd, struct dwc3_gadget_ep_cmd_params *params)
 {
 	struct dwc3_ep		*dep = dwc->eps[ep];
-	u32			timeout = 500;
+	u32			timeout = 5000;
 	u32			reg;
 
 	dev_vdbg(dwc->dev, "%s: cmd '%s' params %08x %08x %08x\n",
@@ -392,9 +398,13 @@ static int dwc3_alloc_trb_pool(struct dwc3_ep *dep)
 	if (dep->number == 0 || dep->number == 1)
 		return 0;
 
-	dep->trb_pool = dma_alloc_coherent(dwc->dev,
-			sizeof(struct dwc3_trb) * DWC3_TRB_NUM,
-			&dep->trb_pool_dma, GFP_KERNEL);
+	if (dep->ebc)
+		dep->trb_pool = dep->ebc->alloc_static_trb_pool(
+				&dep->trb_pool_dma);
+	else
+		dep->trb_pool = dma_alloc_coherent(dwc->dev,
+				sizeof(struct dwc3_trb) * DWC3_TRB_NUM,
+				&dep->trb_pool_dma, GFP_KERNEL);
 	if (!dep->trb_pool) {
 		dev_err(dep->dwc->dev, "failed to allocate trb pool for %s\n",
 				dep->name);
@@ -408,7 +418,11 @@ static void dwc3_free_trb_pool(struct dwc3_ep *dep)
 {
 	struct dwc3		*dwc = dep->dwc;
 
-	dma_free_coherent(dwc->dev, sizeof(struct dwc3_trb) * DWC3_TRB_NUM,
+	if (dep->ebc)
+		dep->ebc->free_static_trb_pool();
+	else
+		dma_free_coherent(dwc->dev,
+			sizeof(struct dwc3_trb) * DWC3_TRB_NUM,
 			dep->trb_pool, dep->trb_pool_dma);
 
 	dep->trb_pool = NULL;
@@ -441,35 +455,58 @@ static int dwc3_gadget_start_config(struct dwc3 *dwc, struct dwc3_ep *dep)
 static int dwc3_gadget_set_ep_config(struct dwc3 *dwc, struct dwc3_ep *dep,
 		const struct usb_endpoint_descriptor *desc,
 		const struct usb_ss_ep_comp_descriptor *comp_desc,
-		bool ignore)
+		bool ignore, u32 cfg_action)
 {
 	struct dwc3_gadget_ep_cmd_params params;
 
 	memset(&params, 0x00, sizeof(params));
 
 	params.param0 = DWC3_DEPCFG_EP_TYPE(usb_endpoint_type(desc))
-		| DWC3_DEPCFG_MAX_PACKET_SIZE(usb_endpoint_maxp(desc));
+		| DWC3_DEPCFG_MAX_PACKET_SIZE(usb_endpoint_maxp(desc))
+		| cfg_action;
 
-	/* Burst size is only needed in SuperSpeed mode */
-	if (dwc->gadget.speed == USB_SPEED_SUPER) {
-		u32 burst = dep->endpoint.maxburst - 1;
+	if (dep->ebc) {
+		if (dwc->gadget.speed == USB_SPEED_SUPER) {
+			u32 burst = 0;
 
-		params.param0 |= DWC3_DEPCFG_BURST_SIZE(burst);
-	}
+			params.param0 |= DWC3_DEPCFG_BURST_SIZE(burst);
+		}
 
-	if (ignore)
 		params.param0 |= DWC3_DEPCFG_IGN_SEQ_NUM;
 
-	params.param1 = DWC3_DEPCFG_XFER_COMPLETE_EN
-		| DWC3_DEPCFG_XFER_NOT_READY_EN;
+		params.param1 = DWC3_DEPCFG_EBC_MODE_EN;
+
+		if (dep->ebc->is_ondemand)
+			params.param1 |= DWC3_DEPCFG_XFER_NOT_READY_EN;
+
+		dep->stream_capable = false;
+	} else {
+		/* Burst size is only needed in SuperSpeed mode */
+		if (dwc->gadget.speed == USB_SPEED_SUPER) {
+			/* In case a function forgets to set maxburst, maxburst
+			 * may be still 0, and we shouldn't minus 1 for it.
+			 */
+			u32 burst = dep->endpoint.maxburst ?
+					dep->endpoint.maxburst - 1 : 0;
+
+			params.param0 |= DWC3_DEPCFG_BURST_SIZE(burst);
+		}
+
+		if (ignore)
+			params.param0 |= DWC3_DEPCFG_IGN_SEQ_NUM;
+
+		params.param1 = DWC3_DEPCFG_XFER_COMPLETE_EN
+			| DWC3_DEPCFG_XFER_NOT_READY_EN;
 
-	if (usb_ss_max_streams(comp_desc) && usb_endpoint_xfer_bulk(desc)) {
-		params.param1 |= DWC3_DEPCFG_STREAM_CAPABLE
-			| DWC3_DEPCFG_STREAM_EVENT_EN;
-		dep->stream_capable = true;
+		if (usb_ss_max_streams(comp_desc) &&
+				usb_endpoint_xfer_bulk(desc)) {
+			params.param1 |= DWC3_DEPCFG_STREAM_CAPABLE
+				| DWC3_DEPCFG_STREAM_EVENT_EN;
+			dep->stream_capable = true;
+		}
 	}
 
-	if (usb_endpoint_xfer_isoc(desc))
+	if (usb_endpoint_xfer_isoc(desc) || usb_endpoint_is_bulk_out(desc))
 		params.param1 |= DWC3_DEPCFG_XFER_IN_PROGRESS_EN;
 
 	/*
@@ -492,6 +529,56 @@ static int dwc3_gadget_set_ep_config(struct dwc3 *dwc, struct dwc3_ep *dep,
 		dep->interval = 1 << (desc->bInterval - 1);
 	}
 
+	if (cfg_action == DWC3_DEPCFG_ACTION_RESTORE)
+		params.param2 = dep->ep_state;
+
+	return dwc3_send_gadget_ep_cmd(dwc, dep->number,
+			DWC3_DEPCMD_SETEPCONFIG, &params);
+}
+
+static int dwc3_gadget_update_ebc_ep_config(struct dwc3 *dwc,
+		struct dwc3_ep *dep,
+		const struct usb_endpoint_descriptor *desc,
+		const struct usb_ss_ep_comp_descriptor *comp_desc,
+		bool ignore_nrdy)
+{
+	u16	maxp;
+	struct dwc3_gadget_ep_cmd_params params;
+
+	if (!dep->ebc)
+		return -EINVAL;
+
+	memset(&params, 0x00, sizeof(params));
+
+	maxp = usb_endpoint_maxp(desc);
+
+	params.param0 =	DWC3_DEPCFG_EP_TYPE(usb_endpoint_type(desc))
+		| DWC3_DEPCFG_MAX_PACKET_SIZE(maxp)
+		| DWC3_DEPCFG_ACTION_MODIFY;
+
+	if (dwc->gadget.speed == USB_SPEED_SUPER) {
+		u32 burst = 0;
+
+		params.param0 |= DWC3_DEPCFG_BURST_SIZE(burst);
+	}
+	params.param0 |= DWC3_DEPCFG_IGN_SEQ_NUM;
+	params.param1 = DWC3_DEPCFG_EBC_MODE_EN;
+
+	if (!ignore_nrdy)
+		params.param1 |= DWC3_DEPCFG_XFER_NOT_READY_EN;
+
+	dep->stream_capable = false;
+
+	params.param1 |= DWC3_DEPCFG_EP_NUMBER(dep->number);
+
+	if (dep->direction)
+		params.param0 |= DWC3_DEPCFG_FIFO_NUMBER(dep->number >> 1);
+
+	if (desc->bInterval) {
+		params.param1 |= DWC3_DEPCFG_BINTERVAL_M1(desc->bInterval - 1);
+		dep->interval = 1 << (desc->bInterval - 1);
+	}
+
 	return dwc3_send_gadget_ep_cmd(dwc, dep->number,
 			DWC3_DEPCMD_SETEPCONFIG, &params);
 }
@@ -530,7 +617,8 @@ static int __dwc3_gadget_ep_enable(struct dwc3_ep *dep,
 			return ret;
 	}
 
-	ret = dwc3_gadget_set_ep_config(dwc, dep, desc, comp_desc, ignore);
+	ret = dwc3_gadget_set_ep_config(dwc, dep, desc, comp_desc, ignore,
+				DWC3_DEPCFG_ACTION_INIT);
 	if (ret)
 		return ret;
 
@@ -551,6 +639,9 @@ static int __dwc3_gadget_ep_enable(struct dwc3_ep *dep,
 		reg |= DWC3_DALEPENA_EP(dep->number);
 		dwc3_writel(dwc->regs, DWC3_DALEPENA, reg);
 
+		if (dep->ebc)
+			dwc->is_ebc = 1;
+
 		if (!usb_endpoint_xfer_isoc(desc))
 			return 0;
 
@@ -569,13 +660,13 @@ static int __dwc3_gadget_ep_enable(struct dwc3_ep *dep,
 	return 0;
 }
 
-static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum);
+static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum, int forcerm);
 static void dwc3_remove_requests(struct dwc3 *dwc, struct dwc3_ep *dep)
 {
 	struct dwc3_request		*req;
 
 	if (!list_empty(&dep->req_queued)) {
-		dwc3_stop_active_transfer(dwc, dep->number);
+		dwc3_stop_active_transfer(dwc, dep->number, 1);
 
 		/* - giveback all requests to gadget driver */
 		while (!list_empty(&dep->req_queued)) {
@@ -603,7 +694,15 @@ static void dwc3_remove_requests(struct dwc3 *dwc, struct dwc3_ep *dep)
 static int __dwc3_gadget_ep_disable(struct dwc3_ep *dep)
 {
 	struct dwc3		*dwc = dep->dwc;
-	u32			reg;
+	struct ebc_io		*ebc = dep->ebc;
+        u32			reg;
+
+	if (ebc) {
+		dwc->is_ebc = 0;
+
+		if (ebc->is_ondemand && ebc->xfer_stop)
+			ebc->xfer_stop();
+	}
 
 	dwc3_remove_requests(dwc, dep);
 
@@ -621,6 +720,10 @@ static int __dwc3_gadget_ep_disable(struct dwc3_ep *dep)
 	dep->type = 0;
 	dep->flags = 0;
 
+	/* set normal endpoint maxpacket to default value */
+	if (dep->number > 1)
+		dep->endpoint.maxpacket = 1024;
+
 	return 0;
 }
 
@@ -707,7 +810,8 @@ static int dwc3_gadget_ep_disable(struct usb_ep *ep)
 	dep = to_dwc3_ep(ep);
 	dwc = dep->dwc;
 
-	if (!(dep->flags & DWC3_EP_ENABLED)) {
+	if (!(dep->flags & DWC3_EP_ENABLED) &&
+		dep->flags != DWC3_EP_HIBERNATION) {
 		dev_WARN_ONCE(dwc->dev, true, "%s is already disabled\n",
 				dep->name);
 		return 0;
@@ -758,7 +862,8 @@ static void dwc3_gadget_ep_free_request(struct usb_ep *ep,
  */
 static void dwc3_prepare_one_trb(struct dwc3_ep *dep,
 		struct dwc3_request *req, dma_addr_t dma,
-		unsigned length, unsigned last, unsigned chain, unsigned node)
+		unsigned length, unsigned last, unsigned chain,
+		unsigned node, unsigned csp)
 {
 	struct dwc3		*dwc = dep->dwc;
 	struct dwc3_trb		*trb;
@@ -825,6 +930,12 @@ static void dwc3_prepare_one_trb(struct dwc3_ep *dep,
 	if (chain)
 		trb->ctrl |= DWC3_TRB_CTRL_CHN;
 
+	if (csp) {
+		trb->ctrl |= DWC3_TRB_CTRL_CSP;
+		trb->ctrl |= DWC3_TRB_CTRL_IOC;
+	}
+
+
 	if (usb_endpoint_xfer_bulk(dep->endpoint.desc) && dep->stream_capable)
 		trb->ctrl |= DWC3_TRB_CTRL_SID_SOFN(req->request.stream_id);
 
@@ -889,7 +1000,8 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 	}
 
 	/* The last TRB is a link TRB, not used for xfer */
-	if ((trbs_left <= 1) && usb_endpoint_xfer_isoc(dep->endpoint.desc))
+	if ((trbs_left <= 1) && usb_endpoint_xfer_isoc(dep->endpoint.desc) &&
+		(dep->free_slot & DWC3_TRB_MASK) == DWC3_TRB_NUM - 1)
 		return;
 
 	list_for_each_entry_safe(req, n, &dep->request_list, list) {
@@ -924,7 +1036,7 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 					chain = false;
 
 				dwc3_prepare_one_trb(dep, req, dma, length,
-						last_one, chain, i);
+						last_one, chain, i, false);
 
 				if (last_one)
 					break;
@@ -933,6 +1045,8 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 			if (last_one)
 				break;
 		} else {
+			unsigned csp = false;
+
 			dma = req->request.dma;
 			length = req->request.length;
 			trbs_left--;
@@ -944,8 +1058,13 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 			if (list_is_last(&req->list, &dep->request_list))
 				last_one = 1;
 
+			/* For bulk-out ep, if req is the short packet and
+			 * not the last one, enable CSP. */
+			if (req->short_packet && !last_one)
+				csp = true;
+
 			dwc3_prepare_one_trb(dep, req, dma, length,
-					last_one, false, 0);
+					last_one, false, 0, csp);
 
 			if (last_one)
 				break;
@@ -953,6 +1072,115 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 	}
 }
 
+/*
+ * dwc3_prepare_ebc_trbs - setup TRBs from DvC endpoint requests
+ * @dep: endpoint for which requests are being prepared
+ * @starting: true if the endpoint is idle and no requests are queued.
+ *
+ * The functions goes through the requests list and setups TRBs for the
+ * transfers.
+ */
+static void dwc3_prepare_ebc_trbs(struct dwc3_ep *dep,
+		bool starting)
+{
+	struct dwc3_request	*req, *n;
+	struct dwc3_trb		*trb_st_hw;
+	struct dwc3_trb		*trb_link;
+	struct dwc3_trb		*trb;
+	u32			trbs_left;
+	u32			trbs_num;
+	u32			trbs_mask;
+
+	/* BUILD_BUG_ON_NOT_POWER_OF_2(DWC3_TRB_NUM);*/
+	trbs_num = dep->ebc->static_trb_pool_size;
+	trbs_mask = trbs_num - 1;
+
+	/* the first request must not be queued */
+	trbs_left = (dep->busy_slot - dep->free_slot) & trbs_mask;
+	/*
+	 * if busy & slot are equal than it is either full or empty. If we are
+	 * starting to proceed requests then we are empty. Otherwise we ar
+	 * full and don't do anything
+	 */
+	if (!trbs_left) {
+		if (!starting)
+			return;
+		trbs_left = trbs_num;
+		dep->busy_slot = 0;
+		dep->free_slot = 0;
+	}
+
+	/* The tailed TRB is a link TRB, not used for xfer */
+	if ((trbs_left <= 1))
+		return;
+
+	list_for_each_entry_safe(req, n, &dep->request_list, list) {
+		unsigned int last_one = 0;
+		unsigned int cur_slot;
+
+		/* revisit: dont use specific TRB buffer for Debug class? */
+		trb = &dep->trb_pool[dep->free_slot & trbs_mask];
+		cur_slot = dep->free_slot;
+		dep->free_slot++;
+
+		/* Skip the LINK-TRB */
+		if (((cur_slot & trbs_mask) == trbs_num - 1))
+			continue;
+
+		dwc3_gadget_move_request_queued(req);
+		trbs_left--;
+
+		/* Is our TRB pool empty? */
+		if (!trbs_left)
+			last_one = 1;
+		/* Is this the last request? */
+		if (list_empty(&dep->request_list))
+			last_one = 1;
+
+		req->trb = trb;
+		req->trb_dma = dwc3_trb_dma_offset(dep, trb);
+
+		trb->size = DWC3_TRB_SIZE_LENGTH(req->request.length);
+		trb->bpl = lower_32_bits(req->request.dma);
+		trb->bph = upper_32_bits(req->request.dma);
+
+		switch (usb_endpoint_type(dep->endpoint.desc)) {
+		case USB_ENDPOINT_XFER_BULK:
+			trb->ctrl = DWC3_TRBCTL_NORMAL;
+			break;
+
+		case USB_ENDPOINT_XFER_CONTROL:
+		case USB_ENDPOINT_XFER_ISOC:
+		case USB_ENDPOINT_XFER_INT:
+		default:
+			/*
+			 * This is only possible with faulty memory because we
+			 * checked it already :)
+			 */
+			BUG();
+		}
+
+		trb->ctrl |= DWC3_TRB_CTRL_HWO | DWC3_TRB_CTRL_CHN;
+
+		if (last_one) {
+			if (trbs_left >= 1) {
+				trb_st_hw = &dep->trb_pool[0];
+
+				trb_link = &dep->trb_pool[dep->free_slot &
+						trbs_mask];
+				trb_link->bpl = lower_32_bits(
+					dwc3_trb_dma_offset(dep, trb_st_hw));
+				trb_link->bph = upper_32_bits(
+					dwc3_trb_dma_offset(dep, trb_st_hw));
+				trb_link->ctrl = DWC3_TRBCTL_LINK_TRB;
+				trb_link->ctrl |= DWC3_TRB_CTRL_HWO;
+				trb_link->size = 0;
+			}
+			break;
+		}
+	}
+}
+
 static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 		int start_new)
 {
@@ -973,8 +1201,11 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 	 * new requests as we try to set the IOC bit only on the last request.
 	 */
 	if (start_new) {
-		if (list_empty(&dep->req_queued))
-			dwc3_prepare_trbs(dep, start_new);
+		if (dep->ebc)
+			dwc3_prepare_ebc_trbs(dep, start_new);
+		else
+			if (list_empty(&dep->req_queued))
+				dwc3_prepare_trbs(dep, start_new);
 
 		/* req points to the first request which will be sent */
 		req = next_request(&dep->req_queued);
@@ -1011,8 +1242,9 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 		 * here and stop, unmap, free and del each of the linked
 		 * requests instead of what we do now.
 		 */
-		usb_gadget_unmap_request(&dwc->gadget, &req->request,
-				req->direction);
+		if (!dep->ebc)
+			usb_gadget_unmap_request(&dwc->gadget, &req->request,
+					req->direction);
 		list_del(&req->list);
 		return ret;
 	}
@@ -1025,6 +1257,26 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 		WARN_ON_ONCE(!dep->resource_index);
 	}
 
+	if (dep->ebc) {
+		if (dep->ebc->is_ondemand == 1) {
+			ret = dwc3_gadget_update_ebc_ep_config(dwc, dep,
+				dep->endpoint.desc, dep->comp_desc, true);
+
+			if (ret < 0) {
+				dev_dbg(dwc->dev,
+					"DEPCFG command failed on %s\n",
+					dep->name);
+				return ret;
+			}
+			dev_dbg(dwc->dev,
+				"successfully udpated DEPCFG command on %s\n",
+				dep->name);
+		}
+
+		if (dep->ebc->xfer_start)
+			dep->ebc->xfer_start();
+	}
+
 	return 0;
 }
 
@@ -1067,6 +1319,29 @@ static int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)
 	req->direction		= dep->direction;
 	req->epnum		= dep->number;
 
+	/* specific handling for debug class */
+	if (dep->ebc) {
+		list_add_tail(&req->list, &dep->request_list);
+
+		if ((dep->ebc->is_ondemand == 1) &&
+			(!(dep->flags & DWC3_EP_PENDING_REQUEST))) {
+			dev_dbg(dwc->dev, "%s: delayed to kick ebc transfers\n",
+				dep->name);
+			return 0;
+		}
+
+		if (dep->flags & DWC3_EP_BUSY) {
+			dwc3_stop_active_transfer(dwc, dep->number, 1);
+			dep->flags = DWC3_EP_ENABLED;
+		}
+
+		ret = __dwc3_gadget_kick_transfer(dep, 0, true);
+		if (ret)
+			dev_dbg(dwc->dev, "%s: failed to kick transfers\n",
+					dep->name);
+		return ret;
+	}
+
 	/*
 	 * We only add to our list of requests now and
 	 * start consuming the list once we get XferNotReady
@@ -1106,7 +1381,7 @@ static int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)
 		 */
 		if (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {
 			if (list_empty(&dep->req_queued)) {
-				dwc3_stop_active_transfer(dwc, dep->number);
+				dwc3_stop_active_transfer(dwc, dep->number, 1);
 				dep->flags = DWC3_EP_ENABLED;
 			}
 			return 0;
@@ -1150,16 +1425,28 @@ static int dwc3_gadget_ep_queue(struct usb_ep *ep, struct usb_request *request,
 
 	int				ret;
 
+	spin_lock_irqsave(&dwc->lock, flags);
 	if (!dep->endpoint.desc) {
 		dev_dbg(dwc->dev, "trying to queue request %p to disabled %s\n",
 				request, ep->name);
+		spin_unlock_irqrestore(&dwc->lock, flags);
 		return -ESHUTDOWN;
 	}
 
 	dev_vdbg(dwc->dev, "queing request %p to %s length %d\n",
 			request, ep->name, request->length);
 
-	spin_lock_irqsave(&dwc->lock, flags);
+	/* pad OUT endpoint buffer to MaxPacketSize per databook requirement*/
+	req->short_packet = false;
+	if (!IS_ALIGNED(request->length, ep->desc->wMaxPacketSize)
+		&& !(dep->number & 1) && (dep->number != DWC3_EP_EBC_OUT_NB)) {
+		request->length = roundup(request->length,
+					(u32) ep->desc->wMaxPacketSize);
+		/* set flag for bulk-out short request */
+		if (usb_endpoint_is_bulk_out(dep->endpoint.desc))
+			req->short_packet = true;
+	}
+
 	ret = __dwc3_gadget_ep_queue(dep, req);
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
@@ -1192,7 +1479,7 @@ static int dwc3_gadget_ep_dequeue(struct usb_ep *ep,
 		}
 		if (r == req) {
 			/* wait until it is processed */
-			dwc3_stop_active_transfer(dwc, dep->number);
+			dwc3_stop_active_transfer(dwc, dep->number, 1);
 			goto out1;
 		}
 		dev_err(dwc->dev, "request %p was not queued to %s\n",
@@ -1424,13 +1711,44 @@ static int dwc3_gadget_set_selfpowered(struct usb_gadget *g,
 	return 0;
 }
 
+static int __dwc3_gadget_run_stop(struct dwc3 *dwc, int is_on)
+{
+	u32			reg;
+	u32			timeout = 500;
+
+	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+	if (is_on)
+		reg |= DWC3_DCTL_RUN_STOP;
+	else
+		reg &= ~DWC3_DCTL_RUN_STOP;
+	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
+		if (is_on) {
+			if (!(reg & DWC3_DSTS_DEVCTRLHLT))
+				break;
+		} else {
+			if (reg & DWC3_DSTS_DEVCTRLHLT)
+				break;
+		}
+		timeout--;
+		if (!timeout)
+			return -ETIMEDOUT;
+		udelay(1);
+	} while (1);
+
+	return 0;
+}
+
 static int dwc3_gadget_run_stop(struct dwc3 *dwc, int is_on)
 {
 	u32			reg;
 	u32			timeout = 500;
+	struct usb_phy		*usb_phy;
 
 	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-	if (is_on) {
+	if (is_on && !dwc->pullups_connected) {
 		if (dwc->revision <= DWC3_REVISION_187A) {
 			reg &= ~DWC3_DCTL_TRGTULST_MASK;
 			reg |= DWC3_DCTL_TRGTULST_RX_DET;
@@ -1440,10 +1758,20 @@ static int dwc3_gadget_run_stop(struct dwc3 *dwc, int is_on)
 			reg &= ~DWC3_DCTL_KEEP_CONNECT;
 		reg |= DWC3_DCTL_RUN_STOP;
 		dwc->pullups_connected = true;
-	} else {
+	} else if (!is_on && dwc->pullups_connected) {
 		reg &= ~DWC3_DCTL_RUN_STOP;
 		dwc->pullups_connected = false;
-	}
+
+		/* WORKAROUND: reset PHY via FUNC_CTRL before disconnect
+		 * to avoid PHY hang
+		 */
+		usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
+		if (usb_phy)
+			usb_phy_io_write(usb_phy,
+					0x6D, ULPI_FUNC_CTRL);
+		usb_put_phy(usb_phy);
+	} else
+		return 0;
 
 	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
 
@@ -1494,6 +1822,7 @@ static void dwc3_gadget_enable_irq(struct dwc3 *dwc)
 			DWC3_DEVTEN_EVNTOVERFLOWEN |
 			DWC3_DEVTEN_CMDCMPLTEN |
 			DWC3_DEVTEN_ERRTICERREN |
+			DWC3_DEVTEN_HIBERNATIONREQEVTEN |
 			DWC3_DEVTEN_WKUPEVTEN |
 			DWC3_DEVTEN_ULSTCNGEN |
 			DWC3_DEVTEN_CONNECTDONEEN |
@@ -1512,37 +1841,12 @@ static void dwc3_gadget_disable_irq(struct dwc3 *dwc)
 static irqreturn_t dwc3_interrupt(int irq, void *_dwc);
 static irqreturn_t dwc3_thread_interrupt(int irq, void *_dwc);
 
-static int dwc3_gadget_start(struct usb_gadget *g,
-		struct usb_gadget_driver *driver)
+static int dwc3_init_for_enumeration(struct dwc3 *dwc)
 {
-	struct dwc3		*dwc = gadget_to_dwc(g);
 	struct dwc3_ep		*dep;
-	unsigned long		flags;
 	int			ret = 0;
-	int			irq;
 	u32			reg;
 
-	irq = platform_get_irq(to_platform_device(dwc->dev), 0);
-	ret = request_threaded_irq(irq, dwc3_interrupt, dwc3_thread_interrupt,
-			IRQF_SHARED | IRQF_ONESHOT, "dwc3", dwc);
-	if (ret) {
-		dev_err(dwc->dev, "failed to request irq #%d --> %d\n",
-				irq, ret);
-		goto err0;
-	}
-
-	spin_lock_irqsave(&dwc->lock, flags);
-
-	if (dwc->gadget_driver) {
-		dev_err(dwc->dev, "%s is already bound to %s\n",
-				dwc->gadget.name,
-				dwc->gadget_driver->driver.name);
-		ret = -EBUSY;
-		goto err1;
-	}
-
-	dwc->gadget_driver	= driver;
-
 	reg = dwc3_readl(dwc->regs, DWC3_DCFG);
 	reg &= ~(DWC3_DCFG_SPEED_MASK);
 
@@ -1565,6 +1869,7 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 		reg |= dwc->maximum_speed;
 	dwc3_writel(dwc->regs, DWC3_DCFG, reg);
 
+	dwc->is_ebc = 0;
 	dwc->start_config_issued = false;
 
 	/* Start with SuperSpeed Default */
@@ -1574,14 +1879,14 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
 	if (ret) {
 		dev_err(dwc->dev, "failed to enable %s\n", dep->name);
-		goto err2;
+		return ret;
 	}
 
 	dep = dwc->eps[1];
 	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
 	if (ret) {
 		dev_err(dwc->dev, "failed to enable %s\n", dep->name);
-		goto err3;
+		goto err0;
 	}
 
 	/* begin to receive SETUP packets */
@@ -1590,20 +1895,74 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 
 	dwc3_gadget_enable_irq(dwc);
 
+	return 0;
+err0:
+	__dwc3_gadget_ep_disable(dwc->eps[0]);
+
+	return ret;
+}
+
+static int dwc3_gadget_start(struct usb_gadget *g,
+		struct usb_gadget_driver *driver)
+{
+	struct dwc3		*dwc = gadget_to_dwc(g);
+	unsigned long		flags;
+	int			ret = 0;
+	int			irq = 0;
+	struct usb_phy		*usb_phy;
+
+	if (dwc->is_otg) {
+		usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
+		if (!usb_phy) {
+			dev_err(dwc->dev, "OTG driver not available\n");
+			ret = -ENODEV;
+			goto err0;
+		}
+
+		otg_set_peripheral(usb_phy->otg, &dwc->gadget);
+		usb_put_phy(usb_phy);
+	} else {
+		irq = platform_get_irq(to_platform_device(dwc->dev), 0);
+		ret = request_threaded_irq(irq, dwc3_interrupt,
+				dwc3_thread_interrupt, IRQF_SHARED,
+				"dwc3", dwc);
+		if (ret) {
+			dev_err(dwc->dev, "failed to request irq #%d --> %d\n",
+					irq, ret);
+			goto err0;
+		}
+	}
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	if (dwc->gadget_driver) {
+		dev_err(dwc->dev, "%s is already bound to %s\n",
+				dwc->gadget.name,
+				dwc->gadget_driver->driver.name);
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	dwc->gadget_driver	= driver;
+
+	if (!dwc->is_otg) {
+		ret = dwc3_init_for_enumeration(dwc);
+		if (ret)
+			goto err2;
+	}
+
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	return 0;
 
-err3:
-	__dwc3_gadget_ep_disable(dwc->eps[0]);
-
 err2:
 	dwc->gadget_driver = NULL;
 
 err1:
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
-	free_irq(irq, dwc);
+	if (!dwc->is_otg)
+		free_irq(irq, dwc);
 
 err0:
 	return ret;
@@ -1632,21 +1991,67 @@ static int dwc3_gadget_stop(struct usb_gadget *g,
 	return 0;
 }
 
-static const struct usb_gadget_ops dwc3_gadget_ops = {
-	.get_frame		= dwc3_gadget_get_frame,
-	.wakeup			= dwc3_gadget_wakeup,
-	.set_selfpowered	= dwc3_gadget_set_selfpowered,
-	.pullup			= dwc3_gadget_pullup,
-	.udc_start		= dwc3_gadget_start,
-	.udc_stop		= dwc3_gadget_stop,
-};
+static int __dwc3_vbus_draw(struct dwc3 *dwc, unsigned ma)
+{
+	int		ret;
+	struct usb_phy	*usb_phy;
 
-/* -------------------------------------------------------------------------- */
+	usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (!usb_phy) {
+		dev_err(dwc->dev, "OTG driver not available\n");
+		return -ENODEV;
+	}
 
-static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
+	ret = usb_phy_set_power(usb_phy, ma);
+	usb_put_phy(usb_phy);
+
+	return ret;
+}
+
+static int dwc3_vbus_draw(struct usb_gadget *g, unsigned ma)
+{
+	unsigned	ma_otg = 0;
+	struct dwc3	*dwc = gadget_to_dwc(g);
+
+	dev_dbg(dwc->dev, "otg_set_power: %d mA\n", ma);
+
+	switch (ma) {
+	case USB3_I_MAX_OTG:
+		ma_otg = OTG_USB3_900MA;
+		break;
+	case USB3_I_UNIT_OTG:
+		ma_otg = OTG_USB3_150MA;
+		break;
+	case USB2_I_MAX_OTG:
+		ma_otg = OTG_USB2_500MA;
+		break;
+	case USB2_I_UNIT_OTG:
+		ma_otg = OTG_USB2_100MA;
+		break;
+	default:
+		dev_err(dwc->dev,
+			"wrong charging current reported: %dmA\n", ma);
+	}
+
+	return __dwc3_vbus_draw(dwc, ma_otg);
+}
+
+static const struct usb_gadget_ops dwc3_gadget_ops = {
+	.get_frame		= dwc3_gadget_get_frame,
+	.wakeup			= dwc3_gadget_wakeup,
+	.set_selfpowered	= dwc3_gadget_set_selfpowered,
+	.pullup			= dwc3_gadget_pullup,
+	.udc_start		= dwc3_gadget_start,
+	.udc_stop		= dwc3_gadget_stop,
+};
+
+/* -------------------------------------------------------------------------- */
+
+static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
 		u8 num, u32 direction)
 {
 	struct dwc3_ep			*dep;
+	struct ebc_io			*ebc, *n;
 	u8				i;
 
 	for (i = 0; i < num; i++) {
@@ -1669,6 +2074,17 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
 		dep->endpoint.name = dep->name;
 		dep->direction = (epnum & 1);
 
+		list_for_each_entry_safe(ebc, n, &ebc_io_ops, list) {
+			if (epnum == ebc->epnum) {
+				dep->ebc = ebc;
+				if (ebc->init)
+					if (ebc->init() == -ENODEV)
+						dev_err(dwc->dev,
+						"debug class init fail %d\n",
+						epnum);
+			}
+		}
+
 		if (epnum == 0 || epnum == 1) {
 			dep->endpoint.maxpacket = 512;
 			dep->endpoint.maxburst = 1;
@@ -1869,7 +2285,7 @@ static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,
 			 */
 			dep->flags = DWC3_EP_PENDING_REQUEST;
 		} else {
-			dwc3_stop_active_transfer(dwc, dep->number);
+			dwc3_stop_active_transfer(dwc, dep->number, 1);
 			dep->flags = DWC3_EP_ENABLED;
 		}
 		return 1;
@@ -1953,8 +2369,9 @@ static void dwc3_endpoint_interrupt(struct dwc3 *dwc,
 		dwc3_endpoint_transfer_complete(dwc, dep, event, 1);
 		break;
 	case DWC3_DEPEVT_XFERINPROGRESS:
-		if (!usb_endpoint_xfer_isoc(dep->endpoint.desc)) {
-			dev_dbg(dwc->dev, "%s is not an Isochronous endpoint\n",
+		if ((!usb_endpoint_xfer_isoc(dep->endpoint.desc)) &&
+			(!usb_endpoint_xfer_bulk(dep->endpoint.desc))) {
+			dev_dbg(dwc->dev, "%s is not an Isochronous/bulk endpoint\n",
 					dep->name);
 			return;
 		}
@@ -2019,7 +2436,7 @@ static void dwc3_disconnect_gadget(struct dwc3 *dwc)
 	}
 }
 
-static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum)
+static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum, int forcerm)
 {
 	struct dwc3_ep *dep;
 	struct dwc3_gadget_ep_cmd_params params;
@@ -2028,6 +2445,31 @@ static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum)
 
 	dep = dwc->eps[epnum];
 
+	if (dep->ebc) {
+		if (dep->ebc->is_ondemand == 1) {
+			ret = dwc3_gadget_update_ebc_ep_config(dwc, dep,
+				dep->endpoint.desc, dep->comp_desc, false);
+			if (ret < 0) {
+				dev_dbg(dwc->dev,
+					"DEPCFG failed on %s\n",
+					dep->name);
+				return;
+			}
+			dev_dbg(dwc->dev,
+				"successfully udpated DEPCFG command on %s\n",
+				dep->name);
+		}
+
+		if (dep->ebc->xfer_stop)
+			dep->ebc->xfer_stop();
+		else
+			dev_dbg(dwc->dev, "%s xfer_stop() NULL\n", dep->name);
+	}
+
+	if (usb_endpoint_xfer_isoc(dep->endpoint.desc))
+		dep->resource_index = dwc3_gadget_ep_get_transfer_index(dwc,
+				dep->number);
+
 	if (!dep->resource_index)
 		return;
 
@@ -2051,8 +2493,10 @@ static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum)
 	 */
 
 	cmd = DWC3_DEPCMD_ENDTRANSFER;
-	cmd |= DWC3_DEPCMD_HIPRI_FORCERM | DWC3_DEPCMD_CMDIOC;
+	cmd |= DWC3_DEPCMD_CMDIOC;
 	cmd |= DWC3_DEPCMD_PARAM(dep->resource_index);
+	if (forcerm)
+		cmd |= DWC3_DEPCMD_HIPRI_FORCERM;
 	memset(&params, 0, sizeof(params));
 	ret = dwc3_send_gadget_ep_cmd(dwc, dep->number, cmd, &params);
 	WARN_ON_ONCE(ret);
@@ -2152,6 +2596,17 @@ static void dwc3_gadget_usb2_phy_suspend(struct dwc3 *dwc, int suspend)
 	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
 }
 
+static void link_state_change_work(struct work_struct *data)
+{
+	struct dwc3 *dwc = container_of((struct delayed_work *)data,
+			struct dwc3, link_work);
+
+	if (dwc->link_state == DWC3_LINK_STATE_U3) {
+		dev_info(dwc->dev, "device suspended; notify OTG\n");
+		__dwc3_vbus_draw(dwc, OTG_DEVICE_SUSPEND);
+	}
+}
+
 static void dwc3_gadget_reset_interrupt(struct dwc3 *dwc)
 {
 	u32			reg;
@@ -2292,22 +2747,26 @@ static void dwc3_gadget_conndone_interrupt(struct dwc3 *dwc)
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);
 		dwc->gadget.ep0->maxpacket = 512;
 		dwc->gadget.speed = USB_SPEED_SUPER;
+		__dwc3_vbus_draw(dwc, OTG_USB3_150MA);
 		break;
 	case DWC3_DCFG_HIGHSPEED:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);
 		dwc->gadget.ep0->maxpacket = 64;
 		dwc->gadget.speed = USB_SPEED_HIGH;
+		__dwc3_vbus_draw(dwc, OTG_USB2_100MA);
 		break;
 	case DWC3_DCFG_FULLSPEED2:
 	case DWC3_DCFG_FULLSPEED1:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);
 		dwc->gadget.ep0->maxpacket = 64;
 		dwc->gadget.speed = USB_SPEED_FULL;
+		__dwc3_vbus_draw(dwc, OTG_USB2_100MA);
 		break;
 	case DWC3_DCFG_LOWSPEED:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(8);
 		dwc->gadget.ep0->maxpacket = 8;
 		dwc->gadget.speed = USB_SPEED_LOW;
+		__dwc3_vbus_draw(dwc, OTG_USB2_100MA);
 		break;
 	}
 
@@ -2338,16 +2797,20 @@ static void dwc3_gadget_conndone_interrupt(struct dwc3 *dwc)
 	}
 
 	dep = dwc->eps[0];
-	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, true);
+	ret = dwc3_gadget_set_ep_config(dwc, dep,
+			&dwc3_gadget_ep0_desc, NULL, false,
+			DWC3_DEPCFG_ACTION_MODIFY);
 	if (ret) {
-		dev_err(dwc->dev, "failed to enable %s\n", dep->name);
+		dev_err(dwc->dev, "failed to update %s\n", dep->name);
 		return;
 	}
 
 	dep = dwc->eps[1];
-	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, true);
+	ret = dwc3_gadget_set_ep_config(dwc, dep,
+			&dwc3_gadget_ep0_desc, NULL, false,
+			DWC3_DEPCFG_ACTION_MODIFY);
 	if (ret) {
-		dev_err(dwc->dev, "failed to enable %s\n", dep->name);
+		dev_err(dwc->dev, "failed to update %s\n", dep->name);
 		return;
 	}
 
@@ -2364,6 +2827,9 @@ static void dwc3_gadget_wakeup_interrupt(struct dwc3 *dwc)
 {
 	dev_vdbg(dwc->dev, "%s\n", __func__);
 
+	dev_info(dwc->dev, "device resumed; notify OTG\n");
+	__dwc3_vbus_draw(dwc, OTG_DEVICE_RESUME);
+
 	/*
 	 * TODO take core out of low power mode when that's
 	 * implemented.
@@ -2453,12 +2919,26 @@ static void dwc3_gadget_linksts_change_interrupt(struct dwc3 *dwc,
 
 	dwc->link_state = next;
 
+	if (next ==  DWC3_LINK_STATE_U3)
+		schedule_delayed_work(
+			&dwc->link_work, msecs_to_jiffies(1000));
+
 	dev_vdbg(dwc->dev, "%s link %d\n", __func__, dwc->link_state);
 }
 
+static void dwc3_gadget_hibernation_interrupt(struct dwc3 *dwc)
+{
+	dev_vdbg(dwc->dev, "%s\n", __func__);
+
+	if (dwc->hiber_enabled)
+		pm_runtime_put(dwc->dev);
+}
+
 static void dwc3_gadget_interrupt(struct dwc3 *dwc,
 		const struct dwc3_event_devt *event)
 {
+	u32	reg;
+
 	switch (event->type) {
 	case DWC3_DEVICE_EVENT_DISCONNECT:
 		dwc3_gadget_disconnect_interrupt(dwc);
@@ -2475,6 +2955,9 @@ static void dwc3_gadget_interrupt(struct dwc3 *dwc,
 	case DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE:
 		dwc3_gadget_linksts_change_interrupt(dwc, event->event_info);
 		break;
+	case DWC3_DEVICE_EVENT_HIBER_REQ:
+		dwc3_gadget_hibernation_interrupt(dwc);
+		break;
 	case DWC3_DEVICE_EVENT_EOPF:
 		dev_vdbg(dwc->dev, "End of Periodic Frame\n");
 		break;
@@ -2483,6 +2966,14 @@ static void dwc3_gadget_interrupt(struct dwc3 *dwc,
 		break;
 	case DWC3_DEVICE_EVENT_ERRATIC_ERROR:
 		dev_vdbg(dwc->dev, "Erratic Error\n");
+
+		/* Controller may generate too many Erratic Errors Messages,
+		 * Disable it until we find a way to recover the failure.
+		 */
+		reg = dwc3_readl(dwc->regs, DWC3_DEVTEN);
+		reg &= ~DWC3_DEVTEN_ERRTICERREN;
+		dwc3_writel(dwc->regs, DWC3_DEVTEN, reg);
+		dev_info(dwc->dev, "Erratic Error Event disabled\n");
 		break;
 	case DWC3_DEVICE_EVENT_CMD_CMPL:
 		dev_vdbg(dwc->dev, "Command Complete\n");
@@ -2519,6 +3010,7 @@ static irqreturn_t dwc3_thread_interrupt(int irq, void *_dwc)
 	struct dwc3 *dwc = _dwc;
 	unsigned long flags;
 	irqreturn_t ret = IRQ_NONE;
+	u32 reg;
 	int i;
 
 	spin_lock_irqsave(&dwc->lock, flags);
@@ -2558,6 +3050,11 @@ static irqreturn_t dwc3_thread_interrupt(int irq, void *_dwc)
 		evt->count = 0;
 		evt->flags &= ~DWC3_EVENT_PENDING;
 		ret = IRQ_HANDLED;
+
+		/* Unmask interrupt */
+		reg = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(i));
+		reg &= ~DWC3_GEVNTSIZ_INTMASK;
+		dwc3_writel(dwc->regs, DWC3_GEVNTSIZ(i), reg);
 	}
 
 	spin_unlock_irqrestore(&dwc->lock, flags);
@@ -2569,6 +3066,7 @@ static irqreturn_t dwc3_process_event_buf(struct dwc3 *dwc, u32 buf)
 {
 	struct dwc3_event_buffer *evt;
 	u32 count;
+	u32 reg;
 
 	evt = dwc->ev_buffs[buf];
 
@@ -2580,6 +3078,17 @@ static irqreturn_t dwc3_process_event_buf(struct dwc3 *dwc, u32 buf)
 	evt->count = count;
 	evt->flags |= DWC3_EVENT_PENDING;
 
+	/* WORKAROUND: Add 4 us delay workaround to A-unit issue in A0 stepping.
+	 * Can be removed after B0.
+	 */
+	if (dwc->is_otg && dwc->revision == DWC3_REVISION_210A)
+		udelay(4);
+
+	/* Mask interrupt */
+	reg = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(buf));
+	reg |= DWC3_GEVNTSIZ_INTMASK;
+	dwc3_writel(dwc->regs, DWC3_GEVNTSIZ(buf), reg);
+
 	return IRQ_WAKE_THREAD;
 }
 
@@ -2590,6 +3099,15 @@ static irqreturn_t dwc3_interrupt(int irq, void *_dwc)
 	irqreturn_t			ret = IRQ_NONE;
 
 	spin_lock(&dwc->lock);
+	if (dwc->pm_state != PM_ACTIVE) {
+		if (dwc->pm_state == PM_SUSPENDED) {
+			dev_info(dwc->dev, "u2/u3 pmu is received\n");
+			pm_runtime_get(dwc->dev);
+			dwc->pm_state = PM_RESUMING;
+			ret = IRQ_HANDLED;
+		}
+		goto out;
+	}
 
 	for (i = 0; i < dwc->num_event_buffers; i++) {
 		irqreturn_t status;
@@ -2599,6 +3117,7 @@ static irqreturn_t dwc3_interrupt(int irq, void *_dwc)
 			ret = status;
 	}
 
+out:
 	spin_unlock(&dwc->lock);
 
 	return ret;
@@ -2615,6 +3134,23 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 	u32					reg;
 	int					ret;
 
+	dwc->scratch_array = dma_alloc_coherent(dwc->dev,
+			sizeof(*dwc->scratch_array),
+			&dwc->scratch_array_dma, GFP_KERNEL);
+	if (!dwc->scratch_array) {
+		dev_err(dwc->dev, "failed to allocate scratch_arrary\n");
+		return -ENOMEM;
+	}
+
+	dwc->scratch_buffer[0] = dma_alloc_coherent(dwc->dev,
+			DWC3_SCRATCH_BUF_SIZE,
+			&dwc->scratch_array->dma_adr[0], GFP_KERNEL);
+	if (!dwc->scratch_buffer[0]) {
+		dev_err(dwc->dev, "failed to allocate scratch_buffer\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
 	dwc->ctrl_req = dma_alloc_coherent(dwc->dev, sizeof(*dwc->ctrl_req),
 			&dwc->ctrl_req_addr, GFP_KERNEL);
 	if (!dwc->ctrl_req) {
@@ -2653,6 +3189,8 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 	dwc->gadget.sg_supported	= true;
 	dwc->gadget.name		= "dwc3-gadget";
 
+	INIT_DELAYED_WORK(&dwc->link_work, link_state_change_work);
+
 	/*
 	 * REVISIT: Here we should clear all pending IRQs to be
 	 * sure we're starting from a well known location.
@@ -2699,6 +3237,13 @@ err1:
 			dwc->ctrl_req, dwc->ctrl_req_addr);
 
 err0:
+	dma_free_coherent(dwc->dev,
+			DWC3_SCRATCH_BUF_SIZE, dwc->scratch_buffer[0],
+			(dma_addr_t)dwc->scratch_array->dma_adr[0]);
+
+err:
+	dma_free_coherent(dwc->dev, sizeof(*dwc->scratch_array),
+			dwc->scratch_array, dwc->scratch_array_dma);
 	return ret;
 }
 
@@ -2720,6 +3265,13 @@ void dwc3_gadget_exit(struct dwc3 *dwc)
 
 	dma_free_coherent(dwc->dev, sizeof(*dwc->ctrl_req),
 			dwc->ctrl_req, dwc->ctrl_req_addr);
+
+	dma_free_coherent(dwc->dev,
+			DWC3_SCRATCH_BUF_SIZE, dwc->scratch_buffer[0],
+			(dma_addr_t)dwc->scratch_array->dma_adr[0]);
+
+	dma_free_coherent(dwc->dev, sizeof(*dwc->scratch_array),
+			dwc->scratch_array, dwc->scratch_array_dma);
 }
 
 int dwc3_gadget_prepare(struct dwc3 *dwc)
@@ -2780,3 +3332,359 @@ err1:
 err0:
 	return ret;
 }
+
+void dwc3_register_io_ebc(struct ebc_io *ebc)
+{
+	list_add_tail(&ebc->list, &ebc_io_ops);
+}
+
+void dwc3_unregister_io_ebc(struct ebc_io *ebc)
+{
+	list_del(&ebc->list);
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static void dwc3_gadget_get_ep_state(struct dwc3 *dwc, struct dwc3_ep *dep)
+{
+	struct	dwc3_gadget_ep_cmd_params params;
+	int	ret;
+
+	dev_vdbg(dwc->dev, "%s\n", __func__);
+
+	memset(&params, 0, sizeof(params));
+	ret = dwc3_send_gadget_ep_cmd(dwc, dep->number,
+			DWC3_DEPCMD_GETEPSTATE, &params);
+	WARN_ON_ONCE(ret);
+
+	dep->ep_state = dwc3_readl(dwc->regs, DWC3_DEPCMDPAR2(dep->number));
+}
+
+static void dwc3_cache_hwregs(struct dwc3 *dwc)
+{
+	struct dwc3_hwregs	*regs = &dwc->hwregs;
+
+	dev_vdbg(dwc->dev, "%s\n", __func__);
+
+	regs->guctl = dwc3_readl(dwc->regs, DWC3_GUCTL);
+	regs->grxthrcfg = dwc3_readl(dwc->regs, DWC3_GRXTHRCFG);
+	regs->dcfg = dwc3_readl(dwc->regs, DWC3_DCFG);
+	regs->devten = dwc3_readl(dwc->regs, DWC3_DEVTEN);
+	regs->gctl = dwc3_readl(dwc->regs, DWC3_GCTL);
+	regs->gusb3pipectl0 = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));
+	regs->gusb2phycfg0 = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));
+	regs->gevntadrlo = dwc3_readl(dwc->regs, DWC3_GEVNTADRLO(0));
+	regs->gevntadrhi = dwc3_readl(dwc->regs, DWC3_GEVNTADRHI(0));
+	regs->gevntsiz = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(0));
+}
+
+static void dwc3_restore_hwregs(struct dwc3 *dwc)
+{
+	struct dwc3_hwregs	*regs = &dwc->hwregs;
+
+	dev_vdbg(dwc->dev, "%s\n", __func__);
+
+	dwc3_writel(dwc->regs, DWC3_GUCTL, regs->guctl);
+	dwc3_writel(dwc->regs, DWC3_GRXTHRCFG, regs->grxthrcfg);
+	dwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), regs->gusb3pipectl0);
+	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), regs->gusb2phycfg0);
+	dwc3_writel(dwc->regs, DWC3_GEVNTADRLO(0), regs->gevntadrlo);
+	dwc3_writel(dwc->regs, DWC3_GEVNTADRHI(0), regs->gevntadrhi);
+	dwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0), regs->gevntsiz);
+	dwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), 0);
+	dwc3_writel(dwc->regs, DWC3_DCFG, regs->dcfg);
+	dwc3_writel(dwc->regs, DWC3_DEVTEN, regs->devten);
+	dwc3_writel(dwc->regs, DWC3_GCTL, regs->gctl);
+}
+
+static int dwc3_gadget_controller_save_state(struct dwc3 *dwc)
+{
+	u32			reg;
+	u32			timeout = 1000;
+
+	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
+
+	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+
+	reg |= DWC3_DCTL_CSS;
+	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
+		if (!(reg & DWC3_DSTS_SSS))
+				return 0;
+
+		timeout--;
+		if (!timeout)
+			return -ETIMEDOUT;
+		udelay(1);
+	} while (1);
+
+	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
+}
+
+static int dwc3_gadget_controller_restore_state(struct dwc3 *dwc)
+{
+	u32			reg;
+	u32			timeout = 1000;
+
+	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
+
+	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+
+	reg |= DWC3_DCTL_CRS;
+	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
+		if (!(reg & DWC3_DSTS_RSS))
+				return 0;
+
+		timeout--;
+		if (!timeout)
+			return -ETIMEDOUT;
+		udelay(1);
+	} while (1);
+
+	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
+}
+
+void dwc3_gadget_keep_conn(struct dwc3 *dwc, int is_on)
+{
+	u32         reg;
+
+	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+	if (is_on)
+		reg |= DWC3_DCTL_KEEP_CONNECT;
+	else
+		reg &= ~DWC3_DCTL_KEEP_CONNECT;
+	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+}
+
+int dwc3_runtime_suspend(struct device *device)
+{
+	struct dwc3			*dwc;
+	struct platform_device		*pdev;
+	unsigned long			flags;
+	u32				epnum;
+	struct dwc3_ep			*dep;
+
+	pdev = to_platform_device(device);
+	dwc = platform_get_drvdata(pdev);
+
+	if (!dwc || !dwc->hiber_enabled)
+		return 0;
+
+	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	if (dwc->pm_state != PM_ACTIVE) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		return 0;
+	}
+
+
+	for (epnum = 0; epnum < DWC3_ENDPOINTS_NUM; epnum++) {
+		dep = dwc->eps[epnum];
+		if (!(dep->flags & DWC3_EP_ENABLED))
+			continue;
+
+		dep->flags_backup = dep->flags;
+		if (dep->flags & DWC3_EP_BUSY)
+			dwc3_stop_active_transfer(dwc, epnum, 0);
+
+		dwc3_gadget_get_ep_state(dwc, dep);
+
+		dep->flags = DWC3_EP_HIBERNATION;
+	}
+
+	__dwc3_gadget_run_stop(dwc, 0);
+	dwc3_gadget_keep_conn(dwc, 1);
+
+	dwc3_cache_hwregs(dwc);
+
+	dwc3_gadget_disable_irq(dwc);
+	dwc3_event_buffers_cleanup(dwc);
+
+	dwc3_gadget_controller_save_state(dwc);
+
+	dwc->pm_state = PM_SUSPENDED;
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	schedule_delayed_work(&dwc->link_work, msecs_to_jiffies(1000));
+	dev_info(dwc->dev, "suspended\n");
+	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
+
+	return 0;
+}
+
+int dwc3_runtime_resume(struct device *device)
+{
+	struct dwc3			*dwc;
+	struct platform_device		*pdev;
+	unsigned long			flags;
+	int				ret;
+	u32				epnum;
+	u32				timeout = 500;
+	u32				reg;
+	u8				link_state;
+	struct dwc3_ep			*dep;
+
+	pdev = to_platform_device(device);
+	dwc = platform_get_drvdata(pdev);
+
+	if (!dwc || !dwc->hiber_enabled)
+		return 0;
+
+	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	if (dwc->pm_state == PM_ACTIVE ||
+		dwc->pm_state == PM_DISCONNECTED) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		return 0;
+	}
+
+	dwc3_send_gadget_generic_command(dwc, DWC3_DGCMD_SET_SCRATCH_ADDR_LO,
+		dwc->scratch_array_dma & 0xffffffffU);
+
+	dwc3_gadget_controller_restore_state(dwc);
+
+	dwc3_restore_hwregs(dwc);
+
+	dep = dwc->eps[0];
+	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
+	if (ret) {
+		dev_err(dwc->dev, "failed to enable %s during runtime resume\n",
+			dep->name);
+		goto err0;
+	}
+
+	dep = dwc->eps[1];
+	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
+	if (ret) {
+		dev_err(dwc->dev, "failed to enable %s during runtime resume\n",
+			dep->name);
+		goto err1;
+	}
+
+	for (epnum = 0; epnum < 2; epnum++) {
+		struct dwc3_gadget_ep_cmd_params params;
+
+		dep = dwc->eps[epnum];
+		if (dep->flags_backup & DWC3_EP_BUSY) {
+			dwc->ep0_trb->ctrl |= DWC3_TRB_CTRL_HWO;
+
+			memset(&params, 0, sizeof(params));
+			params.param0 = upper_32_bits(dwc->ep0_trb_addr);
+			params.param1 = lower_32_bits(dwc->ep0_trb_addr);
+
+			ret = dwc3_send_gadget_ep_cmd(dwc, epnum,
+					DWC3_DEPCMD_STARTTRANSFER, &params);
+			WARN_ON_ONCE(ret);
+		}
+
+		dep->flags = dep->flags_backup;
+		dep->flags_backup = 0;
+	}
+
+	__dwc3_gadget_run_stop(dwc, 1);
+	dwc3_gadget_keep_conn(dwc, 1);
+
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
+		if (!(reg & DWC3_DSTS_DCNRD))
+				break;
+
+		timeout--;
+		if (!timeout)
+			break;
+		udelay(1);
+	} while (1);
+
+	reg = dwc3_readl(dwc->regs, DWC3_DSTS);
+	link_state = DWC3_DSTS_USBLNKST(reg);
+	switch (link_state) {
+	case DWC3_LINK_STATE_U3:
+	case DWC3_LINK_STATE_RESUME:
+		dwc3_gadget_conndone_interrupt(dwc);
+
+		for (epnum = 2; epnum < DWC3_ENDPOINTS_NUM; epnum++) {
+			dep = dwc->eps[epnum];
+			if (!(dep->flags_backup & DWC3_EP_ENABLED))
+				continue;
+			if (dep->endpoint.desc)
+				dwc3_gadget_set_ep_config(dwc,
+					dep, dep->endpoint.desc, dep->comp_desc,
+					false, DWC3_DEPCFG_ACTION_RESTORE);
+
+			dwc3_gadget_set_xfer_resource(dwc, dep);
+
+			reg = dwc3_readl(dwc->regs, DWC3_DALEPENA);
+			reg |= DWC3_DALEPENA_EP(epnum);
+			dwc3_writel(dwc->regs, DWC3_DALEPENA, reg);
+
+			if (dep->flags_backup & DWC3_EP_STALL)
+				__dwc3_gadget_ep_set_halt(dep, 1);
+
+			if (dep->flags_backup & DWC3_EP_BUSY) {
+				struct dwc3_request			*req;
+				struct dwc3_gadget_ep_cmd_params	params;
+
+				req = next_request(&dep->req_queued);
+				if (!req)
+					break;
+				req->trb->ctrl |= DWC3_TRB_CTRL_HWO;
+				memset(&params, 0, sizeof(params));
+				params.param0 = upper_32_bits(req->trb_dma);
+				params.param1 = lower_32_bits(req->trb_dma);
+
+				ret = dwc3_send_gadget_ep_cmd(dwc, epnum,
+						DWC3_DEPCMD_STARTTRANSFER,
+						&params);
+				WARN_ON_ONCE(ret);
+
+			}
+
+			dep->flags = dep->flags_backup;
+			dep->flags_backup = 0;
+		}
+
+		reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+		reg |= DWC3_DCTL_ULSTCHNG_RECOVERY;
+		dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+
+		break;
+	case DWC3_LINK_STATE_RESET:
+		reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+		reg |= DWC3_DCTL_ULSTCHNG_RECOVERY;
+		dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+
+		break;
+	default:
+		/* wait for USB Reset or Connect Done event */
+		break;
+	}
+
+	dwc->pm_state = PM_ACTIVE;
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	__dwc3_vbus_draw(dwc, OTG_DEVICE_RESUME);
+	dev_info(dwc->dev, "resumed\n");
+	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
+	return 0;
+
+err1:
+	__dwc3_gadget_ep_disable(dwc->eps[0]);
+
+err0:
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	return ret;
+}
+#else
+void dwc3_gadget_keep_conn(struct dwc3 *dwc, int is_on) {}
+#endif
-- 
2.37.3

