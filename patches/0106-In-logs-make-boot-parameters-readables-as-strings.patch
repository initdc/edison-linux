From da908c1433cd06b2e6c8d7f7e624de5f011402ec Mon Sep 17 00:00:00 2001
From: Michel Jauffres <michelx.jauffres@intel.com>
Date: Fri, 11 Oct 2013 18:07:03 +0200
Subject: [PATCH 106/429] In logs make boot parameters readables as strings

In the current implementation, when dumping target mode, wakesrc,
in the aplog, their values are given as hexadecimal.
In order to ease their interpretation they are now displayed
as strings.
For example, instead of WAKESRC=0x03 we will see
WAKESRC=[usb charger inserted]

Signed-off-by: Michel Jauffres <michelx.jauffres@intel.com>
---
 arch/x86/include/asm/intel_scu_ipcutil.h | 28 ++++++++
 drivers/platform/x86/intel_scu_ipcutil.c | 88 +++++++++++++++++++++---
 2 files changed, 107 insertions(+), 9 deletions(-)

diff --git a/arch/x86/include/asm/intel_scu_ipcutil.h b/arch/x86/include/asm/intel_scu_ipcutil.h
index 6689839b61e7..ec9c963e2d82 100644
--- a/arch/x86/include/asm/intel_scu_ipcutil.h
+++ b/arch/x86/include/asm/intel_scu_ipcutil.h
@@ -19,6 +19,34 @@
 #define INTEL_SCU_IPC_OSC_CLK_CNTL		    0xC6
 #define INTEL_SCU_IPC_PMDB_ACCESS		    0xD0
 
+#define SIGNED_MOS_ATTR		0x0
+#define SIGNED_COS_ATTR		0x0A
+#define SIGNED_RECOVERY_ATTR	0x0C
+#define SIGNED_POS_ATTR		0x0E
+#define SIGNED_FACTORY_ATTR	0x12
+
+enum intel_scu_ipc_wake_src {
+	WAKE_BATT_INSERT,
+	WAKE_PWR_BUTTON_PRESS,
+	WAKE_RTC_TIMER,
+	WAKE_USB_CHRG_INSERT,
+	WAKE_RESERVED,
+	WAKE_REAL_RESET,
+	WAKE_COLD_BOOT,
+	WAKE_UNKNOWN,
+	WAKE_KERNEL_WATCHDOG_RESET,
+	WAKE_SECURITY_WATCHDOG_RESET,
+	WAKE_WATCHDOG_COUNTER_EXCEEDED,
+	WAKE_POWER_SUPPLY_DETECTED,
+	WAKE_FASTBOOT_BUTTONS_COMBO,
+	WAKE_NO_MATCHING_OSIP_ENTRY,
+	WAKE_CRITICAL_BATTERY,
+	WAKE_INVALID_CHECKSUM,
+	WAKE_FORCED_RESET,
+	WAKE_ACDC_CHRG_INSERT,
+	WAKE_PMIC_WATCHDOG_RESET
+};
+
 struct scu_ipc_data {
 	__u32	count;  /* No. of registers */
 	__u16	addr[5]; /* Register addresses */
diff --git a/drivers/platform/x86/intel_scu_ipcutil.c b/drivers/platform/x86/intel_scu_ipcutil.c
index 47228b08156a..93700eeb712c 100644
--- a/drivers/platform/x86/intel_scu_ipcutil.c
+++ b/drivers/platform/x86/intel_scu_ipcutil.c
@@ -125,6 +125,47 @@ static struct chip_reset_event chip_reset_events[] = {
 	{ INTEL_MID_CPU_CHIP_PENWELL, "RESETIRQ1", "RESETIRQ2" },
 };
 
+struct osnib_target_os {
+	const char *target_os_name;
+	int id;
+};
+
+static struct osnib_target_os osnib_target_oses[] = {
+	{ "main", SIGNED_MOS_ATTR },
+	{ "charging", SIGNED_COS_ATTR  },
+	{ "recovery", SIGNED_RECOVERY_ATTR },
+	{ "fastboot", SIGNED_POS_ATTR },
+	{ "factory", SIGNED_FACTORY_ATTR },
+};
+
+
+struct osnib_wake_src {
+	u8 id;
+	const char *wakesrc_name;
+};
+
+static struct osnib_wake_src osnib_wake_srcs[] = {
+	{ WAKE_BATT_INSERT, "battery inserted" },
+	{ WAKE_PWR_BUTTON_PRESS, "power button pressed" },
+	{ WAKE_RTC_TIMER, "rtc timer" },
+	{ WAKE_USB_CHRG_INSERT, "usb charger inserted" },
+	{ WAKE_RESERVED, "reserved" },
+	{ WAKE_REAL_RESET, "real reset" },
+	{ WAKE_COLD_BOOT, "cold boot" },
+	{ WAKE_UNKNOWN, "unknown" },
+	{ WAKE_KERNEL_WATCHDOG_RESET, "kernel watchdog reset" },
+	{ WAKE_SECURITY_WATCHDOG_RESET, "security watchdog reset" },
+	{ WAKE_WATCHDOG_COUNTER_EXCEEDED, "watchdog counter exceeded" },
+	{ WAKE_POWER_SUPPLY_DETECTED, "power supply detected" },
+	{ WAKE_FASTBOOT_BUTTONS_COMBO, "fastboot combo" },
+	{ WAKE_NO_MATCHING_OSIP_ENTRY, "no matching osip entry" },
+	{ WAKE_CRITICAL_BATTERY, "critical battery" },
+	{ WAKE_INVALID_CHECKSUM, "invalid checksum" },
+	{ WAKE_FORCED_RESET, "forced reset"},
+	{ WAKE_ACDC_CHRG_INSERT, "ac charger inserted" },
+	{ WAKE_PMIC_WATCHDOG_RESET, "pmic watchdog reset" },
+};
+
 
 /* OSNIB allocation. */
 struct scu_ipc_osnib {
@@ -1111,12 +1152,22 @@ exit:
  */
 int intel_scu_ipc_write_osnib_rr(u8 rr)
 {
-	pr_info("intel_scu_ipc_write_osnib_rr: reboot reason %x\n", rr);
+	int i;
 
-	return oshob_info->scu_ipc_write_osnib(
-			&rr,
-			1,
-			offsetof(struct scu_ipc_osnib, target_mode));
+	for (i = 0; i < ARRAY_SIZE(osnib_target_oses); i++) {
+		if (osnib_target_oses[i].id == rr) {
+			pr_info("intel_scu_ipc_write_osnib_rr: reboot reason: %s\n",
+				osnib_target_oses[i].target_os_name);
+			return oshob_info->scu_ipc_write_osnib(
+				&rr,
+				1,
+				offsetof(struct scu_ipc_osnib, target_mode));
+		}
+	}
+
+	pr_warn("intel_scu_ipc_write_osnib_rr: reboot reason [0x%x] not found\n",
+			rr);
+	return -1;
 }
 EXPORT_SYMBOL_GPL(intel_scu_ipc_write_osnib_rr);
 
@@ -2107,6 +2158,7 @@ static int oshob_init(void)
 
 #ifdef DUMP_OSNIB
 	u8 rr, reset_ev1, reset_ev2, wd, alarm, wakesrc, *ptr;
+	int rr_found = 0, wksrc_found = 0;
 	u32 pmit, scu_trace[OSHOB_SCU_BUF_BASE_DW_SIZE*4], ia_trace;
 	int buff_size;
 #endif
@@ -2233,17 +2285,35 @@ static int oshob_init(void)
 		goto exit;
 	}
 
-	pr_warn("[BOOT] RR=0x%02x WD=0x%02x ALARM=0x%02x (osnib)\n",
-		rr, wd, alarm);
+	for (i = 0; i < ARRAY_SIZE(osnib_target_oses); i++) {
+		if (osnib_target_oses[i].id == rr) {
+			pr_warn("[BOOT] RR=[%s] WD=0x%02x ALARM=0x%02x (osnib)\n",
+				osnib_target_oses[i].target_os_name, wd, alarm);
+			rr_found++;
+			break;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(osnib_wake_srcs); i++) {
+		if (osnib_wake_srcs[i].id == wakesrc) {
+			pr_warn("[BOOT] WAKESRC=[%s] (osnib)\n",
+				osnib_wake_srcs[i].wakesrc_name);
+			wksrc_found++;
+			break;
+		}
+	}
+
+	if ((!rr_found) || (!wksrc_found))
+		pr_err("[BOOT] Could not identify passed RR/WAKESRC\n");
 
 	for (i = 0; i < ARRAY_SIZE(chip_reset_events); i++) {
 		if (chip_reset_events[i].id == oshob_info->platform_type) {
-			pr_warn("[BOOT] WAKESRC=0x%02x %s=0x%02x %s=0x%02x (osnib)\n",
-				wakesrc,
+			pr_warn("[BOOT] %s=0x%02x %s=0x%02x (osnib)\n",
 				chip_reset_events[i].reset_ev1_name,
 				reset_ev1,
 				chip_reset_events[i].reset_ev2_name,
 				reset_ev2);
+			break;
 		}
 	}
 
-- 
2.37.3

