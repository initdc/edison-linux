From 8dc9b931400f8867e446ec1c497fc3f3f1f02a94 Mon Sep 17 00:00:00 2001
From: Fernand Cuesta <fernand.cuesta@intel.com>
Date: Tue, 29 Oct 2013 12:01:41 +0100
Subject: [PATCH 102/429] legacysuspend: native_cpu_die sequence enhancement in
 cpu hotplug

In order to end a logical unplug of a cpu, a percpu state CPU_DEAD is set
by the targeted cpu's idle task. In a racing case (~every time), this
value is being set after being checked, which was causing a 100ms retry delay.

To avoid this racing scenario, we replace the looping/retry check by a
completion structure. This makes the end of the unplug sequence more reliable
and safely applicable to all platforms.

In a legacy Suspend-To-RAM (S3), sequence is then shorten by ~300ms on CLV
(3 nonboot cpus) which leads to savings in all use cases where S3 is involved
(~0.3mW in Standby-Flight Mode).

Signed-off-by: Anthony Toubeau <anthony.toubeau@intel.com>
Signed-off-by: Fernand Cuesta <fernand.cuesta@intel.com>
---
 arch/x86/kernel/smpboot.c | 27 ++++++++++++++++-----------
 1 file changed, 16 insertions(+), 11 deletions(-)

diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index 36af8bd0befb..71ba527eab08 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -1325,21 +1325,25 @@ int native_cpu_disable(void)
 	return 0;
 }
 
+/*
+ * We let cpus' idle tasks announce their own death to complete
+ * logical cpu unplug sequence.
+ */
+DECLARE_COMPLETION(cpu_die_comp);
+
 void native_cpu_die(unsigned int cpu)
 {
 	/* We don't do anything here: idle task is faking death itself. */
-	unsigned int i;
+	unsigned long timeout = HZ; /* 1 sec */
 
-	for (i = 0; i < 10; i++) {
-		/* They ack this in play_dead by setting CPU_DEAD */
-		if (per_cpu(cpu_state, cpu) == CPU_DEAD) {
-			if (system_state == SYSTEM_RUNNING)
-				pr_info("CPU %u is now offline\n", cpu);
-			return;
-		}
-		msleep(100);
-	}
-	pr_err("CPU %u didn't die...\n", cpu);
+	/* They ack this in play_dead by setting CPU_DEAD */
+	wait_for_completion_timeout(&cpu_die_comp, timeout);
+	if (per_cpu(cpu_state, cpu) == CPU_DEAD) {
+		if (system_state == SYSTEM_RUNNING)
+			pr_info("CPU %u is now offline\n", cpu);
+		return;
+	} else
+		pr_err("CPU %u didn't die...\n", cpu);
 }
 
 void play_dead_common(void)
@@ -1351,6 +1355,7 @@ void play_dead_common(void)
 	mb();
 	/* Ack it */
 	__this_cpu_write(cpu_state, CPU_DEAD);
+	complete(&cpu_die_comp);
 
 	/*
 	 * With physical CPU hotplug, we should halt the cpu
-- 
2.37.3

