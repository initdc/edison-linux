From 82df3054208628eecc7bee3aad4d4c185968734a Mon Sep 17 00:00:00 2001
From: yisun1 <yi.y.sun@intel.com>
Date: Tue, 12 Nov 2013 18:51:47 +0800
Subject: [PATCH 255/429] mmc: Fix unexpected interrupt issue caused by R1B

Upstream codes assume cmd interrupt comes
before data interrupt. But this is not true
for r1b cmd which causes unexpected interrupt
appears.

Signed-off-by: yisun1 <yi.y.sun@intel.com>
---
 drivers/mmc/host/sdhci.c  | 22 ++++++++++++++++++----
 include/linux/mmc/sdhci.h |  1 +
 2 files changed, 19 insertions(+), 4 deletions(-)

diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index e1f09ee4e8e5..355405b37b5e 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1006,6 +1006,7 @@ static void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 	mod_timer(&host->timer, jiffies + 10 * HZ);
 
 	host->cmd = cmd;
+	host->r1b_busy_end = 0;
 
 	sdhci_prepare_data(host, cmd);
 
@@ -2527,7 +2528,10 @@ static void sdhci_cmd_irq(struct sdhci_host *host, u32 intmask)
 			DBG("Cannot wait for busy signal when also "
 				"doing a data transfer");
 		else if (!(host->quirks & SDHCI_QUIRK_NO_BUSY_IRQ))
-			return;
+			if (!host->r1b_busy_end) {
+				host->r1b_busy_end = 1;
+				return;
+			}
 
 		/* The controller does not support the end-of-busy IRQ,
 		 * fall through and take the SDHCI_INT_RESPONSE */
@@ -2590,7 +2594,10 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 		 */
 		if (host->cmd && (host->cmd->flags & MMC_RSP_BUSY)) {
 			if (intmask & SDHCI_INT_DATA_END) {
-				sdhci_finish_command(host);
+				if (host->r1b_busy_end)
+					sdhci_finish_command(host);
+				else
+					host->r1b_busy_end = 1;
 				return;
 			}
 		}
@@ -2842,6 +2849,7 @@ static void sdhci_panic_send_cmd(struct sdhci_host *host,
 	}
 
 	host->cmd = cmd;
+	host->r1b_busy_end = 0;
 
 	/*
 	 * set the data timeout register to be max value
@@ -3037,7 +3045,10 @@ static void sdhci_panic_cmd_irq(struct sdhci_host *host, u32 intmask)
 		if (host->cmd->data)
 			pr_dbg("Cannot wait for busy signal when also doing a data transfer\n");
 		else if (!(host->quirks & SDHCI_QUIRK_NO_BUSY_IRQ))
-			return;
+			if (!host->r1b_busy_end) {
+				host->r1b_busy_end = 1;
+				return;
+			}
 	}
 
 	if (intmask & SDHCI_INT_RESPONSE)
@@ -3063,7 +3074,10 @@ static void sdhci_panic_data_irq(struct sdhci_host *host, u32 intmask)
 		 */
 		if (host->cmd && (host->cmd->flags & MMC_RSP_BUSY)) {
 			if (intmask & SDHCI_INT_DATA_END) {
-				sdhci_panic_finish_command(host);
+				if (host->r1b_busy_end)
+					sdhci_panic_finish_command(host);
+				else
+					host->r1b_busy_end = 1;
 				return;
 			}
 		}
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index 17ebeeede15a..1c4e1987c5fd 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -185,6 +185,7 @@ struct sdhci_host {
 	struct mmc_command *cmd;	/* Current command */
 	struct mmc_data *data;	/* Current data request */
 	unsigned int data_early:1;	/* Data finished before cmd */
+	unsigned int r1b_busy_end:1;	/* R1B busy end */
 
 	struct sg_mapping_iter sg_miter;	/* SG state for PIO */
 	unsigned int blocks;	/* remaining PIO blocks */
-- 
2.37.3

