From 87e7ec70b4a28575db4a0826f1cec97c498f04f1 Mon Sep 17 00:00:00 2001
From: Ananth Krishna <ananth.krishna.r@intel.com>
Date: Thu, 19 Sep 2013 14:40:28 +0530
Subject: [PATCH 073/429] Check for NC and SC device status before entering S3

During S3 flow there could be a possibility that S0ix aborts happens.
As seen in BZ 114607. But today due to the lack of s0ix abort feedback
mechanism the platform remains in kind of unknown state until a power
button or USB is connected. This gap is addressed in BZ 12353.

This patch adds a check in PMU driver to check NC and SC device status
before requesting C7 (basically C6 mwait + s0ix hint). S3 flow is aborted
in case the check fails and retries; rather leaving platform in unknown
state.

Signed-off-by: Ananth Krishna <ananth.krishna.r@intel.com>
[Fix some trivial conflicts]
Signed-off-by: Srinidhi Kasagar <srinidhi.kasagar@intel.com>
---
 arch/x86/platform/intel-mid/intel_soc_mrfld.c | 73 +++++++++++++++++++
 arch/x86/platform/intel-mid/intel_soc_mrfld.h |  2 +
 .../platform/intel-mid/intel_soc_pm_debug.c   | 23 +-----
 arch/x86/platform/intel-mid/intel_soc_pmu.c   |  8 ++
 arch/x86/platform/intel-mid/intel_soc_pmu.h   |  1 +
 5 files changed, 87 insertions(+), 20 deletions(-)

diff --git a/arch/x86/platform/intel-mid/intel_soc_mrfld.c b/arch/x86/platform/intel-mid/intel_soc_mrfld.c
index 433e0e0bf9dc..575c57ad387d 100644
--- a/arch/x86/platform/intel-mid/intel_soc_mrfld.c
+++ b/arch/x86/platform/intel-mid/intel_soc_mrfld.c
@@ -23,6 +23,26 @@
 u32 __iomem *residency[SYS_STATE_MAX];
 u32 __iomem *s0ix_counter[SYS_STATE_MAX];
 
+/* list of north complex devices */
+char *mrfl_nc_devices[] = {
+	"GFXSLC",
+	"GSDKCK",
+	"GRSCD",
+	"VED",
+	"VEC",
+	"DPA",
+	"DPB",
+	"DPC",
+	"VSP",
+	"ISP",
+	"MIO",
+	"HDMIO",
+	"GFXSLCLDO"
+};
+
+int mrfl_no_of_nc_devices =
+	sizeof(mrfl_nc_devices)/sizeof(mrfl_nc_devices[0]);
+
 static int mrfld_pmu_init(void)
 {
 	mid_pmu_cxt->s3_hint = MRFLD_S3_HINT;
@@ -120,6 +140,58 @@ err4:
 	return PMU_FAILED;
 }
 
+/* This function checks north complex (NC) and
+ * south complex (SC) device status in MRFLD.
+ * returns TRUE if all NC and SC devices are in d0i3
+ * else FALSE.
+ */
+static bool mrfld_nc_sc_status_check(void)
+{
+	int i;
+	u32 val, nc_pwr_sts;
+	struct pmu_ss_states cur_pmsss;
+	bool nc_status, sc_status;
+
+	/* assuming nc and sc are good */
+	nc_status = true;
+	sc_status = true;
+
+	/* Check south complex device status */
+	pmu_read_sss(&cur_pmsss);
+
+	if (!(((cur_pmsss.pmu2_states[0] & S0IX_TARGET_SSS0_MASK) ==
+					 S0IX_TARGET_SSS0) &&
+		((cur_pmsss.pmu2_states[1] & S0IX_TARGET_SSS1_MASK) ==
+					 S0IX_TARGET_SSS1) &&
+		((cur_pmsss.pmu2_states[2] & S0IX_TARGET_SSS2_MASK) ==
+					 S0IX_TARGET_SSS2) &&
+		((cur_pmsss.pmu2_states[3] & S0IX_TARGET_SSS3_MASK) ==
+					 (S0IX_TARGET_SSS3)))) {
+		sc_status = false;
+		pr_warn("SC device/devices not in d0i3!!\n");
+	}
+
+	if (sc_status) {
+		/* Check north complex status */
+		nc_pwr_sts =
+			 intel_mid_msgbus_read32(PUNIT_PORT, NC_PM_SSS);
+		/* loop through the status to see if any of nc power island
+		 * is not in D0i3 state
+		 */
+		for (i = 0; i < mrfl_no_of_nc_devices; i++) {
+			val = nc_pwr_sts & 3;
+			if (val != 3) {
+				nc_status = false;
+				pr_warn("NC device/devices is not in D0i3!!\n");
+				break;
+			}
+			nc_pwr_sts >>= BITS_PER_LSS;
+		}
+	}
+
+	return nc_status & sc_status;
+}
+
 /* FIXME: Need to start the counter only if debug is
  * needed. This will save SCU cycles if debug is
  * disabled
@@ -325,4 +397,5 @@ struct platform_pmu_ops mrfld_pmu_ops = {
 	.enter	 = mrfld_pmu_enter,
 	.set_s0ix_complete = s0ix_complete,
 	.nc_set_power_state = mrfld_nc_set_power_state,
+	.check_nc_sc_status = mrfld_nc_sc_status_check,
 };
diff --git a/arch/x86/platform/intel-mid/intel_soc_mrfld.h b/arch/x86/platform/intel-mid/intel_soc_mrfld.h
index ee7f19f72d9a..ad2780ee134a 100644
--- a/arch/x86/platform/intel-mid/intel_soc_mrfld.h
+++ b/arch/x86/platform/intel-mid/intel_soc_mrfld.h
@@ -149,6 +149,8 @@
 #define LPMP3_TARGET_SSS0_MASK (0xFFF3FFFF)
 #define LPMP3_TARGET_SSS0 (0xFFC3FFFF)
 
+extern char *mrfl_nc_devices[];
+extern int mrfl_no_of_nc_devices;
 extern int intel_scu_ipc_simple_command(int, int);
 extern void log_wakeup_irq(void);
 extern void s0ix_complete(void);
diff --git a/arch/x86/platform/intel-mid/intel_soc_pm_debug.c b/arch/x86/platform/intel-mid/intel_soc_pm_debug.c
index b7a312e607c3..b86f4bb443dc 100644
--- a/arch/x86/platform/intel-mid/intel_soc_pm_debug.c
+++ b/arch/x86/platform/intel-mid/intel_soc_pm_debug.c
@@ -1327,24 +1327,7 @@ void pmu_stats_finish(void)
 
 #endif /*if CONFIG_X86_MDFLD_POWER || CONFIG_X86_CLV_POWER*/
 
-#ifdef CONFIG_INTEL_REMOVEME_ATOM_MRFLD_POWER
-static char *nc_devices[] = {
-	"GFXSLC",
-	"GSDKCK",
-	"GRSCD",
-	"VED",
-	"VEC",
-	"DPA",
-	"DPB",
-	"DPC",
-	"VSP",
-	"ISP",
-	"MIO",
-	"HDMIO",
-	"GFXSLCLDO"
-};
-
-static int no_of_nc_devices = sizeof(nc_devices)/sizeof(nc_devices[0]);
+#ifdef CONFIG_REMOVEME_INTEL_ATOM_MRFLD_POWER
 
 static void pmu_stat_seq_printf(struct seq_file *s, int type, char *typestr)
 {
@@ -1460,10 +1443,10 @@ static int pmu_devices_state_show(struct seq_file *s, void *unused)
 	seq_printf(s, "\nNORTH COMPLEX DEVICES :\n\n");
 
 	nc_pwr_sts = intel_mid_msgbus_read32(PUNIT_PORT, NC_PM_SSS);
-	for (i = 0; i < no_of_nc_devices; i++) {
+	for (i = 0; i < mrfl_no_of_nc_devices; i++) {
 		val = nc_pwr_sts & 3;
 		nc_pwr_sts >>= BITS_PER_LSS;
-		seq_printf(s, "%9s : %s\n", nc_devices[i], dstates[val]);
+		seq_printf(s, "%9s : %s\n", mrfl_nc_devices[i], dstates[val]);
 	}
 
 	seq_printf(s, "\nSOUTH COMPLEX DEVICES :\n\n");
diff --git a/arch/x86/platform/intel-mid/intel_soc_pmu.c b/arch/x86/platform/intel-mid/intel_soc_pmu.c
index b43ba7a29642..346d0b9c3055 100644
--- a/arch/x86/platform/intel-mid/intel_soc_pmu.c
+++ b/arch/x86/platform/intel-mid/intel_soc_pmu.c
@@ -1953,6 +1953,14 @@ static int mid_suspend_enter(suspend_state_t state)
 	if (state != PM_SUSPEND_MEM)
 		return -EINVAL;
 
+	/* one last check before entering standby */
+	if (pmu_ops->check_nc_sc_status) {
+		if (!(pmu_ops->check_nc_sc_status())) {
+			trace_printk("Device d0ix status check failed! Aborting Standby entry!\n");
+			WARN_ON(1);
+		}
+	}
+
 	trace_printk("s3_entry\n");
 	ret = standby_enter();
 	trace_printk("s3_exit %d\n", ret);
diff --git a/arch/x86/platform/intel-mid/intel_soc_pmu.h b/arch/x86/platform/intel-mid/intel_soc_pmu.h
index 4e94e9f7aeed..58ae3dff0198 100644
--- a/arch/x86/platform/intel-mid/intel_soc_pmu.h
+++ b/arch/x86/platform/intel-mid/intel_soc_pmu.h
@@ -375,6 +375,7 @@ struct platform_pmu_ops {
 	void (*set_power_state_ops) (int);
 	void (*set_s0ix_complete) (void);
 	int (*nc_set_power_state) (int, int, int, int *);
+	bool (*check_nc_sc_status) (void);
 };
 
 extern char s0ix[5];
-- 
2.37.3

