From e540bbb6de2babc8d41e0940ab15edf73a8a4cc3 Mon Sep 17 00:00:00 2001
From: Illyas Mansoor <illyas.mansoor@intel.com>
Date: Fri, 11 Oct 2013 21:46:43 +0530
Subject: [PATCH 087/429] intel_soc_pmu: pm_qos for enable/disable s0ix in
 suspend/resume flow

PM driver has module parameter to enable/disable s0ix using boot
time cmdline parameter.

It is currently using a pm_qos handle that is also used during
suspend/resume flows to enable disable s0ix.

This causes, s0ix to get re-enabled during resume flow.

Need to use separate pm_qos handle for suspend/resume flow.

Also use the same pm_qos handle for shutdown flows as well.

Signed-off-by: Illyas Mansoor <illyas.mansoor@intel.com>
---
 arch/x86/platform/intel-mid/intel_soc_pmu.c | 22 ++++++++++++++++-----
 arch/x86/platform/intel-mid/intel_soc_pmu.h |  1 +
 2 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/arch/x86/platform/intel-mid/intel_soc_pmu.c b/arch/x86/platform/intel-mid/intel_soc_pmu.c
index ff566c57dc07..8457de3f22a8 100644
--- a/arch/x86/platform/intel-mid/intel_soc_pmu.c
+++ b/arch/x86/platform/intel-mid/intel_soc_pmu.c
@@ -146,7 +146,7 @@ int pmu_set_devices_in_d0i0(void)
 	cur_pmssc.pmu2_states[3] = D0I0_MASK;
 
 	/* Restrict platform Cx state to C6 */
-	pm_qos_update_request(mid_pmu_cxt->cstate_qos,
+	pm_qos_update_request(mid_pmu_cxt->s3_restrict_qos,
 				(CSTATE_EXIT_LATENCY_S0i1-1));
 
 	down(&mid_pmu_cxt->scu_ready_sem);
@@ -165,7 +165,7 @@ int pmu_set_devices_in_d0i0(void)
 		mid_pmu_cxt->shutdown_started = false;
 
 		/* allow s0ix now */
-		pm_qos_update_request(mid_pmu_cxt->cstate_qos,
+		pm_qos_update_request(mid_pmu_cxt->s3_restrict_qos,
 						PM_QOS_DEFAULT_VALUE);
 		goto unlock;
 	}
@@ -1911,7 +1911,7 @@ static void mid_pmu_shutdown(struct pci_dev *dev)
 
 	if (mid_pmu_cxt) {
 		/* Restrict platform Cx state to C6 */
-		pm_qos_update_request(mid_pmu_cxt->cstate_qos,
+		pm_qos_update_request(mid_pmu_cxt->s3_restrict_qos,
 					(CSTATE_EXIT_LATENCY_S0i1-1));
 
 		down(&mid_pmu_cxt->scu_ready_sem);
@@ -1968,7 +1968,7 @@ static int mid_suspend_begin(suspend_state_t state)
 	pmu_s3_stats_update(1);
 
 	/* Restrict to C6 during suspend */
-	pm_qos_update_request(mid_pmu_cxt->cstate_qos,
+	pm_qos_update_request(mid_pmu_cxt->s3_restrict_qos,
 					(CSTATE_EXIT_LATENCY_S0i1-1));
 	return 0;
 }
@@ -2027,7 +2027,7 @@ static int mid_suspend_enter(suspend_state_t state)
 static void mid_suspend_end(void)
 {
 	/* allow s0ix now */
-	pm_qos_update_request(mid_pmu_cxt->cstate_qos,
+	pm_qos_update_request(mid_pmu_cxt->s3_restrict_qos,
 					PM_QOS_DEFAULT_VALUE);
 
 	pmu_s3_stats_update(0);
@@ -2055,6 +2055,15 @@ static int __init mid_pci_register_init(void)
 	if (mid_pmu_cxt == NULL)
 		return -ENOMEM;
 
+	mid_pmu_cxt->s3_restrict_qos =
+		kzalloc(sizeof(struct pm_qos_request), GFP_KERNEL);
+	if (mid_pmu_cxt->s3_restrict_qos) {
+		pm_qos_add_request(mid_pmu_cxt->s3_restrict_qos,
+			 PM_QOS_CPU_DMA_LATENCY, PM_QOS_DEFAULT_VALUE);
+	} else {
+		return -ENOMEM;
+	}
+
 	init_nc_device_states();
 
 	/* initialize the semaphores */
@@ -2083,6 +2092,9 @@ void pmu_power_off(void)
 
 static void __exit mid_pci_cleanup(void)
 {
+	if (mid_pmu_cxt && mid_pmu_cxt->s3_restrict_qos)
+		pm_qos_remove_request(mid_pmu_cxt->s3_restrict_qos);
+
 	suspend_set_ops(NULL);
 
 	/* registering PCI device */
diff --git a/arch/x86/platform/intel-mid/intel_soc_pmu.h b/arch/x86/platform/intel-mid/intel_soc_pmu.h
index de786abd44c9..ef2965bf1fe6 100644
--- a/arch/x86/platform/intel-mid/intel_soc_pmu.h
+++ b/arch/x86/platform/intel-mid/intel_soc_pmu.h
@@ -348,6 +348,7 @@ struct mid_pmu_dev {
 	struct mid_pmu_stats pmu_stats[SYS_STATE_MAX];
 	struct device_residency pmu_dev_res[MAX_DEVICES];
 	struct delayed_work log_work;
+	struct pm_qos_request *s3_restrict_qos;
 
 #ifdef LOG_PMU_EVENTS
 	struct mid_pmu_cmd_log cmd_log[LOG_SIZE];
-- 
2.37.3

