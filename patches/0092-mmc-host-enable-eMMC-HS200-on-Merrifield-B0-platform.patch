From ac78f7aa1cc41b30e4adc49fe973d46ea88b4b15 Mon Sep 17 00:00:00 2001
From: Yunpeng Gao <yunpeng.gao@intel.com>
Date: Fri, 11 Oct 2013 18:52:37 +0800
Subject: [PATCH 092/429] mmc:host: enable eMMC HS200 on Merrifield B0 platform

This patch enable eMMC HS200 feature on Merrifield B0
eMMC0 host controller. According to the feedback, some
FLIS setting has been changed for HS200.

Signed-off-by: Yunpeng Gao <yunpeng.gao@intel.com>
---
 .../device_libs/pci/platform_sdhci_pci.c      |  97 +++++--
 drivers/mmc/host/sdhci-pci.c                  | 260 ++++++++++++++++++
 drivers/mmc/host/sdhci.c                      |  17 ++
 drivers/mmc/host/sdhci.h                      |   5 +
 include/linux/mmc/sdhci-pci-data.h            |   3 +
 5 files changed, 363 insertions(+), 19 deletions(-)

diff --git a/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c b/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c
index 882944121b27..3b22e3b775cb 100644
--- a/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c
+++ b/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c
@@ -71,6 +71,7 @@ int sdhci_pdata_set_quirks(const unsigned int quirks)
 	return 0;
 }
 
+static int mrfl_flis_check(void *data, unsigned int clk);
 static int mrfl_sdio_setup(struct sdhci_pci_data *data);
 static void mrfl_sdio_cleanup(struct sdhci_pci_data *data);
 
@@ -199,7 +200,6 @@ static int clv_sdio_setup(struct sdhci_pci_data *data)
 	return 0;
 }
 
-
 /* CLV platform data */
 static struct sdhci_pci_data clv_sdhci_pci_data[] = {
 	[EMMC0_INDEX] = {
@@ -239,6 +239,77 @@ static struct sdhci_pci_data clv_sdhci_pci_data[] = {
 	},
 };
 
+#define TNG_EMMC_0_FLIS_ADDR		0xff0c0900
+#define TNG_EMMC_FLIS_SLEW		0x00000400
+#define TNG_EMMC_0_CLK_PULLDOWN		0x00000200
+static int mrfl_flis_slew_change(int slew)
+{
+	void __iomem *flis_addr;
+	unsigned int reg;
+	int i, ret = 0;
+
+	flis_addr = ioremap_nocache(TNG_EMMC_0_FLIS_ADDR, 64);
+
+	if (!flis_addr) {
+		pr_err("flis_addr ioremap fail!\n");
+		ret = -ENOMEM;
+	} else {
+		pr_info("flis_addr mapped addr: %p\n", flis_addr);
+		/*
+		 * Change TNG gpio FLIS settings for all eMMC0
+		 * CLK/CMD/DAT pins.
+		 * That is, including emmc_0_clk, emmc_0_cmd,
+		 * emmc_0_d_0, emmc_0_d_1, emmc_0_d_2, emmc_0_d_3,
+		 * emmc_0_d_4, emmc_0_d_5, emmc_0_d_6, emmc_0_d_7
+		 */
+		for (i = 0; i < 10; i++) {
+			reg = readl(flis_addr + (i * 4));
+			if (slew)
+				reg |= TNG_EMMC_FLIS_SLEW; /* SLEW B */
+			else
+				reg &= ~TNG_EMMC_FLIS_SLEW; /* SLEW A */
+			writel(reg, flis_addr + (i * 4));
+		}
+
+		/* Disable PullDown for emmc_0_clk */
+		reg = readl(flis_addr);
+		reg &= ~TNG_EMMC_0_CLK_PULLDOWN;
+		writel(reg, flis_addr);
+
+		ret = 0;
+	}
+
+	if (flis_addr)
+		iounmap(flis_addr);
+
+	return ret;
+}
+
+static int mrfl_flis_check(void *data, unsigned int clk)
+{
+	struct sdhci_host *host = data;
+	int ret = 0;
+
+	if ((host->clock <= 52000000) && (clk > 52000000))
+		ret = mrfl_flis_slew_change(1);
+	else if ((host->clock > 52000000) && (clk <= 52000000))
+		ret = mrfl_flis_slew_change(0);
+
+	return ret;
+}
+
+/* Board specific setup related to eMMC goes here */
+static int mrfl_emmc_setup(struct sdhci_pci_data *data)
+{
+	struct pci_dev *pdev = data->pdev;
+	int ret = 0;
+
+	if (pdev->revision == 0x01) /* TNB B0 stepping */
+		ret = mrfl_flis_slew_change(1); /* HS200 FLIS slew setting */
+
+	return ret;
+}
+
 /* Board specific setup related to SD goes here */
 static int mrfl_sd_setup(struct sdhci_pci_data *data)
 {
@@ -275,12 +346,6 @@ static void mrfl_sd_cleanup(struct sdhci_pci_data *data)
 {
 }
 
-
-/* Board specific cleanup related to SDIO goes here */
-static void mrfl_sdio_cleanup(struct sdhci_pci_data *data)
-{
-}
-
 /* Board specific setup related to SDIO goes here */
 static int mrfl_sdio_setup(struct sdhci_pci_data *data)
 {
@@ -301,6 +366,11 @@ static int mrfl_sdio_setup(struct sdhci_pci_data *data)
 	return 0;
 }
 
+/* Board specific cleanup related to SDIO goes here */
+static void mrfl_sdio_cleanup(struct sdhci_pci_data *data)
+{
+}
+
 /* MRFL platform data */
 static struct sdhci_pci_data mrfl_sdhci_pci_data[] = {
 	[EMMC0_INDEX] = {
@@ -310,20 +380,10 @@ static struct sdhci_pci_data mrfl_sdhci_pci_data[] = {
 			.cd_gpio = -EINVAL,
 			.quirks = 0,
 			.platform_quirks = 0,
-			.setup = 0,
+			.setup = mrfl_emmc_setup,
 			.cleanup = 0,
 			.power_up = panic_mode_emmc0_power_up,
 	},
-	[EMMC1_INDEX] = {
-			.pdev = NULL,
-			.slotno = EMMC1_INDEX,
-			.rst_n_gpio = 97,
-			.cd_gpio = -EINVAL,
-			.quirks = 0,
-			.platform_quirks = 0,
-			.setup = 0,
-			.cleanup = 0,
-	},
 	[SD_INDEX] = {
 			.pdev = NULL,
 			.slotno = SD_INDEX,
@@ -346,7 +406,6 @@ static struct sdhci_pci_data mrfl_sdhci_pci_data[] = {
 	},
 };
 
-
 /* Board specific setup related to SDIO goes here */
 static int byt_sdio_setup(struct sdhci_pci_data *data)
 {
diff --git a/drivers/mmc/host/sdhci-pci.c b/drivers/mmc/host/sdhci-pci.c
index 1d940dd82087..6a605dbe385e 100644
--- a/drivers/mmc/host/sdhci-pci.c
+++ b/drivers/mmc/host/sdhci-pci.c
@@ -378,6 +378,179 @@ static const struct sdhci_pci_fixes sdhci_intel_byt_sdio = {
 };
 
 static const struct sdhci_pci_fixes sdhci_intel_byt_sd = {
+	.quirks2	= SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+		SDHCI_QUIRK2_POWER_PIN_GPIO_MODE,
+	.allow_runtime_pm = true,
+	.probe_slot	= byt_sd_probe_slot,
+	.remove_slot	= byt_sd_remove_slot,
+};
+
+#define TNG_IOAPIC_IDX	0xfec00000
+static void mrfl_ioapic_rte_reg_addr_map(struct sdhci_pci_slot *slot)
+{
+	slot->host->rte_addr = ioremap_nocache(TNG_IOAPIC_IDX, 256);
+	if (!slot->host->rte_addr)
+		dev_err(&slot->chip->pdev->dev, "rte_addr ioremap fail!\n");
+	else
+		dev_info(&slot->chip->pdev->dev, "rte_addr mapped addr: %p\n",
+			slot->host->rte_addr);
+}
+
+/* Define Host controllers for Intel Merrifield platform */
+#define INTEL_MRFL_EMMC_0	0
+#define INTEL_MRFL_EMMC_1	1
+#define INTEL_MRFL_SD		2
+#define INTEL_MRFL_SDIO		3
+
+static int intel_mrfl_mmc_probe_slot(struct sdhci_pci_slot *slot)
+{
+	int ret = 0;
+
+	switch (PCI_FUNC(slot->chip->pdev->devfn)) {
+	case INTEL_MRFL_EMMC_0:
+		sdhci_alloc_panic_host(slot->host);
+		slot->host->mmc->caps |= MMC_CAP_8_BIT_DATA |
+					MMC_CAP_NONREMOVABLE |
+					MMC_CAP_1_8V_DDR;
+		slot->host->mmc->caps2 |= MMC_CAP2_POLL_R1B_BUSY |
+					MMC_CAP2_INIT_CARD_SYNC |
+					MMC_CAP2_CACHE_CTRL;
+		if (slot->chip->pdev->revision == 0x1) { /* B0 stepping */
+			slot->host->mmc->caps2 |= MMC_CAP2_HS200_1_8V_SDR;
+			/* WA for async abort silicon issue */
+			slot->host->quirks2 |= SDHCI_QUIRK2_CARD_CD_DELAY |
+					SDHCI_QUIRK2_WAIT_FOR_IDLE;
+		}
+		mrfl_ioapic_rte_reg_addr_map(slot);
+		break;
+	case INTEL_MRFL_SD:
+		slot->host->quirks2 |= SDHCI_QUIRK2_WAIT_FOR_IDLE;
+		slot->host->mmc->caps2 |= MMC_CAP2_FIXED_NCRC;
+		break;
+	case INTEL_MRFL_SDIO:
+		slot->host->mmc->caps |= MMC_CAP_NONREMOVABLE;
+		break;
+	}
+
+	if (slot->data->platform_quirks & PLFM_QUIRK_NO_HIGH_SPEED) {
+		slot->host->quirks2 |= SDHCI_QUIRK2_DISABLE_HIGH_SPEED;
+		slot->host->mmc->caps &= ~MMC_CAP_1_8V_DDR;
+	}
+
+	if (slot->data->platform_quirks & PLFM_QUIRK_NO_EMMC_BOOT_PART)
+		slot->host->mmc->caps2 |= MMC_CAP2_BOOTPART_NOACC;
+
+	if (slot->data->platform_quirks & PLFM_QUIRK_NO_HOST_CTRL_HW) {
+		dev_info(&slot->chip->pdev->dev, "Disable MMC Func %d.\n",
+			PCI_FUNC(slot->chip->pdev->devfn));
+		ret = -ENODEV;
+	}
+
+	return ret;
+}
+
+static void intel_mrfl_mmc_remove_slot(struct sdhci_pci_slot *slot, int dead)
+{
+	if (PCI_FUNC(slot->chip->pdev->devfn) == INTEL_MRFL_EMMC_0)
+		if (slot->host->rte_addr)
+			iounmap(slot->host->rte_addr);
+}
+
+static const struct sdhci_pci_fixes sdhci_intel_mrfl_mmc = {
+	.quirks		= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
+	.quirks2	= SDHCI_QUIRK2_BROKEN_AUTO_CMD23 |
+				SDHCI_QUIRK2_HIGH_SPEED_SET_LATE |
+				SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+	.allow_runtime_pm = true,
+	.probe_slot	= intel_mrfl_mmc_probe_slot,
+	.remove_slot	= intel_mrfl_mmc_remove_slot,
+};
+
+static int intel_moor_emmc_probe_slot(struct sdhci_pci_slot *slot)
+{
+	slot->host->mmc->caps |= MMC_CAP_8_BIT_DATA |
+				MMC_CAP_NONREMOVABLE |
+				MMC_CAP_1_8V_DDR;
+
+	sdhci_alloc_panic_host(slot->host);
+
+	slot->host->mmc->caps2 |= MMC_CAP2_POLL_R1B_BUSY |
+				MMC_CAP2_INIT_CARD_SYNC;
+
+	if (slot->data)
+		if (slot->data->platform_quirks & PLFM_QUIRK_NO_HIGH_SPEED) {
+			slot->host->quirks2 |= SDHCI_QUIRK2_DISABLE_HIGH_SPEED;
+			slot->host->mmc->caps &= ~MMC_CAP_1_8V_DDR;
+		}
+
+	if (slot->data)
+		if (slot->data->platform_quirks & PLFM_QUIRK_NO_EMMC_BOOT_PART)
+			slot->host->mmc->caps2 |= MMC_CAP2_BOOTPART_NOACC;
+
+	return 0;
+}
+
+static void intel_moor_emmc_remove_slot(struct sdhci_pci_slot *slot, int dead)
+{
+}
+
+static int intel_moor_sd_probe_slot(struct sdhci_pci_slot *slot)
+{
+	int ret = 0;
+
+	if (slot->data)
+		if (slot->data->platform_quirks & PLFM_QUIRK_NO_HOST_CTRL_HW)
+			ret = -ENODEV;
+
+	return ret;
+}
+
+static void intel_moor_sd_remove_slot(struct sdhci_pci_slot *slot, int dead)
+{
+}
+
+static int intel_moor_sdio_probe_slot(struct sdhci_pci_slot *slot)
+{
+	int ret = 0;
+
+	slot->host->mmc->caps |= MMC_CAP_NONREMOVABLE;
+
+	if (slot->data)
+		if (slot->data->platform_quirks & PLFM_QUIRK_NO_HOST_CTRL_HW)
+			ret = -ENODEV;
+
+	return ret;
+}
+
+static void intel_moor_sdio_remove_slot(struct sdhci_pci_slot *slot, int dead)
+{
+}
+
+static const struct sdhci_pci_fixes sdhci_intel_moor_emmc = {
+	.quirks		= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
+	.quirks2	= SDHCI_QUIRK2_BROKEN_AUTO_CMD23 |
+				SDHCI_QUIRK2_HIGH_SPEED_SET_LATE,
+	.allow_runtime_pm = true,
+	.probe_slot	= intel_moor_emmc_probe_slot,
+	.remove_slot	= intel_moor_emmc_remove_slot,
+};
+
+static const struct sdhci_pci_fixes sdhci_intel_moor_sd = {
+	.quirks		= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
+	.quirks2	= SDHCI_QUIRK2_BROKEN_AUTO_CMD23 |
+				SDHCI_QUIRK2_HIGH_SPEED_SET_LATE,
+	.allow_runtime_pm = true,
+	.probe_slot	= intel_moor_sd_probe_slot,
+	.remove_slot	= intel_moor_sd_remove_slot,
+};
+
+static const struct sdhci_pci_fixes sdhci_intel_moor_sdio = {
+	.quirks		= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
+	.quirks2	= SDHCI_QUIRK2_BROKEN_AUTO_CMD23 |
+				SDHCI_QUIRK2_HIGH_SPEED_SET_LATE,
+	.allow_runtime_pm = true,
+	.probe_slot	= intel_moor_sdio_probe_slot,
+	.remove_slot	= intel_moor_sdio_remove_slot,
 };
 
 /* O2Micro extra registers */
@@ -1120,10 +1293,97 @@ static int sdhci_pci_power_up_host(struct sdhci_host *host)
 	return 0;
 }
 
+static void sdhci_pci_set_dev_power(struct sdhci_host *host, bool poweron)
+{
+	struct sdhci_pci_slot *slot;
+	struct sdhci_pci_chip *chip;
+
+	slot = sdhci_priv(host);
+	if (slot)
+		chip = slot->chip;
+	else
+		return;
+
+	/* only available for Intel CTP platform */
+	if (chip && chip->pdev &&
+		chip->pdev->device == PCI_DEVICE_ID_INTEL_CLV_SDIO0) {
+		mutex_lock(&slot->power_lock);
+		if (poweron)
+			ctp_sd_card_power_restore(slot);
+		else
+			ctp_sd_card_power_save(slot);
+		mutex_unlock(&slot->power_lock);
+	}
+}
+
+static int sdhci_pci_get_cd(struct sdhci_host *host)
+{
+	bool present;
+	struct sdhci_pci_slot *slot = sdhci_priv(host);
+
+	if (gpio_is_valid(slot->cd_gpio))
+		return gpio_get_value(slot->cd_gpio) ? 0 : 1;
+
+	/* If nonremovable or polling, assume that the card is always present */
+	if (host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION)
+		present = true;
+	else
+		present = sdhci_readl(host, SDHCI_PRESENT_STATE) &
+			SDHCI_CARD_PRESENT;
+
+	return present;
+}
+
+static void  sdhci_platform_reset_exit(struct sdhci_host *host, u8 mask)
+{
+	if (host->quirks2 & SDHCI_QUIRK2_POWER_PIN_GPIO_MODE) {
+		if (mask & SDHCI_RESET_ALL) {
+			/* reset back to 3.3v signaling */
+			gpio_set_value(host->gpio_1p8_en, 0);
+			/* disable the VDD power */
+			gpio_set_value(host->gpio_pwr_en, 1);
+		}
+	}
+}
+
+static int sdhci_pci_get_tuning_count(struct sdhci_host *host)
+{
+	struct sdhci_pci_slot *slot = sdhci_priv(host);
+	int tuning_count = 0;
+
+	switch (slot->chip->pdev->device) {
+	case PCI_DEVICE_ID_INTEL_BYT_EMMC45:
+		tuning_count = 4; /* using 8 seconds, this can be tuning */
+	case PCI_DEVICE_ID_INTEL_MRFL_MMC:
+		tuning_count = 4; /* using 8 seconds, this can be tuning */
+	default:
+		break;
+	}
+
+	return tuning_count;
+}
+
+static int sdhci_gpio_buf_check(struct sdhci_host *host, unsigned int clk)
+{
+	int ret = -ENOSYS;
+	struct sdhci_pci_slot *slot = sdhci_priv(host);
+
+	if (slot->data && slot->data->flis_check)
+		ret = slot->data->flis_check(host, clk);
+
+	return ret;
+}
+
 static const struct sdhci_ops sdhci_pci_ops = {
 	.enable_dma	= sdhci_pci_enable_dma,
 	.platform_bus_width	= sdhci_pci_bus_width,
 	.hw_reset		= sdhci_pci_hw_reset,
+	.power_up_host		= sdhci_pci_power_up_host,
+	.set_dev_power		= sdhci_pci_set_dev_power,
+	.get_cd		= sdhci_pci_get_cd,
+	.platform_reset_exit = sdhci_platform_reset_exit,
+	.get_tuning_count = sdhci_pci_get_tuning_count,
+	.gpio_buf_check = sdhci_gpio_buf_check,
 };
 
 /*****************************************************************************\
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index c87133adef9e..18aac246179c 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1137,6 +1137,23 @@ static void sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
 	if (clock == 0)
 		goto out;
 
+	/*
+	 * Check and change Host Controller pin GPIO buffer setting
+	 * according to the new clock will be used.
+	 * For example, when the SD bus frequency is 50MHz or 200MHz,
+	 * the controller SD bus CLK/CMD/DAT pin may need different
+	 * driving strength and slew settings.
+	 * So we add check here. And this API will also change the pin
+	 * gpio buffer settings if needed after the check. Of course,
+	 * it's platform specific behaviours.
+	 * To ensure that the clock signal does not change when gpio
+	 * buffer setting modified, we'd better disable SD bus clock
+	 * first before changing any gpio pin buffer settings and
+	 * enable the SD bus clock again after the changing.
+	 */
+	if (host->ops->gpio_buf_check)
+		host->ops->gpio_buf_check(host, clock);
+
 	if (host->version >= SDHCI_SPEC_300) {
 		if (sdhci_readw(host, SDHCI_HOST_CONTROL2) &
 			SDHCI_CTRL_PRESET_VAL_ENABLE) {
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 379e09d9f3c1..ebc0cb7cbc45 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -294,6 +294,11 @@ struct sdhci_ops {
 	void	(*platform_resume)(struct sdhci_host *host);
 	void    (*adma_workaround)(struct sdhci_host *host, u32 intmask);
 	void	(*platform_init)(struct sdhci_host *host);
+	int	(*power_up_host)(struct sdhci_host *host);
+	void	(*set_dev_power)(struct sdhci_host *, bool);
+	int	(*get_cd)(struct sdhci_host *host);
+	int	(*get_tuning_count)(struct sdhci_host *host);
+	int	(*gpio_buf_check)(struct sdhci_host *host, unsigned int clk);
 };
 
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
diff --git a/include/linux/mmc/sdhci-pci-data.h b/include/linux/mmc/sdhci-pci-data.h
index 139e6664dbc9..d1cace208fec 100644
--- a/include/linux/mmc/sdhci-pci-data.h
+++ b/include/linux/mmc/sdhci-pci-data.h
@@ -11,6 +11,9 @@ struct sdhci_pci_data {
 	int		(*setup)(struct sdhci_pci_data *data);
 	void		(*cleanup)(struct sdhci_pci_data *data);
 	int		(*power_up)(void *data);
+	void		(*register_embedded_control)(void *dev_id,
+			   void (*virtual_cd)(void *dev_id, int card_present));
+	int		(*flis_check)(void *data, unsigned int clk);
 };
 
 extern struct sdhci_pci_data *(*sdhci_pci_get_data)(struct pci_dev *pdev,
-- 
2.37.3

