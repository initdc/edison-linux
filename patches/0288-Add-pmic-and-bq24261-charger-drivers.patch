From 095e9f3f8b054c5563227b2d7339d8008e61bcd5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lo=C3=AFc=20Akue?= <loicx.akue@intel.com>
Date: Tue, 1 Apr 2014 17:38:54 +0200
Subject: [PATCH 288/429] Add pmic and bq24261 charger drivers
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Add the pmic and bq24261 charger drivers by moving them from external directory,
back into the kernel tree.

Signed-off-by: Lo√Øc Akue <loicx.akue@intel.com>
---
 arch/x86/include/asm/pmic_pdata.h             |   45 +
 arch/x86/platform/intel-mid/board.c           |    6 +-
 .../platform/intel-mid/device_libs/Makefile   |    1 +
 .../intel-mid/device_libs/platform_bq24261.c  |    6 +-
 drivers/power/Kconfig                         |   20 +
 drivers/power/Makefile                        |    3 +
 drivers/power/bq24261_charger.c               | 1893 ++++++++++++++++
 drivers/power/pmic_ccsm.c                     | 1914 +++++++++++++++++
 drivers/power/pmic_ccsm.h                     |  356 +++
 drivers/rpmsg/virtio_rpmsg_bus.c              |   12 +-
 include/linux/power/battery_id.h              |    2 +-
 include/linux/power/bq24261_charger.h         |   56 +
 include/linux/power_supply.h                  |    2 +-
 13 files changed, 4304 insertions(+), 12 deletions(-)
 create mode 100644 arch/x86/include/asm/pmic_pdata.h
 create mode 100644 drivers/power/bq24261_charger.c
 create mode 100644 drivers/power/pmic_ccsm.c
 create mode 100644 drivers/power/pmic_ccsm.h
 create mode 100644 include/linux/power/bq24261_charger.h

diff --git a/arch/x86/include/asm/pmic_pdata.h b/arch/x86/include/asm/pmic_pdata.h
new file mode 100644
index 000000000000..d88c64adf0e0
--- /dev/null
+++ b/arch/x86/include/asm/pmic_pdata.h
@@ -0,0 +1,45 @@
+#ifndef __PMIC_PDATA_H__
+#define __PMIC_PDATA_H__
+
+struct temp_lookup {
+	int adc_val;
+	int temp;
+	int temp_err;
+};
+
+/*
+ * pmic cove charger driver info
+ */
+struct pmic_platform_data {
+	void (*cc_to_reg)(int, u8*);
+	void (*cv_to_reg)(int, u8*);
+	void (*inlmt_to_reg)(int, u8*);
+	int max_tbl_row_cnt;
+	struct temp_lookup *adc_tbl;
+};
+
+extern int pmic_get_status(void);
+extern int pmic_enable_charging(bool);
+extern int pmic_set_cc(int);
+extern int pmic_set_cv(int);
+extern int pmic_set_ilimma(int);
+extern int pmic_enable_vbus(bool enable);
+/* WA for ShadyCove VBUS removal detect issue */
+extern int pmic_handle_low_supply(void);
+
+extern void dump_pmic_regs(void);
+#ifdef CONFIG_PMIC_CCSM
+extern int pmic_get_health(void);
+extern int pmic_get_battery_pack_temp(int *);
+#else
+static int pmic_get_health(void)
+{
+	return 0;
+}
+static int pmic_get_battery_pack_temp(int *temp)
+{
+	return 0;
+}
+#endif
+
+#endif
diff --git a/arch/x86/platform/intel-mid/board.c b/arch/x86/platform/intel-mid/board.c
index a03c1cc2cffc..e669ae9ba975 100644
--- a/arch/x86/platform/intel-mid/board.c
+++ b/arch/x86/platform/intel-mid/board.c
@@ -72,6 +72,7 @@
 #include "device_libs/platform_lis331.h"
 #include "device_libs/platform_mpu3050.h"
 #include "device_libs/platform_tc35876x.h"
+#include "device_libs/platform_bq24261.h"
 
 /*
  * SPI devices
@@ -96,6 +97,9 @@ struct devs_id __initconst device_ids[] = {
 	{"WLAN_FAST_IRQ", SFI_DEV_TYPE_SD, 0, &no_platform_data,
 	 &wifi_platform_data_fastirq},
 
+	/* I2C devices*/
+	{"bq24261_charger", SFI_DEV_TYPE_I2C, 1, &bq24261_platform_data, NULL},
+
 	/* SPI devices */
 	{"bma023", SFI_DEV_TYPE_I2C, 1, &no_platform_data, NULL},
 	{"pmic_gpio", SFI_DEV_TYPE_SPI, 1, &pmic_gpio_platform_data, NULL},
@@ -142,8 +146,6 @@ struct devs_id __initconst device_ids[] = {
 						&ipc_device_handler},
 	{"i2c_pmic_adap", SFI_DEV_TYPE_IPC, 1, &mrfl_pmic_i2c_platform_data,
 						&ipc_device_handler},
-
-	/* IPC devices */
 	{"soc_thrm", SFI_DEV_TYPE_IPC, 1, &no_platform_data,
 						&soc_thrm_device_handler},
 	{},
diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile
index f6a7dc74eafd..5cc36f737538 100644
--- a/arch/x86/platform/intel-mid/device_libs/Makefile
+++ b/arch/x86/platform/intel-mid/device_libs/Makefile
@@ -34,6 +34,7 @@ obj-$(subst m,y,$(CONFIG_SENSORS_LIS3LV02D)) += platform_lis331.o
 obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_max7315.o
 obj-$(subst m,y,$(CONFIG_SENSORS_MPU3050)) += platform_mpu3050.o
 obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_tca6416.o
+obj-$(subst m,y,$(CONFIG_BQ24261_CHARGER)) += platform_bq24261.o
 # SPI Devices
 obj-$(subst m,y,$(CONFIG_SERIAL_MRST_MAX3110)) += platform_max3111.o
 # MISC Devices
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_bq24261.c b/arch/x86/platform/intel-mid/device_libs/platform_bq24261.c
index acbf29af8f0f..1c1a583516cb 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_bq24261.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_bq24261.c
@@ -22,6 +22,8 @@
 #include "platform_ipc.h"
 #include "platform_bq24261.h"
 
+#define BOOST_CUR_LIM 500
+
 static struct power_supply_throttle bq24261_throttle_states[] = {
 	{
 		.throttle_action = PSY_THROTTLE_CC_LIMIT,
@@ -62,14 +64,14 @@ void __init *bq24261_platform_data(void *info)
 	bq24261_pdata.enable_charger = NULL;
 #ifdef CONFIG_PMIC_CCSM
 	bq24261_pdata.enable_charging = pmic_enable_charging;
-	bq24261_pdata.set_inlmt = pmic_set_ilimmA;
+	bq24261_pdata.set_inlmt = pmic_set_ilimma;
 	bq24261_pdata.set_cc = pmic_set_cc;
 	bq24261_pdata.set_cv = pmic_set_cv;
 	bq24261_pdata.dump_master_regs = dump_pmic_regs;
 	bq24261_pdata.enable_vbus = pmic_enable_vbus;
 #endif
 	bq24261_pdata.set_iterm = NULL;
-	bq24261_pdata.boost_mode_mA = 1000;
+	bq24261_pdata.boost_mode_ma = BOOST_CUR_LIM;
 
 	return &bq24261_pdata;
 }
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 7b8979c63f48..1c83042d0067 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -14,6 +14,26 @@ config POWER_SUPPLY_DEBUG
 	  Say Y here to enable debugging messages for power supply class
 	  and drivers.
 
+config PMIC_CCSM
+	tristate "PMIC CCSM driver"
+	select POWER_SUPPLY_BATTID
+	depends on INTEL_SCU_IPC && IIO
+	help
+	  Say Y to include support for PMIC Charger Control State Machine driver
+	  Driver for initializing and monitoring the CCSM in PMIC
+	  This driver sets the CCSM registers and handles the PMIC
+	  charger interrupts.
+
+config BQ24261_CHARGER
+	tristate "BQ24261 charger driver"
+	select POWER_SUPPLY_CHARGER
+	depends on I2C
+	help
+	  Say Y to include support for BQ24261 Charger driver. This driver
+	  makes use of power supply charging framework. So the driver gives
+	  the charger hardware abstraction only. Charging logic is abstracted
+	  in the charging framework.
+
 config PDA_POWER
 	tristate "Generic PDA/phone power driver"
 	depends on !S390
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index 31f7ec642f83..ad734a209733 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -57,3 +57,6 @@ obj-$(CONFIG_POWER_AVS)		+= avs/
 obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
 obj-$(CONFIG_CHARGER_TPS65090)	+= tps65090-charger.o
 obj-$(CONFIG_POWER_RESET)	+= reset/
+
+obj-$(CONFIG_BQ24261_CHARGER)	+= bq24261_charger.o
+obj-$(CONFIG_PMIC_CCSM) += pmic_ccsm.o
diff --git a/drivers/power/bq24261_charger.c b/drivers/power/bq24261_charger.c
new file mode 100644
index 000000000000..a1c9aa67030d
--- /dev/null
+++ b/drivers/power/bq24261_charger.c
@@ -0,0 +1,1893 @@
+/*
+ * bq24261_charger.c - BQ24261 Charger I2C client driver
+ *
+ * Copyright (C) 2011 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Jenny TC <jenny.tc@intel.com>
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/power_supply.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/usb/otg.h>
+#include <linux/power/bq24261_charger.h>
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+
+#include <asm/intel_scu_ipc.h>
+
+#define DEV_NAME "bq24261_charger"
+#define DEV_MANUFACTURER "TI"
+#define MODEL_NAME_SIZE 8
+#define DEV_MANUFACTURER_NAME_SIZE 4
+
+#define CHRG_TERM_WORKER_DELAY (30 * HZ)
+#define EXCEPTION_MONITOR_DELAY (60 * HZ)
+#define WDT_RESET_DELAY (15 * HZ)
+
+/* BQ24261 registers */
+#define BQ24261_STAT_CTRL0_ADDR		0x00
+#define BQ24261_CTRL_ADDR		0x01
+#define BQ24261_BATT_VOL_CTRL_ADDR	0x02
+#define BQ24261_VENDOR_REV_ADDR		0x03
+#define BQ24261_TERM_FCC_ADDR		0x04
+#define BQ24261_VINDPM_STAT_ADDR	0x05
+#define BQ24261_ST_NTC_MON_ADDR		0x06
+
+#define BQ24261_RESET_MASK		(0x01 << 7)
+#define BQ24261_RESET_ENABLE		(0x01 << 7)
+
+#define BQ24261_FAULT_MASK		0x07
+#define BQ24261_STAT_MASK		(0x03 << 4)
+#define BQ24261_BOOST_MASK		(0x01 << 6)
+#define BQ24261_TMR_RST_MASK		(0x01 << 7)
+#define BQ24261_TMR_RST			(0x01 << 7)
+
+#define BQ24261_ENABLE_BOOST		(0x01 << 6)
+
+#define BQ24261_VOVP			0x01
+#define BQ24261_LOW_SUPPLY		0x02
+#define BQ24261_THERMAL_SHUTDOWN	0x03
+#define BQ24261_BATT_TEMP_FAULT		0x04
+#define BQ24261_TIMER_FAULT		0x05
+#define BQ24261_BATT_OVP		0x06
+#define BQ24261_NO_BATTERY		0x07
+#define BQ24261_STAT_READY		0x00
+
+#define BQ24261_STAT_CHRG_PRGRSS	(0x01 << 4)
+#define BQ24261_STAT_CHRG_DONE		(0x02 << 4)
+#define BQ24261_STAT_FAULT		(0x03 << 4)
+
+#define BQ24261_CE_MASK			(0x01 << 1)
+#define BQ24261_CE_DISABLE		(0x01 << 1)
+
+#define BQ24261_HZ_MASK			(0x01)
+#define BQ24261_HZ_ENABLE		(0x01)
+
+#define BQ24261_ICHRG_MASK		(0x1F << 3)
+#define BQ24261_ICHRG_100ma		(0x01 << 3)
+#define BQ24261_ICHRG_200ma		(0x01 << 4)
+#define BQ24261_ICHRG_400ma		(0x01 << 5)
+#define BQ24261_ICHRG_800ma		(0x01 << 6)
+#define BQ24261_ICHRG_1600ma		(0x01 << 7)
+
+#define BQ24261_ITERM_MASK		(0x03)
+#define BQ24261_ITERM_50ma		(0x01 << 0)
+#define BQ24261_ITERM_100ma		(0x01 << 1)
+#define BQ24261_ITERM_200ma		(0x01 << 2)
+
+#define BQ24261_VBREG_MASK		(0x3F << 2)
+
+#define BQ24261_INLMT_MASK		(0x03 << 4)
+#define BQ24261_INLMT_100		0x00
+#define BQ24261_INLMT_150		(0x01 << 4)
+#define BQ24261_INLMT_500		(0x02 << 4)
+#define BQ24261_INLMT_900		(0x03 << 4)
+#define BQ24261_INLMT_1500		(0x04 << 4)
+#define BQ24261_INLMT_2500		(0x06 << 4)
+
+#define BQ24261_TE_MASK			(0x01 << 2)
+#define BQ24261_TE_ENABLE		(0x01 << 2)
+#define BQ24261_STAT_ENABLE_MASK	(0x01 << 3)
+#define BQ24261_STAT_ENABLE		(0x01 << 3)
+
+#define BQ24261_VENDOR_MASK		(0x07 << 5)
+#define BQ24261_VENDOR			(0x02 << 5)
+#define BQ24261_REV_MASK		(0x07)
+#define BQ24261_2_3_REV			(0x06)
+#define BQ24261_REV			(0x02)
+#define BQ24260_REV			(0x01)
+
+#define BQ24261_TS_MASK			(0x01 << 3)
+#define BQ24261_TS_ENABLED		(0x01 << 3)
+#define BQ24261_BOOST_ILIM_MASK		(0x01 << 4)
+#define BQ24261_BOOST_ILIM_500ma	(0x0)
+#define BQ24261_BOOST_ILIM_1A		(0x01 << 4)
+
+#define BQ24261_SAFETY_TIMER_MASK	(0x03 << 5)
+#define BQ24261_SAFETY_TIMER_40MIN	0x00
+#define BQ24261_SAFETY_TIMER_6HR	(0x01 << 5)
+#define BQ24261_SAFETY_TIMER_9HR	(0x02 << 5)
+#define BQ24261_SAFETY_TIMER_DISABLED	(0x03 << 5)
+
+/* 1% above voltage max design to report over voltage */
+#define BQ24261_OVP_MULTIPLIER			1010
+#define BQ24261_OVP_RECOVER_MULTIPLIER		990
+#define BQ24261_DEF_BAT_VOLT_MAX_DESIGN		4200000
+
+/* Settings for Voltage / DPPM Register (05) */
+#define BQ24261_VBATT_LEVEL1		3700000
+#define BQ24261_VBATT_LEVEL2		3960000
+#define BQ24261_VINDPM_MASK		(0x07)
+#define BQ24261_VINDPM_320MV		(0x01 << 2)
+#define BQ24261_VINDPM_160MV		(0x01 << 1)
+#define BQ24261_VINDPM_80MV		(0x01 << 0)
+#define BQ24261_CD_STATUS_MASK		(0x01 << 3)
+#define BQ24261_DPM_EN_MASK		(0x01 << 4)
+#define BQ24261_DPM_EN_FORCE		(0x01 << 4)
+#define BQ24261_LOW_CHG_MASK		(0x01 << 5)
+#define BQ24261_LOW_CHG_EN		(0x01 << 5)
+#define BQ24261_LOW_CHG_DIS		(~BQ24261_LOW_CHG_EN)
+#define BQ24261_DPM_STAT_MASK		(0x01 << 6)
+#define BQ24261_MINSYS_STAT_MASK	(0x01 << 7)
+
+#define BQ24261_MIN_CC			500
+
+u16 bq24261_sfty_tmr[][2] = {
+	{0, BQ24261_SAFETY_TIMER_DISABLED}
+	,
+	{40, BQ24261_SAFETY_TIMER_40MIN}
+	,
+	{360, BQ24261_SAFETY_TIMER_6HR}
+	,
+	{540, BQ24261_SAFETY_TIMER_9HR}
+	,
+};
+
+
+u16 bq24261_inlmt[][2] = {
+	{100, BQ24261_INLMT_100}
+	,
+	{150, BQ24261_INLMT_150}
+	,
+	{500, BQ24261_INLMT_500}
+	,
+	{900, BQ24261_INLMT_900}
+	,
+	{1500, BQ24261_INLMT_1500}
+	,
+	{2500, BQ24261_INLMT_2500}
+	,
+};
+
+u16 bq24261_iterm[][2] = {
+	{0, 0x00}
+	,
+	{50, BQ24261_ITERM_50ma}
+	,
+	{100, BQ24261_ITERM_100ma}
+	,
+	{150, BQ24261_ITERM_100ma | BQ24261_ITERM_50ma}
+	,
+	{200, BQ24261_ITERM_200ma}
+	,
+	{250, BQ24261_ITERM_200ma | BQ24261_ITERM_50ma}
+	,
+	{300, BQ24261_ITERM_200ma | BQ24261_ITERM_100ma}
+	,
+	{350, BQ24261_ITERM_200ma | BQ24261_ITERM_100ma | BQ24261_ITERM_50ma}
+	,
+};
+
+u16 bq24261_cc[][2] = {
+
+	{500, 0x00}
+	,
+	{600, BQ24261_ICHRG_100ma}
+	,
+	{700, BQ24261_ICHRG_200ma}
+	,
+	{800, BQ24261_ICHRG_100ma | BQ24261_ICHRG_200ma}
+	,
+	{900, BQ24261_ICHRG_400ma}
+	,
+	{1000, BQ24261_ICHRG_400ma | BQ24261_ICHRG_100ma}
+	,
+	{1100, BQ24261_ICHRG_400ma | BQ24261_ICHRG_200ma}
+	,
+	{1200, BQ24261_ICHRG_400ma | BQ24261_ICHRG_200ma | BQ24261_ICHRG_100ma}
+	,
+	{1300, BQ24261_ICHRG_800ma}
+	,
+	{1400, BQ24261_ICHRG_800ma | BQ24261_ICHRG_100ma}
+	,
+	{1500, BQ24261_ICHRG_800ma | BQ24261_ICHRG_200ma}
+	,
+};
+
+#define BQ24261_MIN_CV 3500
+#define BQ24261_MAX_CV 4440
+#define BQ24261_CV_DIV 20
+#define BQ24261_CV_BIT_POS 2
+
+static enum power_supply_property bq24261_usb_props[] = {
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_INLMT,
+	POWER_SUPPLY_PROP_ENABLE_CHARGING,
+	POWER_SUPPLY_PROP_ENABLE_CHARGER,
+	POWER_SUPPLY_PROP_CHARGE_TERM_CUR,
+	POWER_SUPPLY_PROP_CABLE_TYPE,
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_MAX_TEMP,
+	POWER_SUPPLY_PROP_MIN_TEMP,
+};
+
+enum bq24261_chrgr_stat {
+	BQ24261_CHRGR_STAT_UNKNOWN,
+	BQ24261_CHRGR_STAT_READY,
+	BQ24261_CHRGR_STAT_CHARGING,
+	BQ24261_CHRGR_STAT_BAT_FULL,
+	BQ24261_CHRGR_STAT_FAULT,
+};
+
+struct bq24261_otg_event {
+	struct list_head node;
+	bool is_enable;
+};
+
+struct bq24261_charger {
+
+	struct mutex lock;
+	struct i2c_client *client;
+	struct bq24261_plat_data *pdata;
+	struct power_supply psy_usb;
+	struct delayed_work sw_term_work;
+	struct delayed_work wdt_work;
+	struct delayed_work low_supply_fault_work;
+	struct delayed_work exception_mon_work;
+	struct notifier_block otg_nb;
+	struct usb_phy *transceiver;
+	struct work_struct otg_work;
+	struct work_struct irq_work;
+	struct list_head otg_queue;
+	struct list_head irq_queue;
+	wait_queue_head_t wait_ready;
+	spinlock_t otg_queue_lock;
+	void __iomem *irq_iomap;
+
+	int chrgr_health;
+	int bat_health;
+	int cc;
+	int cv;
+	int inlmt;
+	int max_cc;
+	int max_cv;
+	int iterm;
+	int cable_type;
+	int cntl_state;
+	int max_temp;
+	int min_temp;
+	int revision;
+	enum bq24261_chrgr_stat chrgr_stat;
+	bool online;
+	bool present;
+	bool is_charging_enabled;
+	bool is_charger_enabled;
+	bool is_vsys_on;
+	bool boost_mode;
+	bool is_hw_chrg_term;
+	char model_name[MODEL_NAME_SIZE];
+	char manufacturer[DEV_MANUFACTURER_NAME_SIZE];
+};
+
+enum bq2426x_model_num {
+	BQ2426X = 0,
+	BQ24260,
+	BQ24261,
+};
+
+struct bq2426x_model {
+	char model_name[MODEL_NAME_SIZE];
+	enum bq2426x_model_num model;
+};
+
+static struct bq2426x_model bq24261_model_name[] = {
+	{ "bq2426x", BQ2426X },
+	{ "bq24260", BQ24260 },
+	{ "bq24261", BQ24261 },
+};
+
+struct i2c_client *bq24261_client;
+static inline int get_battery_voltage(int *volt);
+static inline int get_battery_current(int *cur);
+static int bq24261_handle_irq(struct bq24261_charger *chip, u8 stat_reg);
+static inline int bq24261_set_iterm(struct bq24261_charger *chip, int iterm);
+
+enum power_supply_type get_power_supply_type(
+		enum power_supply_charger_cable_type cable)
+{
+
+	switch (cable) {
+
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+		return POWER_SUPPLY_TYPE_USB_DCP;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+		return POWER_SUPPLY_TYPE_USB_CDP;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_ACA:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+		return POWER_SUPPLY_TYPE_USB_ACA;
+	case POWER_SUPPLY_CHARGER_TYPE_AC:
+		return POWER_SUPPLY_TYPE_MAINS;
+	case POWER_SUPPLY_CHARGER_TYPE_NONE:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+	default:
+		return POWER_SUPPLY_TYPE_USB;
+	}
+
+	return POWER_SUPPLY_TYPE_USB;
+}
+
+static void lookup_regval(u16 tbl[][2], size_t size, u16 in_val, u8 *out_val)
+{
+	int i;
+	for (i = 1; i < size; ++i)
+		if (in_val < tbl[i][0])
+			break;
+
+	*out_val = (u8) tbl[i - 1][1];
+}
+
+void bq24261_cc_to_reg(int cc, u8 *reg_val)
+{
+	return lookup_regval(bq24261_cc, ARRAY_SIZE(bq24261_cc), cc, reg_val);
+
+}
+
+void bq24261_cv_to_reg(int cv, u8 *reg_val)
+{
+	int val;
+
+	val = clamp_t(int, cv, BQ24261_MIN_CV, BQ24261_MAX_CV);
+	*reg_val =
+		(((val - BQ24261_MIN_CV) / BQ24261_CV_DIV)
+			<< BQ24261_CV_BIT_POS);
+}
+
+void bq24261_inlmt_to_reg(int inlmt, u8 *regval)
+{
+	return lookup_regval(bq24261_inlmt, ARRAY_SIZE(bq24261_inlmt),
+			     inlmt, regval);
+}
+
+static inline void bq24261_iterm_to_reg(int iterm, u8 *regval)
+{
+	return lookup_regval(bq24261_iterm, ARRAY_SIZE(bq24261_iterm),
+			     iterm, regval);
+}
+
+static inline void bq24261_sfty_tmr_to_reg(int tmr, u8 *regval)
+{
+	return lookup_regval(bq24261_sfty_tmr, ARRAY_SIZE(bq24261_sfty_tmr),
+			     tmr, regval);
+}
+
+static inline int bq24261_read_reg(struct i2c_client *client, u8 reg)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0)
+		dev_err(&client->dev, "Error(%d) in reading reg %d\n", ret,
+			reg);
+
+	return ret;
+}
+
+
+static inline void bq24261_dump_regs(bool dump_master)
+{
+	int i;
+	int ret;
+	int bat_cur, bat_volt;
+	struct bq24261_charger *chip;
+
+	if (!bq24261_client)
+		return;
+
+	chip = i2c_get_clientdata(bq24261_client);
+
+	ret = get_battery_current(&bat_cur);
+	if (ret)
+		dev_err(&bq24261_client->dev,
+			"%s: Error in getting battery current", __func__);
+	else
+		dev_info(&bq24261_client->dev, "Battery Current=%dma\n",
+				(bat_cur/1000));
+
+	ret = get_battery_voltage(&bat_volt);
+	if (ret)
+		dev_err(&bq24261_client->dev,
+			"%s: Error in getting battery voltage", __func__);
+	else
+		dev_info(&bq24261_client->dev, "Battery VOlatge=%dmV\n",
+			(bat_volt/1000));
+
+
+	dev_info(&bq24261_client->dev, "BQ24261 Register dump\n");
+
+	dev_info(&bq24261_client->dev, "*======================*\n");
+	for (i = 0; i < 7; ++i) {
+		ret = bq24261_read_reg(bq24261_client, i);
+		if (ret < 0)
+			dev_err(&bq24261_client->dev,
+				"Error in reading REG 0x%X\n", i);
+		else
+			dev_info(&bq24261_client->dev,
+				"0x%X=0x%X ", i, ret);
+	}
+	dev_info(&bq24261_client->dev, "*======================*\n");
+
+	if (chip->pdata->dump_master_regs && dump_master)
+			chip->pdata->dump_master_regs();
+
+}
+
+
+#ifdef CONFIG_DEBUG_FS
+static int bq24261_reg_show(struct seq_file *seq, void *unused)
+{
+	int val;
+	u8 reg;
+
+	reg = *((u8 *)seq->private);
+	val = bq24261_read_reg(bq24261_client, reg);
+
+	seq_printf(seq, "0x%02x\n", val);
+	return 0;
+}
+
+static int bq24261_dbgfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, bq24261_reg_show, inode->i_private);
+}
+
+static u32 bq24261_register_set[] = {
+	BQ24261_STAT_CTRL0_ADDR,
+	BQ24261_CTRL_ADDR,
+	BQ24261_BATT_VOL_CTRL_ADDR,
+	BQ24261_VENDOR_REV_ADDR,
+	BQ24261_TERM_FCC_ADDR,
+	BQ24261_VINDPM_STAT_ADDR,
+	BQ24261_ST_NTC_MON_ADDR,
+};
+
+static struct dentry *bq24261_dbgfs_dir;
+
+static const struct file_operations bq24261_dbg_fops = {
+	.open = bq24261_dbgfs_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release
+};
+
+static void bq24261_debugfs_init(void)
+{
+	struct dentry *fentry;
+	u32 count = ARRAY_SIZE(bq24261_register_set);
+	u32 i;
+	char name[6] = {0};
+
+	bq24261_dbgfs_dir = debugfs_create_dir(DEV_NAME, NULL);
+	if (bq24261_dbgfs_dir == NULL)
+		goto debugfs_root_exit;
+
+	for (i = 0; i < count; i++) {
+		snprintf(name, 6, "%02x", bq24261_register_set[i]);
+		fentry = debugfs_create_file(name, S_IRUGO,
+						bq24261_dbgfs_dir,
+						&bq24261_register_set[i],
+						&bq24261_dbg_fops);
+		if (fentry == NULL)
+			goto debugfs_err_exit;
+	}
+	dev_err(&bq24261_client->dev, "Debugfs created successfully!!\n");
+	return;
+
+debugfs_err_exit:
+	debugfs_remove_recursive(bq24261_dbgfs_dir);
+debugfs_root_exit:
+	dev_err(&bq24261_client->dev, "Error Creating debugfs!!\n");
+	return;
+}
+
+static void bq24261_debugfs_exit(void)
+{
+	if (bq24261_dbgfs_dir)
+		debugfs_remove_recursive(bq24261_dbgfs_dir);
+
+	return;
+}
+
+#else
+static void bq24261_debugfs_init(void)
+{
+	return;
+}
+
+static void bq24261_debugfs_exit(void)
+{
+	return;
+}
+#endif
+
+static inline int bq24261_write_reg(struct i2c_client *client, u8 reg, u8 data)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, reg, data);
+	if (ret < 0)
+		dev_err(&client->dev, "Error(%d) in writing %d to reg %d\n",
+			ret, data, reg);
+
+	return ret;
+}
+
+static inline int bq24261_read_modify_reg(struct i2c_client *client, u8 reg,
+					  u8 mask, u8 val)
+{
+	int ret;
+
+	ret = bq24261_read_reg(client, reg);
+	if (ret < 0)
+		return ret;
+	ret = (ret & ~mask) | (mask & val);
+	return bq24261_write_reg(client, reg, ret);
+}
+
+static inline int bq24261_tmr_ntc_init(struct bq24261_charger *chip)
+{
+	u8 reg_val;
+	int ret;
+
+	bq24261_sfty_tmr_to_reg(chip->pdata->safety_timer, &reg_val);
+
+	if (chip->pdata->is_ts_enabled)
+		reg_val |= BQ24261_TS_ENABLED;
+
+	/* Check if boost mode current configuration is above 1A*/
+	if (chip->pdata->boost_mode_ma >= 1000)
+		reg_val |= BQ24261_BOOST_ILIM_1A;
+
+	ret = bq24261_read_modify_reg(chip->client, BQ24261_ST_NTC_MON_ADDR,
+			BQ24261_TS_MASK|BQ24261_SAFETY_TIMER_MASK|
+			BQ24261_BOOST_ILIM_MASK, reg_val);
+
+	return ret;
+}
+
+static inline int bq24261_enable_charging(
+	struct bq24261_charger *chip, bool val)
+{
+	int ret;
+	u8 reg_val;
+	bool is_ready;
+
+	ret = bq24261_read_reg(chip->client,
+					BQ24261_STAT_CTRL0_ADDR);
+	if (ret < 0) {
+		dev_err(&chip->client->dev,
+			"Error(%d) in reading BQ24261_STAT_CTRL0_ADDR\n", ret);
+	}
+
+	is_ready =  (ret & BQ24261_STAT_MASK) != BQ24261_STAT_FAULT;
+
+	/* If status is fault, wait for READY before enabling the charging */
+
+	if (!is_ready) {
+		ret = wait_event_timeout(chip->wait_ready,
+			(chip->chrgr_stat != BQ24261_CHRGR_STAT_READY),
+				HZ);
+		dev_info(&chip->client->dev,
+			"chrgr_stat=%x\n", chip->chrgr_stat);
+		if (ret == 0) {
+			dev_err(&chip->client->dev,
+				"Waiting for Charger Ready Failed.Enabling charging anyway\n");
+		}
+	}
+
+	if (chip->pdata->enable_charging)
+		chip->pdata->enable_charging(val);
+
+	if (val) {
+		reg_val = (~BQ24261_CE_DISABLE & BQ24261_CE_MASK);
+		if (chip->is_hw_chrg_term)
+			reg_val |= BQ24261_TE_ENABLE;
+	} else {
+		reg_val = BQ24261_CE_DISABLE;
+	}
+
+	reg_val |=  BQ24261_STAT_ENABLE;
+
+	ret = bq24261_read_modify_reg(chip->client, BQ24261_CTRL_ADDR,
+		       BQ24261_STAT_ENABLE_MASK|BQ24261_RESET_MASK|
+				BQ24261_CE_MASK|BQ24261_TE_MASK,
+					reg_val);
+	if (ret || !val)
+		return ret;
+
+	bq24261_set_iterm(chip, chip->iterm);
+	return bq24261_tmr_ntc_init(chip);
+}
+
+static inline int bq24261_reset_timer(struct bq24261_charger *chip)
+{
+	return bq24261_read_modify_reg(chip->client, BQ24261_STAT_CTRL0_ADDR,
+			BQ24261_TMR_RST_MASK, BQ24261_TMR_RST);
+}
+
+static inline int bq24261_enable_charger(
+	struct bq24261_charger *chip, int val)
+{
+
+	/* TODO: Implement enable/disable HiZ mode to enable/
+	*  disable charger
+	*/
+	u8 reg_val;
+	int ret;
+
+	reg_val = val ? (~BQ24261_HZ_ENABLE & BQ24261_HZ_MASK)  :
+			BQ24261_HZ_ENABLE;
+
+	ret = bq24261_read_modify_reg(chip->client, BQ24261_CTRL_ADDR,
+		       BQ24261_HZ_MASK|BQ24261_RESET_MASK, reg_val);
+	if (ret)
+		return ret;
+
+	return bq24261_reset_timer(chip);
+}
+
+static inline int bq24261_set_cc(struct bq24261_charger *chip, int cc)
+{
+	u8 reg_val;
+	int ret;
+
+	dev_dbg(&chip->client->dev, "cc=%d\n", cc);
+	if (chip->pdata->set_cc) {
+		ret = chip->pdata->set_cc(cc);
+		if (unlikely(ret))
+			return ret;
+	}
+
+	if (cc && (cc < BQ24261_MIN_CC)) {
+		dev_dbg(&chip->client->dev, "Set LOW_CHG bit\n");
+		reg_val = BQ24261_LOW_CHG_EN;
+		ret = bq24261_read_modify_reg(chip->client,
+				BQ24261_VINDPM_STAT_ADDR,
+				BQ24261_LOW_CHG_MASK, reg_val);
+	} else {
+		dev_dbg(&chip->client->dev, "Clear LOW_CHG bit\n");
+		reg_val = BQ24261_LOW_CHG_DIS;
+		ret = bq24261_read_modify_reg(chip->client,
+				BQ24261_VINDPM_STAT_ADDR,
+				BQ24261_LOW_CHG_MASK, reg_val);
+	}
+
+	/* Return from here since the cc setting will be done
+	   by platform specific hardware */
+	if (chip->pdata->set_cc)
+		return ret;
+
+	bq24261_cc_to_reg(cc, &reg_val);
+
+	return bq24261_read_modify_reg(chip->client, BQ24261_TERM_FCC_ADDR,
+			BQ24261_ICHRG_MASK, reg_val);
+}
+
+static inline int bq24261_set_cv(struct bq24261_charger *chip, int cv)
+{
+	int bat_volt;
+	int ret;
+	u8 reg_val;
+	u8 vindpm_val = 0x0;
+
+	/*
+	* Setting VINDPM value as per the battery voltage
+	*  VBatt           Vindpm     Register Setting
+	*  < 3.7v           4.2v       0x0 (default)
+	*  3.71v - 3.96v    4.36v      0x2
+	*  > 3.96v          4.6v       0x5
+	*/
+	ret = get_battery_voltage(&bat_volt);
+	if (ret) {
+		dev_err(&chip->client->dev,
+			"Error getting battery voltage!!\n");
+	} else {
+		if (bat_volt > BQ24261_VBATT_LEVEL2)
+			vindpm_val =
+				(BQ24261_VINDPM_320MV | BQ24261_VINDPM_80MV);
+		else if (bat_volt > BQ24261_VBATT_LEVEL1)
+			vindpm_val = BQ24261_VINDPM_160MV;
+	}
+
+	ret = bq24261_read_modify_reg(chip->client,
+			BQ24261_VINDPM_STAT_ADDR,
+			BQ24261_VINDPM_MASK,
+			vindpm_val);
+	if (ret) {
+		dev_err(&chip->client->dev,
+			"Error setting VINDPM setting!!\n");
+		return ret;
+	}
+
+	if (chip->pdata->set_cv)
+		return chip->pdata->set_cv(cv);
+
+	bq24261_cv_to_reg(cv, &reg_val);
+
+	return bq24261_read_modify_reg(chip->client, BQ24261_BATT_VOL_CTRL_ADDR,
+				       BQ24261_VBREG_MASK, reg_val);
+}
+
+static inline int bq24261_set_inlmt(struct bq24261_charger *chip, int inlmt)
+{
+	u8 reg_val;
+
+	if (chip->pdata->set_inlmt)
+		return chip->pdata->set_inlmt(inlmt);
+
+	bq24261_inlmt_to_reg(inlmt, &reg_val);
+
+	return bq24261_read_modify_reg(chip->client, BQ24261_CTRL_ADDR,
+		       BQ24261_RESET_MASK|BQ24261_INLMT_MASK, reg_val);
+
+}
+
+static inline void resume_charging(struct bq24261_charger *chip)
+{
+
+	if (chip->is_charger_enabled)
+		bq24261_enable_charger(chip, true);
+	if (chip->inlmt)
+		bq24261_set_inlmt(chip, chip->inlmt);
+	if (chip->cc)
+		bq24261_set_cc(chip, chip->cc);
+	if (chip->cv)
+		bq24261_set_cv(chip, chip->cv);
+	if (chip->is_charging_enabled)
+		bq24261_enable_charging(chip, true);
+}
+
+static inline int bq24261_set_iterm(struct bq24261_charger *chip, int iterm)
+{
+	u8 reg_val;
+
+	if (chip->pdata->set_iterm)
+		return chip->pdata->set_iterm(iterm);
+
+	bq24261_iterm_to_reg(iterm, &reg_val);
+
+	return bq24261_read_modify_reg(chip->client, BQ24261_TERM_FCC_ADDR,
+				       BQ24261_ITERM_MASK, reg_val);
+}
+
+static inline int bq24261_enable_hw_charge_term(
+	struct bq24261_charger *chip, bool val)
+{
+	u8 data;
+	int ret;
+
+	data = val ? BQ24261_TE_ENABLE : (~BQ24261_TE_ENABLE & BQ24261_TE_MASK);
+
+
+	ret = bq24261_read_modify_reg(chip->client, BQ24261_CTRL_ADDR,
+			       BQ24261_RESET_MASK|BQ24261_TE_MASK, data);
+
+	if (ret)
+		return ret;
+
+	chip->is_hw_chrg_term = val ? true : false;
+
+	return ret;
+}
+
+static inline int bq24261_enable_boost_mode(
+	struct bq24261_charger *chip, int val)
+{
+	int ret = 0;
+
+
+	if (val) {
+
+		if ((chip->revision & BQ24261_REV_MASK) == BQ24261_REV) {
+			if (chip->pdata->enable_vbus)
+				chip->pdata->enable_vbus(true);
+		}
+
+		/* TODO: Support different Host Mode Current limits */
+
+		bq24261_enable_charger(chip, true);
+		ret =
+		    bq24261_read_modify_reg(chip->client,
+					    BQ24261_STAT_CTRL0_ADDR,
+					    BQ24261_BOOST_MASK,
+					    BQ24261_ENABLE_BOOST);
+		if (unlikely(ret))
+			return ret;
+
+		ret = bq24261_tmr_ntc_init(chip);
+		if (unlikely(ret))
+			return ret;
+		chip->boost_mode = true;
+
+		if ((chip->revision & BQ24261_REV_MASK) == BQ24261_REV)
+			schedule_delayed_work(&chip->wdt_work, 0);
+
+		dev_info(&chip->client->dev, "Boost Mode enabled\n");
+	} else {
+
+		ret =
+		    bq24261_read_modify_reg(chip->client,
+					    BQ24261_STAT_CTRL0_ADDR,
+					    BQ24261_BOOST_MASK,
+					    ~BQ24261_ENABLE_BOOST);
+
+		if (unlikely(ret))
+			return ret;
+		/* if charging need not to be enabled, disable
+		* the charger else keep the charger on
+		*/
+		if (!chip->is_charging_enabled)
+			bq24261_enable_charger(chip, false);
+		chip->boost_mode = false;
+		dev_info(&chip->client->dev, "Boost Mode disabled\n");
+
+		if ((chip->revision & BQ24261_REV_MASK) == BQ24261_REV) {
+			cancel_delayed_work_sync(&chip->wdt_work);
+
+			if (chip->pdata->enable_vbus)
+				chip->pdata->enable_vbus(false);
+		}
+
+		/* Notify power supply subsystem to enable charging
+		 * if needed. Eg. if DC adapter is connected
+		 */
+		power_supply_changed(&chip->psy_usb);
+	}
+
+	return ret;
+}
+
+static inline bool bq24261_is_vsys_on(struct bq24261_charger *chip)
+{
+	int ret;
+	struct i2c_client *client = chip->client;
+
+	ret = bq24261_read_reg(client, BQ24261_CTRL_ADDR);
+	if (ret < 0) {
+		dev_err(&client->dev,
+			"Error(%d) in reading BQ24261_CTRL_ADDR\n", ret);
+		return false;
+	}
+
+	if (((ret & BQ24261_HZ_MASK) == BQ24261_HZ_ENABLE) &&
+			chip->is_charger_enabled) {
+		dev_err(&client->dev, "Charger in Hi Z Mode\n");
+		bq24261_dump_regs(true);
+		return false;
+	}
+
+	ret = bq24261_read_reg(client, BQ24261_VINDPM_STAT_ADDR);
+	if (ret < 0) {
+		dev_err(&client->dev,
+			"Error(%d) in reading BQ24261_VINDPM_STAT_ADDR\n", ret);
+		return false;
+	}
+
+	if (ret & BQ24261_CD_STATUS_MASK) {
+		dev_err(&client->dev, "CD line asserted\n");
+		bq24261_dump_regs(true);
+		return false;
+	}
+
+	return true;
+}
+
+
+static inline bool bq24261_is_online(struct bq24261_charger *chip)
+{
+	if (chip->cable_type == POWER_SUPPLY_CHARGER_TYPE_NONE)
+		return false;
+	else if (!chip->is_charger_enabled)
+		return false;
+	/* BQ24261 gives interrupt only on stop/resume charging.
+	 * If charging is already stopped, we need to query the hardware
+	 * to see charger is still active and can supply vsys or not.
+	 */
+	else if ((chip->chrgr_stat == BQ24261_CHRGR_STAT_FAULT) ||
+		 (!chip->is_charging_enabled))
+		return bq24261_is_vsys_on(chip);
+	else
+		return chip->is_vsys_on;
+}
+
+static int bq24261_usb_set_property(struct power_supply *psy,
+				    enum power_supply_property psp,
+				    const union power_supply_propval *val)
+{
+	struct bq24261_charger *chip = container_of(psy,
+						    struct bq24261_charger,
+						    psy_usb);
+	int ret = 0;
+
+
+	mutex_lock(&chip->lock);
+
+
+	switch (psp) {
+
+	case POWER_SUPPLY_PROP_PRESENT:
+		chip->present = val->intval;
+		/*If charging capable cable is present, then
+		hold the charger wakelock so that the target
+		does not enter suspend mode when charging is
+		in progress.
+		If charging cable has been removed, then
+		unlock the wakelock to allow the target to
+		enter the sleep mode*/
+/*		if (!wake_lock_active(&chip->chrgr_en_wakelock) &&
+					val->intval)
+			wake_lock(&chip->chrgr_en_wakelock);
+		else if (wake_lock_active(&chip->chrgr_en_wakelock) &&
+					!val->intval)
+			wake_unlock(&chip->chrgr_en_wakelock);
+*/
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		chip->online = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGING:
+
+		ret = bq24261_enable_charging(chip, val->intval);
+
+		if (ret)
+			dev_err(&chip->client->dev,
+				"Error(%d) in %s charging", ret,
+				(val->intval ? "enable" : "disable"));
+		else
+			chip->is_charging_enabled = val->intval;
+
+		if (val->intval)
+			bq24261_enable_hw_charge_term(chip, true);
+		else
+			cancel_delayed_work_sync(&chip->sw_term_work);
+
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGER:
+
+		/* Don't enable the charger unless overvoltage is recovered */
+
+		if (chip->bat_health != POWER_SUPPLY_HEALTH_OVERVOLTAGE) {
+			ret = bq24261_enable_charger(chip, val->intval);
+
+			if (ret)
+				dev_err(&chip->client->dev,
+					"Error(%d) in %s charger", ret,
+					(val->intval ? "enable" : "disable"));
+			else
+				chip->is_charger_enabled = val->intval;
+		} else {
+			dev_info(&chip->client->dev, "Battery Over Voltage. Charger will be disabled\n");
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CURRENT:
+		ret = bq24261_set_cc(chip, val->intval);
+		if (!ret)
+			chip->cc = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_VOLTAGE:
+		ret = bq24261_set_cv(chip, val->intval);
+		if (!ret)
+			chip->cv = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT:
+		chip->max_cc = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE:
+		chip->max_cv = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TERM_CUR:
+		ret = bq24261_set_iterm(chip, val->intval);
+		if (!ret)
+			chip->iterm = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CABLE_TYPE:
+
+		chip->cable_type = val->intval;
+		chip->psy_usb.type = get_power_supply_type(chip->cable_type);
+		if (chip->cable_type != POWER_SUPPLY_CHARGER_TYPE_NONE) {
+			chip->chrgr_health = POWER_SUPPLY_HEALTH_GOOD;
+			chip->chrgr_stat = BQ24261_CHRGR_STAT_UNKNOWN;
+
+			/* Adding this processing in order to check
+			for any faults during connect */
+
+			ret = bq24261_read_reg(chip->client,
+						BQ24261_STAT_CTRL0_ADDR);
+			if (ret < 0)
+				dev_err(&chip->client->dev,
+				"Error (%d) in reading status register(0x00)\n",
+				ret);
+			else
+				bq24261_handle_irq(chip, ret);
+		} else {
+			chip->chrgr_stat = BQ24261_CHRGR_STAT_UNKNOWN;
+			chip->chrgr_health = POWER_SUPPLY_HEALTH_UNKNOWN;
+			cancel_delayed_work_sync(&chip->low_supply_fault_work);
+		}
+
+
+		break;
+	case POWER_SUPPLY_PROP_INLMT:
+		ret = bq24261_set_inlmt(chip, val->intval);
+		if (!ret)
+			chip->inlmt = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		chip->cntl_state = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MAX_TEMP:
+		chip->max_temp = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MIN_TEMP:
+		chip->min_temp = val->intval;
+		break;
+	default:
+		ret = -ENODATA;
+	}
+
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+
+static int bq24261_usb_get_property(struct power_supply *psy,
+				    enum power_supply_property psp,
+				    union power_supply_propval *val)
+{
+	struct bq24261_charger *chip = container_of(psy,
+						    struct bq24261_charger,
+						    psy_usb);
+
+	mutex_lock(&chip->lock);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = chip->present;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = chip->online;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = chip->chrgr_health;
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT:
+		val->intval = chip->max_cc;
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE:
+		val->intval = chip->max_cv;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CURRENT:
+		val->intval = chip->cc;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_VOLTAGE:
+		val->intval = chip->cv;
+		break;
+	case POWER_SUPPLY_PROP_INLMT:
+		val->intval = chip->inlmt;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TERM_CUR:
+		val->intval = chip->iterm;
+		break;
+	case POWER_SUPPLY_PROP_CABLE_TYPE:
+		val->intval = chip->cable_type;
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGING:
+		if (chip->boost_mode)
+			val->intval = false;
+		else
+			val->intval = (chip->is_charging_enabled &&
+			(chip->chrgr_stat == BQ24261_CHRGR_STAT_CHARGING));
+
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGER:
+		val->intval = bq24261_is_online(chip);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		val->intval = chip->cntl_state;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
+		val->intval = chip->pdata->num_throttle_states;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = chip->model_name;
+		break;
+	case POWER_SUPPLY_PROP_MANUFACTURER:
+		val->strval = chip->manufacturer;
+		break;
+	case POWER_SUPPLY_PROP_MAX_TEMP:
+		val->intval = chip->max_temp;
+		break;
+	case POWER_SUPPLY_PROP_MIN_TEMP:
+		val->intval = chip->min_temp;
+		break;
+	default:
+		mutex_unlock(&chip->lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&chip->lock);
+	return 0;
+}
+
+static inline struct power_supply *get_psy_battery(void)
+{
+	struct class_dev_iter iter;
+	struct device *dev;
+	static struct power_supply *pst;
+
+	class_dev_iter_init(&iter, power_supply_class, NULL, NULL);
+	while ((dev = class_dev_iter_next(&iter))) {
+		pst = (struct power_supply *)dev_get_drvdata(dev);
+		if (pst->type == POWER_SUPPLY_TYPE_BATTERY) {
+			class_dev_iter_exit(&iter);
+			return pst;
+		}
+	}
+	class_dev_iter_exit(&iter);
+
+	return NULL;
+}
+
+static inline int get_battery_voltage(int *volt)
+{
+	struct power_supply *psy;
+	union power_supply_propval val;
+	int ret;
+
+	psy = get_psy_battery();
+	if (!psy)
+		return -EINVAL;
+
+	ret = psy->get_property(psy, POWER_SUPPLY_PROP_VOLTAGE_NOW, &val);
+	if (!ret)
+		*volt = (val.intval);
+
+	return ret;
+}
+
+static inline int get_battery_volt_max_design(int *volt)
+{
+	struct power_supply *psy;
+	union power_supply_propval val;
+	int ret;
+
+	psy = get_psy_battery();
+	if (!psy)
+		return -EINVAL;
+
+	ret = psy->get_property(psy,
+		POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN, &val);
+	if (!ret)
+		(*volt = val.intval);
+	return ret;
+}
+
+static inline int get_battery_current(int *cur)
+{
+	struct power_supply *psy;
+	union power_supply_propval val;
+	int ret;
+
+	psy = get_psy_battery();
+	if (!psy)
+		return -EINVAL;
+
+	ret = psy->get_property(psy, POWER_SUPPLY_PROP_CURRENT_NOW, &val);
+	if (!ret)
+		*cur = val.intval;
+
+	return ret;
+}
+
+static void bq24261_wdt_reset_worker(struct work_struct *work)
+{
+
+	struct bq24261_charger *chip = container_of(work,
+			    struct bq24261_charger, wdt_work.work);
+	int ret;
+	ret = bq24261_reset_timer(chip);
+
+	if (ret)
+		dev_err(&chip->client->dev, "Error (%d) in WDT reset\n");
+	else
+		dev_info(&chip->client->dev, "WDT reset\n");
+
+	schedule_delayed_work(&chip->wdt_work, WDT_RESET_DELAY);
+}
+
+static void bq24261_sw_charge_term_worker(struct work_struct *work)
+{
+
+	struct bq24261_charger *chip = container_of(work,
+						    struct bq24261_charger,
+						    sw_term_work.work);
+
+	power_supply_changed(NULL);
+
+	schedule_delayed_work(&chip->sw_term_work,
+			      CHRG_TERM_WORKER_DELAY);
+
+}
+
+int bq24261_get_bat_health(void)
+{
+
+	struct bq24261_charger *chip;
+
+	if (!bq24261_client)
+		return -ENODEV;
+
+	chip = i2c_get_clientdata(bq24261_client);
+
+	return chip->bat_health;
+}
+
+
+static void bq24261_low_supply_fault_work(struct work_struct *work)
+{
+	struct bq24261_charger *chip = container_of(work,
+						    struct bq24261_charger,
+						    low_supply_fault_work.work);
+
+	if (chip->chrgr_stat == BQ24261_CHRGR_STAT_FAULT) {
+		dev_err(&chip->client->dev, "Low Supply Fault detected!!\n");
+		chip->chrgr_health = POWER_SUPPLY_HEALTH_DEAD;
+		power_supply_changed(&chip->psy_usb);
+		bq24261_dump_regs(true);
+	}
+	return;
+}
+
+
+/* is_bat_over_voltage: check battery is over voltage or not
+*  @chip: bq24261_charger context
+*
+*  This function is used to verify the over voltage condition.
+*  In some scenarios, HW generates Over Voltage exceptions when
+*  battery voltage is normal. This function uses the over voltage
+*  condition (voltage_max_design * 1.01) to verify battery is really
+*  over charged or not.
+*/
+
+static bool is_bat_over_voltage(struct bq24261_charger *chip,
+		bool verify_recovery)
+{
+
+	int bat_volt, bat_volt_max_des, ret;
+
+	ret = get_battery_voltage(&bat_volt);
+	if (ret)
+		return verify_recovery ? false : true;
+
+	ret = get_battery_volt_max_design(&bat_volt_max_des);
+
+	if (ret)
+		bat_volt_max_des = BQ24261_DEF_BAT_VOLT_MAX_DESIGN;
+
+	dev_info(&chip->client->dev, "bat_volt=%d Voltage Max Design=%d OVP_VOLT=%d OVP recover volt=%d\n",
+			bat_volt, bat_volt_max_des,
+			(bat_volt_max_des/1000 * BQ24261_OVP_MULTIPLIER),
+			(bat_volt_max_des/1000 *
+				BQ24261_OVP_RECOVER_MULTIPLIER));
+	if (verify_recovery) {
+		if ((bat_volt) <= (bat_volt_max_des / 1000 *
+				BQ24261_OVP_RECOVER_MULTIPLIER))
+			return true;
+		else
+			return false;
+	} else {
+		if ((bat_volt) >= (bat_volt_max_des / 1000 *
+					BQ24261_OVP_MULTIPLIER))
+			return true;
+		else
+			return false;
+	}
+
+	return false;
+}
+
+#define IS_BATTERY_OVER_VOLTAGE(chip) \
+	is_bat_over_voltage(chip , false)
+
+#define IS_BATTERY_OVER_VOLTAGE_RECOVERED(chip) \
+	is_bat_over_voltage(chip , true)
+
+static void handle_battery_over_voltage(struct bq24261_charger *chip)
+{
+	/* Set Health to Over Voltage. Disable charger to discharge
+	*  battery to reduce the battery voltage.
+	*/
+	chip->bat_health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	bq24261_enable_charger(chip, false);
+	chip->is_charger_enabled = false;
+	cancel_delayed_work_sync(&chip->exception_mon_work);
+	schedule_delayed_work(&chip->exception_mon_work,
+			EXCEPTION_MONITOR_DELAY);
+}
+
+static void bq24261_exception_mon_work(struct work_struct *work)
+{
+	struct bq24261_charger *chip = container_of(work,
+						    struct bq24261_charger,
+						    exception_mon_work.work);
+	/* Only overvoltage exception need to monitor.*/
+	if (IS_BATTERY_OVER_VOLTAGE_RECOVERED(chip)) {
+		dev_info(&chip->client->dev, "Over Voltage Exception Recovered\n");
+		chip->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		bq24261_enable_charger(chip, true);
+		chip->is_charger_enabled = true;
+		resume_charging(chip);
+	} else {
+		schedule_delayed_work(&chip->exception_mon_work,
+			      EXCEPTION_MONITOR_DELAY);
+	}
+}
+
+static int bq24261_handle_irq(struct bq24261_charger *chip, u8 stat_reg)
+{
+	struct i2c_client *client = chip->client;
+	bool notify = true;
+
+	dev_info(&client->dev, "%s:%d stat=0x%x\n",
+			__func__, __LINE__, stat_reg);
+
+	switch (stat_reg & BQ24261_STAT_MASK) {
+	case BQ24261_STAT_READY:
+		chip->chrgr_stat = BQ24261_CHRGR_STAT_READY;
+		chip->chrgr_health = POWER_SUPPLY_HEALTH_GOOD;
+		chip->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		dev_info(&client->dev, "Charger Status: Ready\n");
+		notify = false;
+		break;
+	case BQ24261_STAT_CHRG_PRGRSS:
+		chip->chrgr_stat = BQ24261_CHRGR_STAT_CHARGING;
+		chip->chrgr_health = POWER_SUPPLY_HEALTH_GOOD;
+		chip->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		dev_info(&client->dev, "Charger Status: Charge Progress\n");
+		bq24261_dump_regs(false);
+		break;
+	case BQ24261_STAT_CHRG_DONE:
+		chip->chrgr_health = POWER_SUPPLY_HEALTH_GOOD;
+		chip->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		dev_info(&client->dev, "Charger Status: Charge Done\n");
+
+		bq24261_enable_hw_charge_term(chip, false);
+		resume_charging(chip);
+		schedule_delayed_work(&chip->sw_term_work, 0);
+		break;
+
+	case BQ24261_STAT_FAULT:
+		break;
+	}
+
+	if (stat_reg & BQ24261_BOOST_MASK)
+		dev_info(&client->dev, "Boost Mode\n");
+
+	if ((stat_reg & BQ24261_STAT_MASK) == BQ24261_STAT_FAULT) {
+		bool dump_master = true;
+		chip->chrgr_stat = BQ24261_CHRGR_STAT_FAULT;
+
+		switch (stat_reg & BQ24261_FAULT_MASK) {
+		case BQ24261_VOVP:
+			chip->chrgr_health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+			dev_err(&client->dev, "Charger OVP Fault\n");
+			break;
+
+		case BQ24261_LOW_SUPPLY:
+			notify = false;
+
+			if (chip->pdata->handle_low_supply)
+				chip->pdata->handle_low_supply();
+
+			if (chip->cable_type !=
+					POWER_SUPPLY_CHARGER_TYPE_NONE) {
+				schedule_delayed_work
+					(&chip->low_supply_fault_work,
+					5*HZ);
+				dev_dbg(&client->dev,
+					"Schedule Low Supply Fault work!!\n");
+			}
+			break;
+
+		case BQ24261_THERMAL_SHUTDOWN:
+			chip->chrgr_health = POWER_SUPPLY_HEALTH_OVERHEAT;
+			dev_err(&client->dev, "Charger Thermal Fault\n");
+			break;
+
+		case BQ24261_BATT_TEMP_FAULT:
+			chip->bat_health = POWER_SUPPLY_HEALTH_OVERHEAT;
+			dev_err(&client->dev, "Battery Temperature Fault\n");
+			break;
+
+		case BQ24261_TIMER_FAULT:
+			chip->bat_health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+			chip->chrgr_health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+			dev_err(&client->dev, "Charger Timer Fault\n");
+			break;
+
+		case BQ24261_BATT_OVP:
+			notify = false;
+			if (chip->bat_health !=
+					POWER_SUPPLY_HEALTH_OVERVOLTAGE) {
+				if (!IS_BATTERY_OVER_VOLTAGE(chip)) {
+					chip->chrgr_stat =
+						BQ24261_CHRGR_STAT_UNKNOWN;
+					resume_charging(chip);
+				} else {
+					dev_err(&client->dev, "Battery Over Voltage Fault\n");
+					handle_battery_over_voltage(chip);
+					notify = true;
+				}
+			}
+			break;
+		case BQ24261_NO_BATTERY:
+			dev_err(&client->dev, "No Battery Connected\n");
+			break;
+
+		}
+
+		if (chip->chrgr_stat == BQ24261_CHRGR_STAT_FAULT && notify)
+			bq24261_dump_regs(dump_master);
+	}
+
+	wake_up(&chip->wait_ready);
+
+	chip->is_vsys_on = bq24261_is_vsys_on(chip);
+	if (notify)
+		power_supply_changed(&chip->psy_usb);
+
+	return 0;
+}
+
+static void bq24261_irq_worker(struct work_struct *work)
+{
+	struct bq24261_charger *chip =
+	    container_of(work, struct bq24261_charger, irq_work);
+	int ret;
+
+	/*Lock to ensure that interrupt register readings are done
+	* and processed sequentially. The interrupt Fault registers
+	* are read on clear and without sequential processing double
+	* fault interrupts or fault recovery cannot be handlled propely
+	*/
+
+	mutex_lock(&chip->lock);
+
+	dev_dbg(&chip->client->dev, "%s\n", __func__);
+
+	ret = bq24261_read_reg(chip->client, BQ24261_STAT_CTRL0_ADDR);
+	if (ret < 0) {
+		printk(KERN_ERR "LOIC bq24261_irq_worker RET < 0\n");
+		dev_err(&chip->client->dev,
+			"Error (%d) in reading BQ24261_STAT_CTRL0_ADDR\n", ret);
+	}
+	else {
+		printk(KERN_ERR "LOIC bq24261_irq_worker handle_irq(chip,ret))\n");
+		bq24261_handle_irq(chip, ret);
+	}
+	mutex_unlock(&chip->lock);
+}
+
+static irqreturn_t bq24261_thread_handler(int id, void *data)
+{
+	struct bq24261_charger *chip = (struct bq24261_charger *)data;
+
+	queue_work(system_nrt_wq, &chip->irq_work);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t bq24261_irq_handler(int irq, void *data)
+{
+	struct bq24261_charger *chip = (struct bq24261_charger *)data;
+	u8 intr_stat;
+
+	if (chip->irq_iomap) {
+		intr_stat = ioread8(chip->irq_iomap);
+		if ((intr_stat & chip->pdata->irq_mask)) {
+			dev_dbg(&chip->client->dev, "%s\n", __func__);
+			return IRQ_WAKE_THREAD;
+		}
+	}
+
+	return IRQ_NONE;
+}
+
+static void bq24261_boostmode_worker(struct work_struct *work)
+{
+	struct bq24261_charger *chip =
+	    container_of(work, struct bq24261_charger, otg_work);
+	struct bq24261_otg_event *evt, *tmp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->otg_queue_lock, flags);
+	list_for_each_entry_safe(evt, tmp, &chip->otg_queue, node) {
+		list_del(&evt->node);
+		spin_unlock_irqrestore(&chip->otg_queue_lock, flags);
+
+		dev_info(&chip->client->dev,
+			"%s:%d state=%d\n", __FILE__, __LINE__,
+				evt->is_enable);
+		mutex_lock(&chip->lock);
+		if (evt->is_enable)
+			bq24261_enable_boost_mode(chip, 1);
+		else
+			bq24261_enable_boost_mode(chip, 0);
+
+		mutex_unlock(&chip->lock);
+		spin_lock_irqsave(&chip->otg_queue_lock, flags);
+		kfree(evt);
+
+	}
+	spin_unlock_irqrestore(&chip->otg_queue_lock, flags);
+}
+
+static int otg_handle_notification(struct notifier_block *nb,
+				   unsigned long event, void *param)
+{
+
+	struct bq24261_charger *chip =
+	    container_of(nb, struct bq24261_charger, otg_nb);
+	struct bq24261_otg_event *evt;
+
+	dev_dbg(&chip->client->dev, "OTG notification: %lu\n", event);
+	if (!param || event != USB_EVENT_DRIVE_VBUS)
+		return NOTIFY_DONE;
+
+	evt = kzalloc(sizeof(*evt), GFP_ATOMIC);
+	if (!evt) {
+		dev_err(&chip->client->dev,
+			"failed to allocate memory for OTG event\n");
+		return NOTIFY_DONE;
+	}
+
+	evt->is_enable = *(int *)param;
+	INIT_LIST_HEAD(&evt->node);
+
+	spin_lock(&chip->otg_queue_lock);
+	list_add_tail(&evt->node, &chip->otg_queue);
+	spin_unlock(&chip->otg_queue_lock);
+
+	queue_work(system_nrt_wq, &chip->otg_work);
+	return NOTIFY_OK;
+}
+
+static inline int register_otg_notifications(struct bq24261_charger *chip)
+{
+
+	int retval;
+
+	INIT_LIST_HEAD(&chip->otg_queue);
+	INIT_WORK(&chip->otg_work, bq24261_boostmode_worker);
+	spin_lock_init(&chip->otg_queue_lock);
+
+	chip->otg_nb.notifier_call = otg_handle_notification;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0))
+	chip->transceiver = usb_get_transceiver();
+#else
+	chip->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);
+#endif
+	if (!chip->transceiver || IS_ERR(chip->transceiver)) {
+		dev_err(&chip->client->dev, "failed to get otg transceiver\n");
+		return -EINVAL;
+	}
+	retval = usb_register_notifier(chip->transceiver, &chip->otg_nb);
+	if (retval) {
+		dev_err(&chip->client->dev,
+			"failed to register otg notifier\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static enum bq2426x_model_num bq24261_get_model(int bq24261_rev_reg)
+{
+	switch (bq24261_rev_reg & BQ24261_REV_MASK) {
+	case BQ24260_REV:
+		return BQ24260;
+	case BQ24261_REV:
+	case BQ24261_2_3_REV:
+		return BQ24261;
+	default:
+		return BQ2426X;
+	}
+}
+
+static int bq24261_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter;
+	struct bq24261_charger *chip;
+	int ret;
+	int bq2426x_rev;
+	enum bq2426x_model_num bq24261_rev_index;
+
+	printk(KERN_ERR "welcome in the bq24261_probe\n");
+
+	adapter = to_i2c_adapter(client->dev.parent);
+
+	if (!client->dev.platform_data) {
+		dev_err(&client->dev, "platform data is null");
+		return -EFAULT;
+	}
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev,
+			"I2C adapter %s doesn'tsupport BYTE DATA transfer\n",
+			adapter->name);
+		return -EIO;
+	}
+
+	bq2426x_rev = bq24261_read_reg(client, BQ24261_VENDOR_REV_ADDR);
+	if (bq2426x_rev < 0) {
+		dev_err(&client->dev,
+			"Error (%d) in reading BQ24261_VENDOR_REV_ADDR\n", bq2426x_rev);
+		return bq2426x_rev;
+	}
+	dev_info(&client->dev, "bq2426x revision: 0x%x found!!\n", bq2426x_rev);
+
+	bq24261_rev_index = bq24261_get_model(bq2426x_rev);
+	if ((bq2426x_rev & BQ24261_VENDOR_MASK) != BQ24261_VENDOR) {
+		dev_err(&client->dev,
+			"Invalid Vendor/Revision number in BQ24261_VENDOR_REV_ADDR: %d",
+			bq2426x_rev);
+		return -ENODEV;
+	}
+
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip) {
+		dev_err(&client->dev, "mem alloc failed\n");
+		return -ENOMEM;
+	}
+
+	init_waitqueue_head(&chip->wait_ready);
+	i2c_set_clientdata(client, chip);
+	chip->pdata = client->dev.platform_data;
+
+	/* Remap IRQ map address to read the IRQ status */
+	if ((chip->pdata->irq_map) && (chip->pdata->irq_mask)) {
+		chip->irq_iomap = ioremap_nocache(chip->pdata->irq_map, 8);
+		if (!chip->irq_iomap) {
+			dev_err(&client->dev, "Failed: ioremap_nocache\n");
+			return -EFAULT;
+		}
+	}
+
+	chip->client = client;
+	chip->pdata = client->dev.platform_data;
+
+	chip->psy_usb.name = DEV_NAME;
+	chip->psy_usb.type = POWER_SUPPLY_TYPE_USB;
+	chip->psy_usb.properties = bq24261_usb_props;
+	chip->psy_usb.num_properties = ARRAY_SIZE(bq24261_usb_props);
+	chip->psy_usb.get_property = bq24261_usb_get_property;
+	chip->psy_usb.set_property = bq24261_usb_set_property;
+	chip->psy_usb.supplied_to = chip->pdata->supplied_to;
+	chip->psy_usb.num_supplicants = chip->pdata->num_supplicants;
+	chip->psy_usb.throttle_states = chip->pdata->throttle_states;
+	chip->psy_usb.num_throttle_states = chip->pdata->num_throttle_states;
+	chip->psy_usb.supported_cables = POWER_SUPPLY_CHARGER_TYPE_USB;
+	chip->max_cc = 1500;
+	chip->chrgr_stat = BQ24261_CHRGR_STAT_UNKNOWN;
+	chip->chrgr_health = POWER_SUPPLY_HEALTH_UNKNOWN;
+	chip->revision = bq2426x_rev;
+
+	strncpy(chip->model_name,
+		bq24261_model_name[bq24261_rev_index].model_name,
+		MODEL_NAME_SIZE);
+	strncpy(chip->manufacturer, DEV_MANUFACTURER,
+		DEV_MANUFACTURER_NAME_SIZE);
+
+	mutex_init(&chip->lock);
+	ret = power_supply_register(&client->dev, &chip->psy_usb);
+	if (ret) {
+		dev_err(&client->dev, "Failed: power supply register (%d)\n",
+			ret);
+		iounmap(chip->irq_iomap);
+		return ret;
+	}
+
+	INIT_DELAYED_WORK(&chip->sw_term_work, bq24261_sw_charge_term_worker);
+	INIT_DELAYED_WORK(&chip->low_supply_fault_work,
+				bq24261_low_supply_fault_work);
+	INIT_DELAYED_WORK(&chip->exception_mon_work,
+				bq24261_exception_mon_work);
+	if ((chip->revision & BQ24261_REV_MASK) == BQ24261_REV) {
+		INIT_DELAYED_WORK(&chip->wdt_work,
+					bq24261_wdt_reset_worker);
+	}
+
+	INIT_WORK(&chip->irq_work, bq24261_irq_worker);
+	if (chip->client->irq) {
+		ret = request_threaded_irq(chip->client->irq,
+					   bq24261_irq_handler,
+					   bq24261_thread_handler,
+					   IRQF_SHARED|IRQF_NO_SUSPEND,
+					   DEV_NAME, chip);
+		if (ret) {
+			dev_err(&client->dev, "Failed: request_irq (%d)\n",
+				ret);
+			iounmap(chip->irq_iomap);
+			power_supply_unregister(&chip->psy_usb);
+			return ret;
+		}
+	}
+
+	if (IS_BATTERY_OVER_VOLTAGE(chip))
+		handle_battery_over_voltage(chip);
+	else
+		chip->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+
+	if (register_otg_notifications(chip))
+		dev_err(&client->dev, "Error in registering OTG notifications. Unable to supply power to Host\n");
+
+	bq24261_client = client;
+	power_supply_changed(&chip->psy_usb);
+	bq24261_debugfs_init();
+
+	printk(KERN_ERR "Welcome in the bq24261_probe SUCCESS OUT\n ");
+
+	return 0;
+}
+
+static int bq24261_remove(struct i2c_client *client)
+{
+	struct bq24261_charger *chip = i2c_get_clientdata(client);
+
+	if (client->irq)
+		free_irq(client->irq, chip);
+
+	flush_scheduled_work();
+	if (chip->irq_iomap)
+		iounmap(chip->irq_iomap);
+	if (chip->transceiver)
+		usb_unregister_notifier(chip->transceiver, &chip->otg_nb);
+
+	power_supply_unregister(&chip->psy_usb);
+	bq24261_debugfs_exit();
+	return 0;
+}
+
+static int bq24261_suspend(struct device *dev)
+{
+	struct bq24261_charger *chip = dev_get_drvdata(dev);
+
+	if ((chip->revision & BQ24261_REV_MASK) == BQ24261_REV) {
+		if (chip->boost_mode)
+			cancel_delayed_work_sync(&chip->wdt_work);
+	}
+	dev_dbg(&chip->client->dev, "bq24261 suspend\n");
+	return 0;
+}
+
+static int bq24261_resume(struct device *dev)
+{
+	struct bq24261_charger *chip = dev_get_drvdata(dev);
+
+	if ((chip->revision & BQ24261_REV_MASK) == BQ24261_REV) {
+		if (chip->boost_mode)
+			bq24261_enable_boost_mode(chip, 1);
+	}
+
+	dev_dbg(&chip->client->dev, "bq24261 resume\n");
+	return 0;
+}
+
+static int bq24261_runtime_suspend(struct device *dev)
+{
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int bq24261_runtime_resume(struct device *dev)
+{
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int bq24261_runtime_idle(struct device *dev)
+{
+
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops bq24261_pm_ops = {
+	.suspend = bq24261_suspend,
+	.resume = bq24261_resume,
+	.runtime_suspend = bq24261_runtime_suspend,
+	.runtime_resume = bq24261_runtime_resume,
+	.runtime_idle = bq24261_runtime_idle,
+};
+
+static const struct i2c_device_id bq24261_id[] = {
+	{DEV_NAME, 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, bq24261_id);
+
+static struct i2c_driver bq24261_driver = {
+	.driver = {
+		   .name = DEV_NAME,
+		   .pm = &bq24261_pm_ops,
+		   },
+	.probe = bq24261_probe,
+	.remove = bq24261_remove,
+	.id_table = bq24261_id,
+};
+
+static int __init bq24261_init(void)
+{
+	return i2c_add_driver(&bq24261_driver);
+}
+
+module_init(bq24261_init);
+
+static void __exit bq24261_exit(void)
+{
+	i2c_del_driver(&bq24261_driver);
+}
+
+module_exit(bq24261_exit);
+
+MODULE_AUTHOR("Jenny TC <jenny.tc@intel.com>");
+MODULE_DESCRIPTION("BQ24261 Charger Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/pmic_ccsm.c b/drivers/power/pmic_ccsm.c
new file mode 100644
index 000000000000..e5adebe7d20e
--- /dev/null
+++ b/drivers/power/pmic_ccsm.c
@@ -0,0 +1,1914 @@
+/*
+ * pmic_ccsm.c - Intel MID PMIC Charger Driver
+ *
+ * Copyright (C) 2011 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Jenny TC <jenny.tc@intel.com>
+ * Author: Yegnesh Iyer <yegnesh.s.iyer@intel.com>
+ */
+
+/* Includes */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/jiffies.h>
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#include <linux/kfifo.h>
+#include <linux/param.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/usb/otg.h>
+#include <linux/power_supply.h>
+#include <linux/power_supply.h>
+#include <linux/rpmsg.h>
+#include <linux/version.h>
+#include <asm/intel_basincove_gpadc.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+#include <linux/iio/consumer.h>
+#else
+#include "../../../kernel/drivers/staging/iio/consumer.h"
+#endif
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_mid_remoteproc.h>
+#include <linux/io.h>
+#include <linux/sched.h>
+#include <linux/pm_runtime.h>
+#include <linux/sfi.h>
+#include <linux/async.h>
+#include <linux/reboot.h>
+#include <linux/notifier.h>
+#include <linux/power/battery_id.h>
+#include "pmic_ccsm.h"
+
+/* Macros */
+#define DRIVER_NAME "pmic_ccsm"
+#define PMIC_SRAM_INTR_ADDR 0xFFFFF616
+#define ADC_TO_TEMP 1
+#define TEMP_TO_ADC 0
+#define is_valid_temp(tmp)\
+	(!(tmp > chc.pdata->adc_tbl[0].temp ||\
+	tmp < chc.pdata->adc_tbl[chc.pdata->max_tbl_row_cnt - 1].temp))
+#define is_valid_adc_code(val)\
+	(!(val < chc.pdata->adc_tbl[0].adc_val ||\
+	val > chc.pdata->adc_tbl[chc.pdata->max_tbl_row_cnt - 1].adc_val))
+#define CONVERT_ADC_TO_TEMP(adc_val, temp)\
+	adc_temp_conv(adc_val, temp, ADC_TO_TEMP)
+#define CONVERT_TEMP_TO_ADC(temp, adc_val)\
+	adc_temp_conv(temp, adc_val, TEMP_TO_ADC)
+#define NEED_ZONE_SPLIT(bprof)\
+	 ((bprof->temp_mon_ranges < MIN_BATT_PROF))
+
+#define USB_WAKE_LOCK_TIMEOUT	(5 * HZ)
+
+/* 100mA value definition for setting the inlimit in bq24261 */
+#define USBINPUTICC100VAL	100
+
+/* Type definitions */
+static void pmic_bat_zone_changed(void);
+static void pmic_battery_overheat_handler(bool);
+
+/* Extern definitions */
+
+/* Global declarations */
+static DEFINE_MUTEX(pmic_lock);
+static struct pmic_chrgr_drv_context chc;
+static struct interrupt_info chgrirq0_info[] = {
+	{
+		CHGIRQ0_BZIRQ_MASK,
+		0,
+		"Battery temperature zone changed",
+		NULL,
+		NULL,
+		pmic_bat_zone_changed,
+		NULL,
+	},
+	{
+		CHGIRQ0_BAT_CRIT_MASK,
+		SCHGIRQ0_SBAT_CRIT_MASK,
+		NULL,
+		"Battery Over heat exception",
+		"Battery Over heat exception Recovered",
+		NULL,
+		pmic_battery_overheat_handler
+	},
+	{
+		CHGIRQ0_BAT0_ALRT_MASK,
+		SCHGIRQ0_SBAT0_ALRT_MASK,
+		NULL,
+		"Battery0 temperature inside boundary",
+		"Battery0 temperature outside boundary",
+		NULL,
+		pmic_battery_overheat_handler
+	},
+	{
+		CHGIRQ0_BAT1_ALRT_MASK,
+		SCHGIRQ0_SBAT1_ALRT_MASK,
+		NULL,
+		"Battery1 temperature inside boundary",
+		"Battery1 temperature outside boundary",
+		NULL,
+		NULL
+	},
+};
+
+u16 pmic_inlmt[][2] = {
+	{ 100, CHGRCTRL1_FUSB_INLMT_100},
+	{ 150, CHGRCTRL1_FUSB_INLMT_150},
+	{ 500, CHGRCTRL1_FUSB_INLMT_500},
+	{ 900, CHGRCTRL1_FUSB_INLMT_900},
+	{ 1500, CHGRCTRL1_FUSB_INLMT_1500},
+};
+
+static inline struct power_supply *get_psy_battery(void)
+{
+	struct class_dev_iter iter;
+	struct device *dev;
+	struct power_supply *pst;
+
+	class_dev_iter_init(&iter, power_supply_class, NULL, NULL);
+	while ((dev = class_dev_iter_next(&iter))) {
+		pst = (struct power_supply *)dev_get_drvdata(dev);
+		if (pst->type == POWER_SUPPLY_TYPE_BATTERY) {
+			class_dev_iter_exit(&iter);
+			return pst;
+		}
+	}
+	class_dev_iter_exit(&iter);
+
+	return NULL;
+}
+
+
+/* Function definitions */
+static void lookup_regval(u16 tbl[][2], size_t size, u16 in_val, u8 *out_val)
+{
+	int i;
+	for (i = 1; i < size; ++i)
+		if (in_val < tbl[i][0])
+			break;
+
+	*out_val = (u8)tbl[i-1][1];
+}
+
+static int interpolate_y(int dx1x0, int dy1y0, int dxx0, int y0)
+{
+	return y0 + DIV_ROUND_CLOSEST((dxx0 * dy1y0), dx1x0);
+}
+
+static int interpolate_x(int dy1y0, int dx1x0, int dyy0, int x0)
+{
+	return x0 + DIV_ROUND_CLOSEST((dyy0 * dx1x0), dy1y0);
+}
+
+static int adc_temp_conv(int in_val, int *out_val, int conv)
+{
+	int tbl_row_cnt, i;
+	struct temp_lookup *adc_temp_tbl;
+
+	if (!chc.pdata) {
+		dev_err(chc.dev, "ADC-lookup table not yet available\n");
+		return -ERANGE;
+	}
+
+	tbl_row_cnt = chc.pdata->max_tbl_row_cnt;
+	adc_temp_tbl = chc.pdata->adc_tbl;
+
+	if (conv == ADC_TO_TEMP) {
+		if (!is_valid_adc_code(in_val))
+			return -ERANGE;
+
+		if (in_val == adc_temp_tbl[tbl_row_cnt-1].adc_val)
+			i = tbl_row_cnt - 1;
+		else {
+			for (i = 0; i < tbl_row_cnt; ++i)
+				if (in_val < adc_temp_tbl[i].adc_val)
+					break;
+		}
+
+		*out_val =
+		    interpolate_y((adc_temp_tbl[i].adc_val
+					- adc_temp_tbl[i - 1].adc_val),
+				  (adc_temp_tbl[i].temp
+				   - adc_temp_tbl[i - 1].temp),
+				  (in_val - adc_temp_tbl[i - 1].adc_val),
+				  adc_temp_tbl[i - 1].temp);
+	} else {
+		if (!is_valid_temp(in_val))
+			return -ERANGE;
+
+		if (in_val == adc_temp_tbl[tbl_row_cnt-1].temp)
+			i = tbl_row_cnt - 1;
+		else {
+			for (i = 0; i < tbl_row_cnt; ++i)
+				if (in_val > adc_temp_tbl[i].temp)
+					break;
+		}
+
+		*((short int *)out_val) =
+		    interpolate_x((adc_temp_tbl[i].temp
+					- adc_temp_tbl[i - 1].temp),
+				  (adc_temp_tbl[i].adc_val
+				   - adc_temp_tbl[i - 1].adc_val),
+				  (in_val - adc_temp_tbl[i - 1].temp),
+				  adc_temp_tbl[i - 1].adc_val);
+	}
+	return 0;
+}
+
+static int pmic_read_reg(u16 addr, u8 *val)
+{
+	int ret;
+
+	ret = intel_scu_ipc_ioread8(addr, val);
+	if (ret) {
+		dev_err(chc.dev,
+			"Error in intel_scu_ipc_ioread8 0x%.4x\n", addr);
+		return -EIO;
+	}
+	return 0;
+}
+
+
+static int __pmic_write_tt(u8 addr, u8 data)
+{
+	int ret;
+
+	ret = intel_scu_ipc_iowrite8(CHRTTADDR_ADDR, addr);
+	if (unlikely(ret))
+		return ret;
+
+	return intel_scu_ipc_iowrite8(CHRTTDATA_ADDR, data);
+}
+
+static inline int pmic_write_tt(u8 addr, u8 data)
+{
+	int ret;
+
+	mutex_lock(&pmic_lock);
+	ret = __pmic_write_tt(addr, data);
+	mutex_unlock(&pmic_lock);
+
+	/* If access is blocked return success to avoid additional
+	*  error handling at client side
+	*/
+	if (ret == -EACCES) {
+		dev_warn(chc.dev, "IPC write blocked due to unsigned kernel/invalid battery\n");
+		ret = 0;
+	}
+	return ret;
+}
+
+static int __pmic_read_tt(u8 addr, u8 *data)
+{
+	int ret;
+
+	ret = intel_scu_ipc_iowrite8(CHRTTADDR_ADDR, addr);
+	if (ret)
+		return ret;
+
+	usleep_range(2000, 3000);
+
+	return intel_scu_ipc_ioread8(CHRTTDATA_ADDR, data);
+}
+
+static inline int pmic_read_tt(u8 addr, u8 *data)
+{
+	int ret;
+
+	mutex_lock(&pmic_lock);
+	ret = __pmic_read_tt(addr, data);
+	mutex_unlock(&pmic_lock);
+
+	return ret;
+}
+
+static int pmic_update_tt(u8 addr, u8 mask, u8 data)
+{
+	u8 tdata;
+	int ret;
+
+	mutex_lock(&pmic_lock);
+	ret = __pmic_read_tt(addr, &tdata);
+	if (unlikely(ret))
+		goto exit;
+
+	tdata = (tdata & ~mask) | (data & mask);
+	ret = __pmic_write_tt(addr, tdata);
+exit:
+	mutex_unlock(&pmic_lock);
+	return ret;
+}
+
+#ifdef CONFIG_DEBUG_FS
+static int pmic_chrgr_reg_show(struct seq_file *seq, void *unused)
+{
+	int ret;
+	u16 addr;
+	u16 val1;
+	u8 val;
+
+	addr = *((u8 *)seq->private);
+
+	if (addr == CHRGRIRQ1_ADDR) {
+		val1 = ioread16(chc.pmic_intr_iomap);
+		val = (u8)(val1 >> 8);
+	} else if (addr == CHGRIRQ0_ADDR) {
+		val1 = ioread16(chc.pmic_intr_iomap);
+		val = (u8)val1;
+	} else {
+		ret = pmic_read_reg(addr, &val);
+		if (ret != 0) {
+			dev_err(chc.dev,
+				"Error reading tt register 0x%2x\n",
+				addr);
+			return -EIO;
+		}
+	}
+
+	seq_printf(seq, "0x%x\n", val);
+	return 0;
+}
+
+static int pmic_chrgr_tt_reg_show(struct seq_file *seq, void *unused)
+{
+	int ret;
+	u8 addr;
+	u8 val;
+
+	addr = *((u8 *)seq->private);
+
+	ret = pmic_read_tt(addr, &val);
+	if (ret != 0) {
+		dev_err(chc.dev,
+			"Error reading tt register 0x%2x\n",
+			addr);
+		return -EIO;
+	}
+
+	seq_printf(seq, "0x%x\n", val);
+	return 0;
+}
+
+static int pmic_chrgr_tt_reg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pmic_chrgr_tt_reg_show, inode->i_private);
+}
+
+static int pmic_chrgr_reg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pmic_chrgr_reg_show, inode->i_private);
+}
+
+static struct dentry *charger_debug_dir;
+static struct pmic_regs_def pmic_regs_bc[] = {
+	PMIC_REG_DEF(PMIC_ID_ADDR),
+	PMIC_REG_DEF(IRQLVL1_ADDR),
+	PMIC_REG_DEF(IRQLVL1_MASK_ADDR),
+	PMIC_REG_DEF(CHGRIRQ0_ADDR),
+	PMIC_REG_DEF(SCHGRIRQ0_ADDR),
+	PMIC_REG_DEF(MCHGRIRQ0_ADDR),
+	PMIC_REG_DEF(LOWBATTDET0_ADDR),
+	PMIC_REG_DEF(LOWBATTDET1_ADDR),
+	PMIC_REG_DEF(BATTDETCTRL_ADDR),
+	PMIC_REG_DEF(VBUSDETCTRL_ADDR),
+	PMIC_REG_DEF(VDCINDETCTRL_ADDR),
+	PMIC_REG_DEF(CHRGRIRQ1_ADDR),
+	PMIC_REG_DEF(SCHGRIRQ1_ADDR),
+	PMIC_REG_DEF(MCHGRIRQ1_ADDR),
+	PMIC_REG_DEF(CHGRCTRL0_ADDR),
+	PMIC_REG_DEF(CHGRCTRL1_ADDR),
+	PMIC_REG_DEF(CHGRSTATUS_ADDR),
+	PMIC_REG_DEF(USBIDCTRL_ADDR),
+	PMIC_REG_DEF(USBIDSTAT_ADDR),
+	PMIC_REG_DEF(WAKESRC_ADDR),
+	PMIC_REG_DEF(THRMBATZONE_ADDR_BC),
+	PMIC_REG_DEF(THRMZN0L_ADDR_BC),
+	PMIC_REG_DEF(THRMZN0H_ADDR_BC),
+	PMIC_REG_DEF(THRMZN1L_ADDR_BC),
+	PMIC_REG_DEF(THRMZN1H_ADDR_BC),
+	PMIC_REG_DEF(THRMZN2L_ADDR_BC),
+	PMIC_REG_DEF(THRMZN2H_ADDR_BC),
+	PMIC_REG_DEF(THRMZN3L_ADDR_BC),
+	PMIC_REG_DEF(THRMZN3H_ADDR_BC),
+	PMIC_REG_DEF(THRMZN4L_ADDR_BC),
+	PMIC_REG_DEF(THRMZN4H_ADDR_BC),
+};
+
+static struct pmic_regs_def pmic_regs_sc[] = {
+	PMIC_REG_DEF(PMIC_ID_ADDR),
+	PMIC_REG_DEF(IRQLVL1_ADDR),
+	PMIC_REG_DEF(IRQLVL1_MASK_ADDR),
+	PMIC_REG_DEF(CHGRIRQ0_ADDR),
+	PMIC_REG_DEF(SCHGRIRQ0_ADDR),
+	PMIC_REG_DEF(MCHGRIRQ0_ADDR),
+	PMIC_REG_DEF(LOWBATTDET0_ADDR),
+	PMIC_REG_DEF(LOWBATTDET1_ADDR),
+	PMIC_REG_DEF(BATTDETCTRL_ADDR),
+	PMIC_REG_DEF(VBUSDETCTRL_ADDR),
+	PMIC_REG_DEF(VDCINDETCTRL_ADDR),
+	PMIC_REG_DEF(CHRGRIRQ1_ADDR),
+	PMIC_REG_DEF(SCHGRIRQ1_ADDR),
+	PMIC_REG_DEF(MCHGRIRQ1_ADDR),
+	PMIC_REG_DEF(CHGRCTRL0_ADDR),
+	PMIC_REG_DEF(CHGRCTRL1_ADDR),
+	PMIC_REG_DEF(CHGRSTATUS_ADDR),
+	PMIC_REG_DEF(USBIDCTRL_ADDR),
+	PMIC_REG_DEF(USBIDSTAT_ADDR),
+	PMIC_REG_DEF(WAKESRC_ADDR),
+	PMIC_REG_DEF(USBPATH_ADDR),
+	PMIC_REG_DEF(USBSRCDETSTATUS_ADDR),
+	PMIC_REG_DEF(THRMBATZONE_ADDR_SC),
+	PMIC_REG_DEF(THRMZN0L_ADDR_SC),
+	PMIC_REG_DEF(THRMZN0H_ADDR_SC),
+	PMIC_REG_DEF(THRMZN1L_ADDR_SC),
+	PMIC_REG_DEF(THRMZN1H_ADDR_SC),
+	PMIC_REG_DEF(THRMZN2L_ADDR_SC),
+	PMIC_REG_DEF(THRMZN2H_ADDR_SC),
+	PMIC_REG_DEF(THRMZN3L_ADDR_SC),
+	PMIC_REG_DEF(THRMZN3H_ADDR_SC),
+	PMIC_REG_DEF(THRMZN4L_ADDR_SC),
+	PMIC_REG_DEF(THRMZN4H_ADDR_SC),
+};
+
+static struct pmic_regs_def pmic_tt_regs[] = {
+	PMIC_REG_DEF(TT_I2CDADDR_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT0OS_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT1OS_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT2OS_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT3OS_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT4OS_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT5OS_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT6OS_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT7OS_ADDR),
+	PMIC_REG_DEF(TT_USBINPUTICCOS_ADDR),
+	PMIC_REG_DEF(TT_USBINPUTICCMASK_ADDR),
+	PMIC_REG_DEF(TT_CHRCVOS_ADDR),
+	PMIC_REG_DEF(TT_CHRCVMASK_ADDR),
+	PMIC_REG_DEF(TT_CHRCCOS_ADDR),
+	PMIC_REG_DEF(TT_CHRCCMASK_ADDR),
+	PMIC_REG_DEF(TT_LOWCHROS_ADDR),
+	PMIC_REG_DEF(TT_LOWCHRMASK_ADDR),
+	PMIC_REG_DEF(TT_WDOGRSTOS_ADDR),
+	PMIC_REG_DEF(TT_WDOGRSTMASK_ADDR),
+	PMIC_REG_DEF(TT_CHGRENOS_ADDR),
+	PMIC_REG_DEF(TT_CHGRENMASK_ADDR),
+	PMIC_REG_DEF(TT_CUSTOMFIELDEN_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT0VAL_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT1VAL_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT2VAL_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT3VAL_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT4VAL_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT5VAL_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT6VAL_ADDR),
+	PMIC_REG_DEF(TT_CHGRINIT7VAL_ADDR),
+	PMIC_REG_DEF(TT_USBINPUTICC100VAL_ADDR),
+	PMIC_REG_DEF(TT_USBINPUTICC150VAL_ADDR),
+	PMIC_REG_DEF(TT_USBINPUTICC500VAL_ADDR),
+	PMIC_REG_DEF(TT_USBINPUTICC900VAL_ADDR),
+	PMIC_REG_DEF(TT_USBINPUTICC1500VAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCVEMRGLOWVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCVCOLDVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCVCOOLVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCVWARMVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCVHOTVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCVEMRGHIVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCCEMRGLOWVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCCCOLDVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCCCOOLVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCCWARMVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCCHOTVAL_ADDR),
+	PMIC_REG_DEF(TT_CHRCCEMRGHIVAL_ADDR),
+	PMIC_REG_DEF(TT_LOWCHRENVAL_ADDR),
+	PMIC_REG_DEF(TT_LOWCHRDISVAL_ADDR),
+};
+
+void dump_pmic_regs(void)
+{
+	int vendor_id = chc.pmic_id & PMIC_VENDOR_ID_MASK;
+	u32 pmic_reg_cnt = 0;
+	u32 reg_index;
+	u8 data;
+	int retval;
+	struct pmic_regs_def *pmic_regs = NULL;
+
+	if (vendor_id == BASINCOVE_VENDORID) {
+		pmic_reg_cnt = ARRAY_SIZE(pmic_regs_bc);
+		pmic_regs = pmic_regs_bc;
+	} else if (vendor_id == SHADYCOVE_VENDORID) {
+		pmic_reg_cnt = ARRAY_SIZE(pmic_regs_sc);
+		pmic_regs = pmic_regs_sc;
+	}
+
+	dev_info(chc.dev, "PMIC Register dump\n");
+	dev_info(chc.dev, "====================\n");
+
+	for (reg_index = 0; reg_index < pmic_reg_cnt; reg_index++) {
+
+		retval = intel_scu_ipc_ioread8(pmic_regs[reg_index].addr,
+				&data);
+		if (retval)
+			dev_err(chc.dev, "Error in reading %x\n",
+				pmic_regs[reg_index].addr);
+		else
+			dev_info(chc.dev, "0x%x=0x%x\n",
+				pmic_regs[reg_index].addr, data);
+	}
+	dev_info(chc.dev, "====================\n");
+}
+
+void dump_pmic_tt_regs(void)
+{
+	u32 pmic_tt_reg_cnt = ARRAY_SIZE(pmic_tt_regs);
+	u32 reg_index;
+	u8 data;
+	int retval;
+
+	dev_info(chc.dev, "PMIC CHRGR TT dump\n");
+	dev_info(chc.dev, "====================\n");
+
+	for (reg_index = 0; reg_index < pmic_tt_reg_cnt; reg_index++) {
+
+		retval = pmic_read_tt(pmic_tt_regs[reg_index].addr, &data);
+		if (retval)
+			dev_err(chc.dev, "Error in reading %x\n",
+				pmic_tt_regs[reg_index].addr);
+		else
+			dev_info(chc.dev, "0x%x=0x%x\n",
+				pmic_tt_regs[reg_index].addr, data);
+	}
+
+	dev_info(chc.dev, "====================\n");
+}
+static const struct file_operations pmic_chrgr_reg_fops = {
+	.open = pmic_chrgr_reg_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release
+};
+
+static const struct file_operations pmic_chrgr_tt_reg_fops = {
+	.open = pmic_chrgr_tt_reg_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release
+};
+
+static void pmic_debugfs_init(void)
+{
+	struct dentry *fentry;
+	struct dentry *pmic_regs_dir;
+	struct dentry *pmic_tt_regs_dir;
+
+	u32 reg_index;
+	int vendor_id = chc.pmic_id & PMIC_VENDOR_ID_MASK;
+	u32 pmic_reg_cnt = 0;
+	u32 pmic_tt_reg_cnt = ARRAY_SIZE(pmic_tt_regs);
+	char name[PMIC_REG_NAME_LEN] = {0};
+	struct pmic_regs_def *pmic_regs = NULL;
+
+	if (vendor_id == BASINCOVE_VENDORID) {
+		pmic_reg_cnt = ARRAY_SIZE(pmic_regs_bc);
+		pmic_regs = pmic_regs_bc;
+	} else if (vendor_id == SHADYCOVE_VENDORID) {
+		pmic_reg_cnt = ARRAY_SIZE(pmic_regs_sc);
+		pmic_regs = pmic_regs_sc;
+	}
+
+	/* Creating a directory under debug fs for charger */
+	charger_debug_dir = debugfs_create_dir(DRIVER_NAME , NULL) ;
+	if (charger_debug_dir == NULL)
+		goto debugfs_root_exit;
+
+	/* Create a directory for pmic charger registers */
+	pmic_regs_dir = debugfs_create_dir("pmic_ccsm_regs",
+			charger_debug_dir);
+
+	if (pmic_regs_dir == NULL)
+		goto debugfs_err_exit;
+
+	for (reg_index = 0; reg_index < pmic_reg_cnt; reg_index++) {
+
+		sprintf(name, "%s",
+			pmic_regs[reg_index].reg_name);
+
+		fentry = debugfs_create_file(name,
+				S_IRUGO,
+				pmic_regs_dir,
+				&pmic_regs[reg_index].addr,
+				&pmic_chrgr_reg_fops);
+
+		if (fentry == NULL)
+			goto debugfs_err_exit;
+	}
+
+	/* Create a directory for pmic tt charger registers */
+	pmic_tt_regs_dir = debugfs_create_dir("pmic_ccsm_tt_regs",
+			charger_debug_dir);
+
+	if (pmic_tt_regs_dir == NULL)
+		goto debugfs_err_exit;
+
+	for (reg_index = 0; reg_index < pmic_tt_reg_cnt; reg_index++) {
+
+		sprintf(name, "%s", pmic_tt_regs[reg_index].reg_name);
+
+		fentry = debugfs_create_file(name,
+				S_IRUGO,
+				pmic_tt_regs_dir,
+				&pmic_tt_regs[reg_index].addr,
+				&pmic_chrgr_tt_reg_fops);
+
+		if (fentry == NULL)
+			goto debugfs_err_exit;
+	}
+
+	dev_dbg(chc.dev, "Debugfs created successfully!!");
+	return;
+
+debugfs_err_exit:
+	debugfs_remove_recursive(charger_debug_dir);
+debugfs_root_exit:
+	dev_err(chc.dev, "Error creating debugfs entry!!");
+	return;
+}
+
+static void pmic_debugfs_exit(void)
+{
+	if (charger_debug_dir != NULL)
+		debugfs_remove_recursive(charger_debug_dir);
+}
+#endif
+
+static void pmic_bat_zone_changed(void)
+{
+	int retval;
+	int cur_zone;
+	u16 addr = 0;
+	u8 data = 0;
+	struct power_supply *psy_bat;
+	int vendor_id;
+
+	vendor_id = chc.pmic_id & PMIC_VENDOR_ID_MASK;
+	if (vendor_id == BASINCOVE_VENDORID)
+		addr = THRMBATZONE_ADDR_BC;
+	else if (vendor_id == SHADYCOVE_VENDORID)
+		addr = THRMBATZONE_ADDR_SC;
+
+	retval = intel_scu_ipc_ioread8(addr, &data);
+	if (retval) {
+		dev_err(chc.dev, "Error in reading battery zone\n");
+		return;
+	}
+
+	cur_zone = data & THRMBATZONE_MASK;
+	dev_info(chc.dev, "Battery Zone changed. Current zone is %d\n",
+			(data & THRMBATZONE_MASK));
+
+	/* if current zone is the top and bottom zones then report OVERHEAT
+	 */
+	if ((cur_zone == PMIC_BZONE_LOW) || (cur_zone == PMIC_BZONE_HIGH))
+		chc.health = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else
+		chc.health = POWER_SUPPLY_HEALTH_GOOD;
+
+	psy_bat = get_psy_battery();
+
+	if (psy_bat && psy_bat->external_power_changed)
+		psy_bat->external_power_changed(psy_bat);
+
+	return;
+}
+
+static void pmic_battery_overheat_handler(bool stat)
+{
+	if (stat)
+		chc.health = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else
+		chc.health = POWER_SUPPLY_HEALTH_GOOD;
+	return;
+}
+
+int pmic_get_health(void)
+{
+	return chc.health;
+}
+
+int pmic_enable_vbus(bool enable)
+{
+	int ret;
+	int vendor_id;
+
+	vendor_id = chc.pmic_id & PMIC_VENDOR_ID_MASK;
+
+	if (enable) {
+		ret = intel_scu_ipc_update_register(CHGRCTRL0_ADDR,
+				WDT_NOKICK_ENABLE, CHGRCTRL0_WDT_NOKICK_MASK);
+		if (ret)
+			return ret;
+
+		if (vendor_id == SHADYCOVE_VENDORID)
+			ret = intel_scu_ipc_update_register(CHGRCTRL1_ADDR,
+					CHGRCTRL1_OTGMODE_MASK,
+					CHGRCTRL1_OTGMODE_MASK);
+	} else {
+		ret = intel_scu_ipc_update_register(CHGRCTRL0_ADDR,
+				WDT_NOKICK_DISABLE, CHGRCTRL0_WDT_NOKICK_MASK);
+		if (ret)
+			return ret;
+
+		if (vendor_id == SHADYCOVE_VENDORID)
+			ret = intel_scu_ipc_update_register(CHGRCTRL1_ADDR,
+					0x0, CHGRCTRL1_OTGMODE_MASK);
+	}
+
+	/* If access is blocked return success to avoid additional
+	*  error handling at client side
+	*/
+	if (ret == -EACCES) {
+		dev_warn(chc.dev, "IPC blocked due to unsigned kernel/invalid battery\n");
+		ret = 0;
+	}
+
+	return ret;
+}
+
+int pmic_enable_charging(bool enable)
+{
+	int ret;
+	u8 val;
+
+	if (enable) {
+		ret = intel_scu_ipc_update_register(CHGRCTRL1_ADDR,
+			CHGRCTRL1_FTEMP_EVENT_MASK, CHGRCTRL1_FTEMP_EVENT_MASK);
+		if (ret)
+			return ret;
+	}
+
+	val = (enable) ? 0 : EXTCHRDIS_ENABLE;
+
+	ret = intel_scu_ipc_update_register(CHGRCTRL0_ADDR,
+			val, CHGRCTRL0_EXTCHRDIS_MASK);
+	/* If access is blocked return success to avoid additional
+	*  error handling at client side
+	*/
+	if (ret == -EACCES) {
+		dev_warn(chc.dev, "IPC blocked due to unsigned kernel/invalid battery\n");
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static inline int update_zone_cc(int zone, u8 reg_val)
+{
+	u8 addr_cc = TT_CHRCCHOTVAL_ADDR - zone;
+	dev_dbg(chc.dev, "%s:%X=%X\n", __func__, addr_cc, reg_val);
+	return pmic_write_tt(addr_cc, reg_val);
+}
+
+static inline int update_zone_cv(int zone, u8 reg_val)
+{
+	u8 addr_cv = TT_CHRCVHOTVAL_ADDR - zone;
+	dev_dbg(chc.dev, "%s:%X=%X\n", __func__, addr_cv, reg_val);
+	return pmic_write_tt(addr_cv, reg_val);
+}
+
+static inline int update_zone_temp(int zone, u16 adc_val)
+{
+	int ret;
+	u16 addr_tzone;
+	int vendor_id = chc.pmic_id & PMIC_VENDOR_ID_MASK;
+
+	if (vendor_id == BASINCOVE_VENDORID)
+		addr_tzone = THRMZN4H_ADDR_BC - (2 * zone);
+	else if (vendor_id == SHADYCOVE_VENDORID) {
+		/* to take care of address-discontinuity of zone-registers */
+		int offset_zone = zone;
+		if (zone >= 3)
+			offset_zone += 1;
+
+		addr_tzone = THRMZN4H_ADDR_SC - (2 * offset_zone);
+	} else {
+		dev_err(chc.dev, "%s: invalid vendor id %X\n", __func__, vendor_id);
+		return -EINVAL;
+	}
+
+	ret = intel_scu_ipc_iowrite8(addr_tzone, (u8)(adc_val >> 8));
+	if (unlikely(ret))
+		return ret;
+	dev_dbg(chc.dev, "%s:%X:%X=%X\n", __func__, addr_tzone,
+				(addr_tzone+1), adc_val);
+
+	return intel_scu_ipc_iowrite8(addr_tzone+1, (u8)(adc_val & 0xFF));
+}
+
+int pmic_set_cc(int new_cc)
+{
+	struct ps_pse_mod_prof *bcprof = chc.actual_bcprof;
+	struct ps_pse_mod_prof *r_bcprof = chc.runtime_bcprof;
+	int temp_mon_ranges;
+	int new_cc1;
+	int ret;
+	int i;
+	u8 reg_val = 0;
+
+	/* No need to write PMIC if CC = 0 */
+	if (!new_cc)
+		return 0;
+
+	temp_mon_ranges = min_t(u16, bcprof->temp_mon_ranges,
+			BATT_TEMP_NR_RNG);
+
+	for (i = 0; i < temp_mon_ranges; ++i) {
+		new_cc1 = min_t(int, new_cc,
+				bcprof->temp_mon_range[i].full_chrg_cur);
+
+		if (new_cc1 != r_bcprof->temp_mon_range[i].full_chrg_cur) {
+			if (chc.pdata->cc_to_reg) {
+				chc.pdata->cc_to_reg(new_cc1, &reg_val);
+				ret = update_zone_cc(i, reg_val);
+				if (unlikely(ret))
+					return ret;
+			}
+			r_bcprof->temp_mon_range[i].full_chrg_cur = new_cc1;
+		}
+	}
+
+	/* send the new CC and CV */
+	intel_scu_ipc_update_register(CHGRCTRL1_ADDR,
+		CHGRCTRL1_FTEMP_EVENT_MASK, CHGRCTRL1_FTEMP_EVENT_MASK);
+
+	return 0;
+}
+
+int pmic_set_cv(int new_cv)
+{
+	struct ps_pse_mod_prof *bcprof = chc.actual_bcprof;
+	struct ps_pse_mod_prof *r_bcprof = chc.runtime_bcprof;
+	int temp_mon_ranges;
+	int new_cv1;
+	int ret;
+	int i;
+	u8 reg_val = 0;
+
+	/* No need to write PMIC if CV = 0 */
+	if (!new_cv)
+		return 0;
+
+	temp_mon_ranges = min_t(u16, bcprof->temp_mon_ranges,
+			BATT_TEMP_NR_RNG);
+
+	for (i = 0; i < temp_mon_ranges; ++i) {
+		new_cv1 = min_t(int, new_cv,
+				bcprof->temp_mon_range[i].full_chrg_vol);
+
+		if (new_cv1 != r_bcprof->temp_mon_range[i].full_chrg_vol) {
+			if (chc.pdata->cv_to_reg) {
+				chc.pdata->cv_to_reg(new_cv1, &reg_val);
+				ret = update_zone_cv(i, reg_val);
+				if (unlikely(ret))
+					return ret;
+			}
+			r_bcprof->temp_mon_range[i].full_chrg_vol = new_cv1;
+		}
+	}
+
+	/* send the new CC and CV */
+	intel_scu_ipc_update_register(CHGRCTRL1_ADDR,
+		CHGRCTRL1_FTEMP_EVENT_MASK, CHGRCTRL1_FTEMP_EVENT_MASK);
+
+	return 0;
+}
+
+int pmic_set_ilimma(int ilim_ma)
+{
+	u8 reg_val;
+	int ret;
+
+	lookup_regval(pmic_inlmt, ARRAY_SIZE(pmic_inlmt),
+			ilim_ma, &reg_val);
+	dev_dbg(chc.dev, "Setting inlmt %d in register %x=%x\n", ilim_ma,
+		CHGRCTRL1_ADDR, reg_val);
+	ret = intel_scu_ipc_iowrite8(CHGRCTRL1_ADDR, reg_val);
+
+	/* If access is blocked return success to avoid additional
+	*  error handling at client side
+	*/
+	if (ret == -EACCES) {
+		dev_warn(chc.dev, "IPC blocked due to unsigned kernel/invalid battery\n");
+		ret = 0;
+	}
+
+	return ret;
+}
+
+/**
+ * pmic_read_adc_val - read ADC value of specified sensors
+ * @channel: channel of the sensor to be sampled
+ * @sensor_val: pointer to the charger property to hold sampled value
+ * @chc :  battery info pointer
+ *
+ * Returns 0 if success
+ */
+static int pmic_read_adc_val(int channel, int *sensor_val,
+			      struct pmic_chrgr_drv_context *chc)
+{
+	int val;
+	int ret;
+	struct iio_channel *indio_chan;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0))
+	indio_chan = iio_st_channel_get("BATTEMP", "BATTEMP0");
+#else
+	indio_chan = iio_channel_get(NULL, "BATTEMP0");
+#endif
+	if (IS_ERR_OR_NULL(indio_chan)) {
+		ret = PTR_ERR(indio_chan);
+		goto exit;
+	}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0))
+	ret = iio_st_read_channel_raw(indio_chan, &val);
+#else
+	ret = iio_read_channel_raw(indio_chan, &val);
+#endif
+	if (ret) {
+		dev_err(chc->dev, "IIO channel read error\n");
+		goto err_exit;
+	}
+
+	switch (channel) {
+	case GPADC_BATTEMP0:
+		ret = CONVERT_ADC_TO_TEMP(val, sensor_val);
+		break;
+	default:
+		dev_err(chc->dev, "invalid sensor%d", channel);
+		ret = -EINVAL;
+	}
+	dev_dbg(chc->dev, "pmic_ccsm pmic_ccsm.0: %s adc val=%x, %d temp=%d\n",
+		__func__, val, val, *sensor_val);
+
+err_exit:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0))
+	iio_st_channel_release(indio_chan);
+#else
+	iio_channel_release(indio_chan);
+#endif
+exit:
+	return ret;
+}
+
+int pmic_get_battery_pack_temp(int *temp)
+{
+	if (chc.invalid_batt)
+		return -ENODEV;
+	return pmic_read_adc_val(GPADC_BATTEMP0, temp, &chc);
+}
+
+static int get_charger_type()
+{
+	int ret, i = 0;
+	u8 val;
+	int chgr_type;
+
+	do {
+		ret = pmic_read_reg(USBSRCDETSTATUS_ADDR, &val);
+		if (ret != 0) {
+			dev_err(chc.dev,
+				"Error reading USBSRCDETSTAT-register 0x%2x\n",
+				USBSRCDETSTATUS_ADDR);
+			return 0;
+		}
+
+		i++;
+		dev_info(chc.dev, "Read USBSRCDETSTATUS val: %x\n", val);
+
+		if (val & USBSRCDET_SUSBHWDET_DETSUCC)
+			break;
+		else
+			msleep(USBSRCDET_SLEEP_TIME);
+	} while (i < USBSRCDET_RETRY_CNT);
+
+	if (!(val & USBSRCDET_SUSBHWDET_DETSUCC)) {
+		dev_err(chc.dev, "Charger detection unsuccessful after %dms\n",
+			i * USBSRCDET_SLEEP_TIME);
+		return 0;
+	}
+
+	chgr_type = (val & USBSRCDET_USBSRCRSLT_MASK) >> 2;
+	dev_info(chc.dev, "Charger type after detection complete: %d\n",
+			(val & USBSRCDET_USBSRCRSLT_MASK) >> 2);
+
+	switch (chgr_type) {
+	case PMIC_CHARGER_TYPE_SDP:
+		return POWER_SUPPLY_CHARGER_TYPE_USB_SDP;
+	case PMIC_CHARGER_TYPE_DCP:
+		return POWER_SUPPLY_CHARGER_TYPE_USB_DCP;
+	case PMIC_CHARGER_TYPE_CDP:
+		return POWER_SUPPLY_CHARGER_TYPE_USB_CDP;
+	case PMIC_CHARGER_TYPE_ACA:
+		return POWER_SUPPLY_CHARGER_TYPE_USB_ACA;
+	case PMIC_CHARGER_TYPE_SE1:
+		return POWER_SUPPLY_CHARGER_TYPE_SE1;
+	case PMIC_CHARGER_TYPE_MHL:
+		return POWER_SUPPLY_CHARGER_TYPE_MHL;
+	default:
+		return POWER_SUPPLY_CHARGER_TYPE_NONE;
+	}
+}
+
+static void handle_internal_usbphy_notifications(int mask)
+{
+	struct power_supply_cable_props cap;
+
+	if (mask) {
+		cap.chrg_evt = POWER_SUPPLY_CHARGER_EVENT_CONNECT;
+		cap.chrg_type = get_charger_type();
+		chc.charger_type = cap.chrg_type;
+	} else {
+		cap.chrg_evt = POWER_SUPPLY_CHARGER_EVENT_DISCONNECT;
+		cap.chrg_type = chc.charger_type;
+	}
+
+	if (cap.chrg_type == POWER_SUPPLY_CHARGER_TYPE_USB_SDP)
+		cap.ma = 0;
+	else if ((cap.chrg_type == POWER_SUPPLY_CHARGER_TYPE_USB_DCP)
+			|| (cap.chrg_type == POWER_SUPPLY_TYPE_USB_CDP)
+			|| (cap.chrg_type == POWER_SUPPLY_CHARGER_TYPE_SE1))
+		cap.ma = 1500;
+
+	dev_info(chc.dev, "Notifying OTG ev:%d, evt:%d, chrg_type:%d, mA:%d\n",
+			USB_EVENT_CHARGER, cap.chrg_evt, cap.chrg_type,
+			cap.ma);
+	atomic_notifier_call_chain(&chc.otg->notifier,
+			USB_EVENT_CHARGER, &cap);
+}
+
+/* ShadyCove-WA for VBUS removal detect issue */
+int pmic_handle_low_supply(void)
+{
+	int ret;
+	u8 val;
+	int vendor_id = chc.pmic_id & PMIC_VENDOR_ID_MASK;
+
+	dev_info(chc.dev, "Low-supply event received from external-charger\n");
+	if (vendor_id == BASINCOVE_VENDORID || !chc.vbus_connect_status) {
+		dev_err(chc.dev, "Ignore Low-supply event received\n");
+		return 0;
+	}
+
+	msleep(50);
+	ret = pmic_read_reg(SCHGRIRQ1_ADDR, &val);
+	if (ret) {
+		dev_err(chc.dev,
+			"Error reading SCHGRIRQ1-register 0x%2x\n",
+			SCHGRIRQ1_ADDR);
+		return ret;
+	}
+
+	if (!(val & SCHRGRIRQ1_SVBUSDET_MASK)) {
+		int mask = 0;
+
+		dev_info(chc.dev, "USB VBUS Removed. Notifying OTG driver\n");
+		chc.vbus_connect_status = false;
+
+		if (chc.is_internal_usb_phy)
+			handle_internal_usbphy_notifications(mask);
+		else
+			atomic_notifier_call_chain(&chc.otg->notifier,
+					USB_EVENT_VBUS, &mask);
+	}
+
+	return ret;
+}
+
+static void handle_level0_interrupt(u8 int_reg, u8 stat_reg,
+				struct interrupt_info int_info[],
+				int int_info_size)
+{
+	int i;
+	bool int_stat;
+	char *log_msg;
+
+	for (i = 0; i < int_info_size; ++i) {
+
+		/*continue if interrupt register bit is not set */
+		if (!(int_reg & int_info[i].int_reg_mask))
+			continue;
+
+		/*log message if interrupt bit is set */
+		if (int_info[i].log_msg_int_reg_true)
+			dev_err(chc.dev, "%s",
+					int_info[i].log_msg_int_reg_true);
+
+		/* interrupt bit is set.call int handler. */
+		if (int_info[i].int_handle)
+			int_info[i].int_handle();
+
+		/* continue if stat_reg_mask is zero which
+		 *  means ignore status register
+		 */
+		if (!(int_info[i].stat_reg_mask))
+			continue;
+
+		dev_dbg(chc.dev,
+				"stat_reg=%X int_info[i].stat_reg_mask=%X",
+				stat_reg, int_info[i].stat_reg_mask);
+
+		/* check if the interrupt status is true */
+		int_stat = (stat_reg & int_info[i].stat_reg_mask);
+
+		/* log message */
+		log_msg = int_stat ? int_info[i].log_msg_stat_true :
+			int_info[i].log_msg_stat_false;
+
+		if (log_msg)
+			dev_err(chc.dev, "%s", log_msg);
+
+		/* call status handler function */
+		if (int_info[i].stat_handle)
+			int_info[i].stat_handle(int_stat);
+
+	}
+
+	return ;
+}
+
+static void handle_level1_interrupt(u8 int_reg, u8 stat_reg)
+{
+	int mask;
+	u8 usb_id_sts;
+	int ret;
+
+	if (!int_reg)
+		return;
+
+	mask = !!(int_reg & stat_reg);
+	if (int_reg & CHRGRIRQ1_SUSBIDDET_MASK) {
+		if (mask)
+			dev_info(chc.dev,
+				"USB ID Detected. Notifying OTG driver\n");
+		else
+			dev_info(chc.dev,
+				"USB ID Removed. Notifying OTG driver\n");
+		atomic_notifier_call_chain(&chc.otg->notifier,
+				USB_EVENT_ID, &mask);
+	}
+
+	if (int_reg & CHRGRIRQ1_SVBUSDET_MASK) {
+		if (mask) {
+			dev_info(chc.dev,
+				"USB VBUS Detected. Notifying OTG driver\n");
+			chc.vbus_connect_status = true;
+		} else {
+			dev_info(chc.dev, "USB VBUS Removed. Notifying OTG driver\n");
+			chc.vbus_connect_status = false;
+		}
+
+		if (chc.is_internal_usb_phy)
+			handle_internal_usbphy_notifications(mask);
+		else
+			atomic_notifier_call_chain(&chc.otg->notifier,
+					USB_EVENT_VBUS, &mask);
+	}
+
+	return;
+}
+static void pmic_event_worker(struct work_struct *work)
+{
+	struct pmic_event *evt, *tmp;
+
+	dev_dbg(chc.dev, "%s\n", __func__);
+
+	mutex_lock(&chc.evt_queue_lock);
+	list_for_each_entry_safe(evt, tmp, &chc.evt_queue, node) {
+		list_del(&evt->node);
+
+		dev_dbg(chc.dev, "CHGRIRQ0=%X SCHGRIRQ0=%X CHGRIRQ1=%x SCHGRIRQ1=%X\n",
+				evt->chgrirq0_int, evt->chgrirq0_stat,
+				evt->chgrirq1_int, evt->chgrirq1_stat);
+		if (evt->chgrirq0_int)
+			handle_level0_interrupt(evt->chgrirq0_int,
+				evt->chgrirq0_stat, chgrirq0_info,
+				ARRAY_SIZE(chgrirq0_info));
+
+		if (evt->chgrirq1_stat)
+			handle_level1_interrupt(evt->chgrirq1_int,
+							evt->chgrirq1_stat);
+		kfree(evt);
+	}
+
+	mutex_unlock(&chc.evt_queue_lock);
+}
+
+static irqreturn_t pmic_isr(int irq, void *data)
+{
+	u16 pmic_intr;
+	u8 chgrirq0_int;
+	u8 chgrirq1_int;
+	u8 mask = ((CHRGRIRQ1_SVBUSDET_MASK) | (CHRGRIRQ1_SUSBIDDET_MASK));
+
+	pmic_intr = ioread16(chc.pmic_intr_iomap);
+	chgrirq0_int = (u8)pmic_intr;
+	chgrirq1_int = (u8)(pmic_intr >> 8);
+
+	if (!chgrirq1_int && !(chgrirq0_int & PMIC_CHRGR_INT0_MASK))
+		return IRQ_NONE;
+
+	dev_dbg(chc.dev, "%s", __func__);
+
+	return IRQ_WAKE_THREAD;
+}
+static irqreturn_t pmic_thread_handler(int id, void *data)
+{
+	u16 pmic_intr;
+	struct pmic_event *evt;
+	int ret;
+
+	evt = kzalloc(sizeof(*evt), GFP_ATOMIC);
+	if (evt == NULL) {
+		dev_dbg(chc.dev, "Error allocating evt structure in fn:%s\n",
+			__func__);
+		return IRQ_NONE;
+	}
+
+	pmic_intr = ioread16(chc.pmic_intr_iomap);
+	evt->chgrirq0_int = (u8)pmic_intr;
+	evt->chgrirq1_int = (u8)(pmic_intr >> 8);
+	dev_dbg(chc.dev, "irq0=%x irq1=%x\n",
+		evt->chgrirq0_int, evt->chgrirq1_int);
+
+	/*
+	In case this is an external charger interrupt, we are
+	clearing the level 1 irq register and let external charger
+	driver handle the interrupt.
+	 */
+
+	if (!(evt->chgrirq1_int) &&
+		!(evt->chgrirq0_int & PMIC_CHRGR_CCSM_INT0_MASK)) {
+		intel_scu_ipc_update_register(IRQLVL1_MASK_ADDR, 0x00,
+				IRQLVL1_CHRGR_MASK);
+		if ((chc.invalid_batt) &&
+			(evt->chgrirq0_int & PMIC_CHRGR_EXT_CHRGR_INT_MASK)) {
+			dev_dbg(chc.dev, "Handling external charger interrupt!!\n");
+			kfree(evt);
+			return IRQ_HANDLED;
+		}
+		kfree(evt);
+		dev_dbg(chc.dev, "Unhandled interrupt!!\n");
+		return IRQ_NONE;
+	}
+
+	if (evt->chgrirq0_int & PMIC_CHRGR_CCSM_INT0_MASK) {
+		ret = intel_scu_ipc_ioread8(SCHGRIRQ0_ADDR,
+				&evt->chgrirq0_stat);
+		if (ret) {
+			dev_err(chc.dev,
+				"%s: Error(%d) in intel_scu_ipc_ioread8. Faile to read SCHGRIRQ0_ADDR\n",
+					__func__, ret);
+			kfree(evt);
+			goto end;
+		}
+	}
+	if (evt->chgrirq1_int) {
+		ret = intel_scu_ipc_ioread8(SCHGRIRQ1_ADDR,
+				&evt->chgrirq1_stat);
+		if (ret) {
+			dev_err(chc.dev,
+				"%s: Error(%d) in intel_scu_ipc_ioread8. Faile to read SCHGRIRQ1_ADDR\n",
+					__func__, ret);
+			kfree(evt);
+			goto end;
+		}
+	}
+
+	INIT_LIST_HEAD(&evt->node);
+
+	mutex_lock(&chc.evt_queue_lock);
+	list_add_tail(&evt->node, &chc.evt_queue);
+	mutex_unlock(&chc.evt_queue_lock);
+
+	queue_work(system_nrt_wq, &chc.evt_work);
+
+end:
+	/*clear first level IRQ */
+	dev_dbg(chc.dev, "Clearing IRQLVL1_MASK_ADDR\n");
+	intel_scu_ipc_update_register(IRQLVL1_MASK_ADDR, 0x00,
+			IRQLVL1_CHRGR_MASK);
+
+	return IRQ_HANDLED;
+}
+
+static int pmic_init(void)
+{
+	int ret = 0, i, temp_mon_ranges;
+	u16 adc_val;
+	u8 reg_val;
+	struct ps_pse_mod_prof *bcprof = chc.actual_bcprof;
+
+
+	temp_mon_ranges = min_t(u16, bcprof->temp_mon_ranges,
+			BATT_TEMP_NR_RNG);
+	for (i = 0; i < temp_mon_ranges; ++i) {
+		ret =
+		CONVERT_TEMP_TO_ADC(bcprof->temp_mon_range[i].temp_up_lim,
+				(int *)&adc_val);
+		if (unlikely(ret)) {
+			dev_err(chc.dev,
+				"Error converting temperature for zone %d!!\n",
+				i);
+			return ret;
+		}
+		ret = update_zone_temp(i, adc_val);
+		if (unlikely(ret)) {
+			dev_err(chc.dev,
+				"Error updating zone temp for zone %d\n",
+				i);
+			return ret;
+		}
+
+		if (chc.pdata->cc_to_reg)
+			chc.pdata->cc_to_reg(bcprof->temp_mon_range[i].
+					full_chrg_cur, &reg_val);
+
+		ret = update_zone_cc(i, reg_val);
+		if (unlikely(ret)) {
+			dev_err(chc.dev,
+				"Error updating zone cc for zone %d\n",
+				i);
+			return ret;
+		}
+
+		if (chc.pdata->cv_to_reg)
+			chc.pdata->cv_to_reg(bcprof->temp_mon_range[i].
+					full_chrg_vol, &reg_val);
+
+		ret = update_zone_cv(i, reg_val);
+		if (unlikely(ret)) {
+			dev_err(chc.dev,
+				"Error updating zone cv for zone %d\n",
+				i);
+			return ret;
+		}
+
+		/* Write lowest temp limit */
+		if (i == (bcprof->temp_mon_ranges - 1)) {
+			ret = CONVERT_TEMP_TO_ADC(bcprof->temp_low_lim,
+							(int *)&adc_val);
+			if (unlikely(ret)) {
+				dev_err(chc.dev,
+					"Error converting low lim temp!!\n");
+				return ret;
+			}
+
+			ret = update_zone_temp(i+1, adc_val);
+
+			if (unlikely(ret)) {
+				dev_err(chc.dev,
+					"Error updating last temp for zone %d\n",
+					i+1);
+				return ret;
+			}
+		}
+	}
+	ret = pmic_update_tt(TT_CUSTOMFIELDEN_ADDR,
+				TT_HOT_COLD_LC_MASK,
+				TT_HOT_COLD_LC_DIS);
+
+	if (unlikely(ret)) {
+		dev_err(chc.dev, "Error updating TT_CUSTOMFIELD_EN reg\n");
+		return ret;
+	}
+
+	if (chc.pdata->inlmt_to_reg)
+		chc.pdata->inlmt_to_reg(USBINPUTICC100VAL, &reg_val);
+
+	ret = pmic_write_tt(TT_USBINPUTICC100VAL_ADDR, reg_val);
+	return ret;
+}
+
+static inline void print_ps_pse_mod_prof(struct ps_pse_mod_prof *bcprof)
+{
+	int i, temp_mon_ranges;
+
+	dev_info(chc.dev, "ChrgProf: batt_id:%s\n", bcprof->batt_id);
+	dev_info(chc.dev, "ChrgProf: battery_type:%u\n", bcprof->battery_type);
+	dev_info(chc.dev, "ChrgProf: capacity:%u\n", bcprof->capacity);
+	dev_info(chc.dev, "ChrgProf: voltage_max:%u\n", bcprof->voltage_max);
+	dev_info(chc.dev, "ChrgProf: chrg_term_ma:%u\n", bcprof->chrg_term_ma);
+	dev_info(chc.dev, "ChrgProf: low_batt_mV:%u\n", bcprof->low_batt_mV);
+	dev_info(chc.dev, "ChrgProf: disch_tmp_ul:%d\n", bcprof->disch_tmp_ul);
+	dev_info(chc.dev, "ChrgProf: disch_tmp_ll:%d\n", bcprof->disch_tmp_ll);
+	dev_info(chc.dev, "ChrgProf: temp_mon_ranges:%u\n",
+			bcprof->temp_mon_ranges);
+	temp_mon_ranges = min_t(u16, bcprof->temp_mon_ranges,
+			BATT_TEMP_NR_RNG);
+
+	for (i = 0; i < temp_mon_ranges; ++i) {
+		dev_info(chc.dev, "ChrgProf: temp_up_lim[%d]:%d\n",
+				i, bcprof->temp_mon_range[i].temp_up_lim);
+		dev_info(chc.dev, "ChrgProf: full_chrg_vol[%d]:%d\n",
+				i, bcprof->temp_mon_range[i].full_chrg_vol);
+		dev_info(chc.dev, "ChrgProf: full_chrg_cur[%d]:%d\n",
+				i, bcprof->temp_mon_range[i].full_chrg_cur);
+		dev_info(chc.dev, "ChrgProf: maint_chrgr_vol_ll[%d]:%d\n",
+				i, bcprof->temp_mon_range[i].maint_chrg_vol_ll);
+		dev_info(chc.dev, "ChrgProf: maint_chrgr_vol_ul[%d]:%d\n",
+				i, bcprof->temp_mon_range[i].maint_chrg_vol_ul);
+		dev_info(chc.dev, "ChrgProf: maint_chrg_cur[%d]:%d\n",
+				i, bcprof->temp_mon_range[i].maint_chrg_cur);
+	}
+	dev_info(chc.dev, "ChrgProf: temp_low_lim:%d\n", bcprof->temp_low_lim);
+}
+
+static int find_tempzone_index(short int *interval,
+				int *num_zones,
+				short int *temp_up_lim)
+{
+	struct ps_pse_mod_prof *bprof = chc.sfi_bcprof->batt_prof;
+	int up_lim_index = 0, low_lim_index = -1;
+	int diff = 0;
+	int i;
+
+	*num_zones = MIN_BATT_PROF - bprof->temp_mon_ranges + 1;
+	if ((*num_zones) <= 0)
+		return 0;
+
+	for (i = 0 ; i < bprof->temp_mon_ranges ; i++) {
+		if (bprof->temp_mon_range[i].temp_up_lim == BATT_TEMP_WARM)
+			up_lim_index = i;
+	}
+
+	low_lim_index = up_lim_index + 1;
+
+	if (low_lim_index == bprof->temp_mon_ranges)
+		diff = bprof->temp_low_lim -
+			bprof->temp_mon_range[up_lim_index].temp_up_lim;
+	else
+		diff = bprof->temp_mon_range[low_lim_index].temp_up_lim -
+			bprof->temp_mon_range[up_lim_index].temp_up_lim;
+
+	*interval = diff / (*num_zones);
+	*temp_up_lim = bprof->temp_mon_range[up_lim_index].temp_up_lim;
+
+	return up_lim_index;
+}
+
+
+static void set_pmic_batt_prof(struct ps_pse_mod_prof *new_prof,
+				struct ps_pse_mod_prof *bprof)
+{
+	int num_zones;
+	int split_index;
+	int i, j = 0;
+	short int temp_up_lim;
+	short int interval;
+
+	if ((new_prof == NULL) || (bprof == NULL))
+		return;
+
+	if (!NEED_ZONE_SPLIT(bprof)) {
+		dev_info(chc.dev, "No need to split the zones!!\n");
+		memcpy(new_prof, bprof, sizeof(struct ps_pse_mod_prof));
+		return;
+	}
+
+	strcpy(&(new_prof->batt_id[0]), &(bprof->batt_id[0]));
+	new_prof->battery_type = bprof->battery_type;
+	new_prof->capacity = bprof->capacity;
+	new_prof->voltage_max =  bprof->voltage_max;
+	new_prof->chrg_term_ma = bprof->chrg_term_ma;
+	new_prof->low_batt_mV =  bprof->low_batt_mV;
+	new_prof->disch_tmp_ul = bprof->disch_tmp_ul;
+	new_prof->disch_tmp_ll = bprof->disch_tmp_ll;
+
+	split_index = find_tempzone_index(&interval, &num_zones, &temp_up_lim);
+
+	for (i = 0 ; i < bprof->temp_mon_ranges; i++) {
+		if ((i == split_index) && (num_zones > 0)) {
+			for (j = 0; j < num_zones; j++,
+					temp_up_lim += interval) {
+				memcpy(&new_prof->temp_mon_range[i+j],
+					&bprof->temp_mon_range[i],
+					sizeof(bprof->temp_mon_range[i]));
+				new_prof->temp_mon_range[i+j].temp_up_lim =
+					temp_up_lim;
+			}
+			j--;
+		} else {
+			memcpy(&new_prof->temp_mon_range[i+j],
+				&bprof->temp_mon_range[i],
+				sizeof(bprof->temp_mon_range[i]));
+		}
+	}
+
+	new_prof->temp_mon_ranges = i+j;
+	new_prof->temp_low_lim = bprof->temp_low_lim;
+
+	return;
+}
+
+
+static int pmic_check_initial_events(void)
+{
+	struct pmic_event *evt;
+	int ret;
+	u8 mask = (CHRGRIRQ1_SVBUSDET_MASK);
+
+	evt = kzalloc(sizeof(struct pmic_event), GFP_KERNEL);
+	if (evt == NULL) {
+		dev_dbg(chc.dev, "Error allocating evt structure in fn:%s\n",
+			__func__);
+		return -1;
+	}
+
+	ret = intel_scu_ipc_ioread8(SCHGRIRQ0_ADDR, &evt->chgrirq0_stat);
+	evt->chgrirq0_int = evt->chgrirq0_stat;
+	ret = intel_scu_ipc_ioread8(SCHGRIRQ1_ADDR, &evt->chgrirq1_stat);
+	evt->chgrirq1_int = evt->chgrirq1_stat;
+
+	if (evt->chgrirq1_stat || evt->chgrirq0_int) {
+		INIT_LIST_HEAD(&evt->node);
+		mutex_lock(&chc.evt_queue_lock);
+		list_add_tail(&evt->node, &chc.evt_queue);
+		mutex_unlock(&chc.evt_queue_lock);
+		schedule_work(&chc.evt_work);
+	}
+
+	pmic_bat_zone_changed();
+
+	return ret;
+}
+
+/**
+ * pmic_charger_probe - PMIC charger probe function
+ * @pdev: pmic platform device structure
+ * Context: can sleep
+ *
+ * pmic charger driver initializes its internal data
+ * structure and other  infrastructure components for it
+ * to work as expected.
+ */
+static int pmic_chrgr_probe(struct platform_device *pdev)
+{
+	int retval = 0;
+	u8 val;
+
+	if (!pdev)
+		return -ENODEV;
+
+	chc.health = POWER_SUPPLY_HEALTH_UNKNOWN;
+	chc.dev = &pdev->dev;
+	chc.irq = platform_get_irq(pdev, 0);
+	chc.pdata = pdev->dev.platform_data;
+	platform_set_drvdata(pdev, &chc);
+
+	if (chc.pdata == NULL) {
+		dev_err(chc.dev, "Platform data not initialized\n");
+		return -EFAULT;
+	}
+
+	retval = intel_scu_ipc_ioread8(PMIC_ID_ADDR, &chc.pmic_id);
+	if (retval) {
+		dev_err(chc.dev,
+			"Error reading PMIC ID register\n");
+		return retval;
+	}
+
+	dev_info(chc.dev, "PMIC-ID: %x\n", chc.pmic_id);
+	if ((chc.pmic_id & PMIC_VENDOR_ID_MASK) == SHADYCOVE_VENDORID) {
+		retval = pmic_read_reg(USBPATH_ADDR, &val);
+		if (retval) {
+			dev_err(chc.dev,
+				"Error reading CHGRSTATUS-register 0x%2x\n",
+				CHGRSTATUS_ADDR);
+			return retval;
+		}
+
+		if (val & USBPATH_USBSEL_MASK) {
+			dev_info(chc.dev, "SOC-Internal-USBPHY used\n");
+			chc.is_internal_usb_phy = true;
+		} else
+			dev_info(chc.dev, "External-USBPHY used\n");
+	}
+
+	chc.sfi_bcprof = kzalloc(sizeof(struct ps_batt_chg_prof),
+				GFP_KERNEL);
+	if (chc.sfi_bcprof == NULL) {
+		dev_err(chc.dev,
+			"Error allocating memeory SFI battery profile\n");
+		return -ENOMEM;
+	}
+
+	retval = get_batt_prop(chc.sfi_bcprof);
+	if (retval) {
+		dev_err(chc.dev,
+			"Error reading battery profile from battid frmwrk\n");
+		kfree(chc.sfi_bcprof);
+		chc.invalid_batt = true;
+		chc.sfi_bcprof = NULL;
+	}
+
+	retval = intel_scu_ipc_update_register(CHGRCTRL0_ADDR, SWCONTROL_ENABLE,
+			CHGRCTRL0_SWCONTROL_MASK);
+	if (retval)
+		dev_err(chc.dev, "Error enabling sw control. Charging may continue in h/w control mode\n");
+
+	if (!chc.invalid_batt) {
+		chc.actual_bcprof = kzalloc(sizeof(struct ps_pse_mod_prof),
+					GFP_KERNEL);
+		if (chc.actual_bcprof == NULL) {
+			dev_err(chc.dev,
+				"Error allocating mem for local battery profile\n");
+			kfree(chc.sfi_bcprof);
+			return -ENOMEM;
+		}
+
+		chc.runtime_bcprof = kzalloc(sizeof(struct ps_pse_mod_prof),
+					GFP_KERNEL);
+		if (chc.runtime_bcprof == NULL) {
+			dev_err(chc.dev,
+			"Error allocating mem for runtime batt profile\n");
+			kfree(chc.sfi_bcprof);
+			kfree(chc.actual_bcprof);
+			return -ENOMEM;
+		}
+
+		set_pmic_batt_prof(chc.actual_bcprof,
+				chc.sfi_bcprof->batt_prof);
+		print_ps_pse_mod_prof(chc.actual_bcprof);
+		retval = pmic_init();
+		if (retval)
+			dev_err(chc.dev, "Error in Initializing PMIC. Continue in h/w charging mode\n");
+
+		memcpy(chc.runtime_bcprof, chc.actual_bcprof,
+			sizeof(struct ps_pse_mod_prof));
+	}
+
+	chc.pmic_intr_iomap = ioremap_nocache(PMIC_SRAM_INTR_ADDR, 8);
+	if (!chc.pmic_intr_iomap) {
+		dev_err(&pdev->dev, "ioremap Failed\n");
+		retval = -ENOMEM;
+		goto ioremap_failed;
+	}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0))
+	chc.otg = usb_get_transceiver();
+#else
+	chc.otg = usb_get_phy(USB_PHY_TYPE_USB2);
+#endif
+	if (!chc.otg || IS_ERR(chc.otg)) {
+		dev_err(&pdev->dev, "Failed to get otg transceiver!!\n");
+		retval = -ENOMEM;
+		goto otg_req_failed;
+	}
+
+	INIT_WORK(&chc.evt_work, pmic_event_worker);
+	INIT_LIST_HEAD(&chc.evt_queue);
+	mutex_init(&chc.evt_queue_lock);
+
+	/* register interrupt */
+	retval = request_threaded_irq(chc.irq, pmic_isr,
+			pmic_thread_handler,
+			IRQF_SHARED|IRQF_NO_SUSPEND ,
+			DRIVER_NAME, &chc);
+	if (retval) {
+		dev_err(&pdev->dev,
+			"Error in request_threaded_irq(irq(%d)!!\n",
+			chc.irq);
+		goto otg_req_failed;
+	}
+
+	retval = pmic_check_initial_events();
+	if (unlikely(retval)) {
+		dev_err(&pdev->dev,
+			"Error posting initial events\n");
+		goto req_irq_failed;
+	}
+
+	/* unmask charger interrupts in second level IRQ register*/
+	retval = intel_scu_ipc_update_register(MCHGRIRQ0_ADDR, 0x00,
+			PMIC_CHRGR_INT0_MASK);
+	/* unmask charger interrupts in second level IRQ register*/
+	retval = intel_scu_ipc_iowrite8(MCHGRIRQ1_ADDR, 0x00);
+	if (unlikely(retval))
+		goto unmask_irq_failed;
+
+
+	/* unmask IRQLVL1 register */
+	retval = intel_scu_ipc_update_register(IRQLVL1_MASK_ADDR, 0x00,
+			IRQLVL1_CHRGR_MASK);
+	if (unlikely(retval))
+		goto unmask_irq_failed;
+
+	retval = intel_scu_ipc_update_register(USBIDCTRL_ADDR,
+			 ACADETEN_MASK | USBIDEN_MASK,
+			ACADETEN_MASK | USBIDEN_MASK);
+	if (unlikely(retval))
+		goto unmask_irq_failed;
+
+	chc.health = POWER_SUPPLY_HEALTH_GOOD;
+#ifdef CONFIG_DEBUG_FS
+	pmic_debugfs_init();
+#endif
+	return 0;
+
+unmask_irq_failed:
+req_irq_failed:
+	free_irq(chc.irq, &chc);
+otg_req_failed:
+	iounmap(chc.pmic_intr_iomap);
+ioremap_failed:
+	kfree(chc.sfi_bcprof);
+	kfree(chc.actual_bcprof);
+	kfree(chc.runtime_bcprof);
+	return retval;
+}
+
+static void pmic_chrgr_do_exit_ops(struct pmic_chrgr_drv_context *chc)
+{
+	/*TODO:
+	 * If charger is connected send IPC message to SCU to continue charging
+	 */
+#ifdef CONFIG_DEBUG_FS
+	pmic_debugfs_exit();
+#endif
+}
+
+/**
+ * pmic_charger_remove - PMIC Charger driver remove
+ * @pdev: PMIC charger platform device structure
+ * Context: can sleep
+ *
+ * PMIC charger finalizes its internal data structure and other
+ * infrastructure components that it initialized in
+ * pmic_chrgr_probe.
+ */
+static int pmic_chrgr_remove(struct platform_device *pdev)
+{
+	struct pmic_chrgr_drv_context *chc = platform_get_drvdata(pdev);
+
+	if (chc) {
+		pmic_chrgr_do_exit_ops(chc);
+		free_irq(chc->irq, chc);
+		iounmap(chc->pmic_intr_iomap);
+		kfree(chc->sfi_bcprof);
+		kfree(chc->actual_bcprof);
+		kfree(chc->runtime_bcprof);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pmic_chrgr_suspend(struct device *dev)
+{
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int pmic_chrgr_resume(struct device *dev)
+{
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int pmic_chrgr_runtime_suspend(struct device *dev)
+{
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int pmic_chrgr_runtime_resume(struct device *dev)
+{
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int pmic_chrgr_runtime_idle(struct device *dev)
+{
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+#endif
+
+/*********************************************************************
+ *		Driver initialisation and finalization
+ *********************************************************************/
+
+static const struct dev_pm_ops pmic_chrgr_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pmic_chrgr_suspend,
+				pmic_chrgr_resume)
+	SET_RUNTIME_PM_OPS(pmic_chrgr_runtime_suspend,
+				pmic_chrgr_runtime_resume,
+				pmic_chrgr_runtime_idle)
+};
+
+static struct platform_driver pmic_chrgr_driver = {
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   .pm = &pmic_chrgr_pm_ops,
+		   },
+	.probe = pmic_chrgr_probe,
+	.remove = pmic_chrgr_remove,
+};
+
+static int pmic_chrgr_init(void)
+{
+	return platform_driver_register(&pmic_chrgr_driver);
+}
+
+static void pmic_chrgr_exit(void)
+{
+	platform_driver_unregister(&pmic_chrgr_driver);
+}
+
+static int pmic_ccsm_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed pmic_ccsm rpmsg device\n");
+
+	ret = pmic_chrgr_init();
+
+out:
+	return ret;
+}
+
+static void pmic_ccsm_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	pmic_chrgr_exit();
+	dev_info(&rpdev->dev, "Removed pmic_ccsm rpmsg device\n");
+}
+
+static void pmic_ccsm_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+					int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+		       data, len,  true);
+}
+
+static struct rpmsg_device_id pmic_ccsm_rpmsg_id_table[] = {
+	{ .name	= "rpmsg_pmic_ccsm" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, pmic_ccsm_rpmsg_id_table);
+
+static struct rpmsg_driver pmic_ccsm_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= pmic_ccsm_rpmsg_id_table,
+	.probe		= pmic_ccsm_rpmsg_probe,
+	.callback	= pmic_ccsm_rpmsg_cb,
+	.remove		= pmic_ccsm_rpmsg_remove,
+};
+
+static int __init pmic_ccsm_rpmsg_init(void)
+{
+	return register_rpmsg_driver(&pmic_ccsm_rpmsg);
+}
+
+static void __exit pmic_ccsm_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&pmic_ccsm_rpmsg);
+}
+/* Defer init call so that dependant drivers will be loaded. Using  async
+ * for parallel driver initialization */
+late_initcall(pmic_ccsm_rpmsg_init);
+module_exit(pmic_ccsm_rpmsg_exit);
+
+MODULE_AUTHOR("Jenny TC <jenny.tc@intel.com>");
+MODULE_DESCRIPTION("PMIC Charger  Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/pmic_ccsm.h b/drivers/power/pmic_ccsm.h
new file mode 100644
index 000000000000..7619389ec1dd
--- /dev/null
+++ b/drivers/power/pmic_ccsm.h
@@ -0,0 +1,356 @@
+/*
+ * pmic_ccsm.h - Intel MID PMIC CCSM Driver header file
+ *
+ * Copyright (C) 2011 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Jenny TC <jenny.tc@intel.com>
+ */
+
+#ifndef __PMIC_CCSM_H__
+#define __PMIC_CCSM_H__
+
+#include <asm/pmic_pdata.h>
+/*********************************************************************
+ *		Generic defines
+ *********************************************************************/
+
+#define D7 (1 << 7)
+#define D6 (1 << 6)
+#define D5 (1 << 5)
+#define D4 (1 << 4)
+#define D3 (1 << 3)
+#define D2 (1 << 2)
+#define D1 (1 << 1)
+#define D0 (1 << 0)
+
+#define PMIC_ID_ADDR	0x00
+
+#define PMIC_VENDOR_ID_MASK	(0x03 << 6)
+#define PMIC_MINOR_REV_MASK	0x07
+#define PMIC_MAJOR_REV_MASK	(0x07 << 3)
+
+#define BASINCOVE_VENDORID	(0x03 << 6)
+#define SHADYCOVE_VENDORID	0x00
+
+#define BC_PMIC_MAJOR_REV_A0	0x00
+#define BC_PMIC_MAJOR_REV_B0	(0x01 << 3)
+
+#define PMIC_BZONE_LOW 0
+#define PMIC_BZONE_HIGH 5
+
+#define IRQLVL1_ADDR			0x01
+#define IRQLVL1_MASK_ADDR		0x0c
+#define IRQLVL1_CHRGR_MASK		D5
+
+#define THRMZN0H_ADDR_BC		0xCE
+#define THRMZN0L_ADDR_BC		0xCF
+#define THRMZN1H_ADDR_BC		0xD0
+#define THRMZN1L_ADDR_BC		0xD1
+#define THRMZN2H_ADDR_BC		0xD2
+#define THRMZN2L_ADDR_BC		0xD3
+#define THRMZN3H_ADDR_BC		0xD4
+#define THRMZN3L_ADDR_BC		0xD5
+#define THRMZN4H_ADDR_BC		0xD6
+#define THRMZN4L_ADDR_BC		0xD7
+
+#define THRMZN0H_ADDR_SC		0xD7
+#define THRMZN0L_ADDR_SC		0xD8
+#define THRMZN1H_ADDR_SC		0xD9
+#define THRMZN1L_ADDR_SC		0xDA
+#define THRMZN2H_ADDR_SC		0xDD
+#define THRMZN2L_ADDR_SC		0xDE
+#define THRMZN3H_ADDR_SC		0xDF
+#define THRMZN3L_ADDR_SC		0xE0
+#define THRMZN4H_ADDR_SC		0xE1
+#define THRMZN4L_ADDR_SC		0xE2
+
+#define CHGRIRQ0_ADDR			0x07
+#define CHGIRQ0_BZIRQ_MASK		D7
+#define CHGIRQ0_BAT_CRIT_MASK		D6
+#define CHGIRQ0_BAT1_ALRT_MASK		D5
+#define CHGIRQ0_BAT0_ALRT_MASK		D4
+
+#define MCHGRIRQ0_ADDR			0x12
+#define MCHGIRQ0_RSVD_MASK		D7
+#define MCHGIRQ0_MBAT_CRIT_MASK		D6
+#define MCHGIRQ0_MBAT1_ALRT_MASK	D5
+#define MCHGIRQ0_MBAT0_ALRT_MASK	D4
+
+#define SCHGRIRQ0_ADDR			0x4E
+#define SCHGIRQ0_RSVD_MASK		D7
+#define SCHGIRQ0_SBAT_CRIT_MASK		D6
+#define SCHGIRQ0_SBAT1_ALRT_MASK	D5
+#define SCHGIRQ0_SBAT0_ALRT_MASK	D4
+
+#define LOWBATTDET0_ADDR		0x2C
+#define LOWBATTDET1_ADDR		0x2D
+#define BATTDETCTRL_ADDR		0x2E
+#define VBUSDETCTRL_ADDR		0x50
+#define VDCINDETCTRL_ADDR		0x51
+
+#define CHRGRIRQ1_ADDR			0x08
+#define CHRGRIRQ1_SUSBIDDET_MASK	D3
+#define CHRGRIRQ1_SBATTDET_MASK		D2
+#define CHRGRIRQ1_SDCDET_MASK		D1
+#define CHRGRIRQ1_SVBUSDET_MASK		D0
+#define MCHGRIRQ1_ADDR			0x13
+#define MCHRGRIRQ1_SUSBIDDET_MASK	D3
+#define MCHRGRIRQ1_SBATTDET_MAS		D2
+#define MCHRGRIRQ1_SDCDET_MASK		D1
+#define MCHRGRIRQ1_SVBUSDET_MASK	D0
+#define SCHGRIRQ1_ADDR			0x4F
+#define SCHRGRIRQ1_SUSBIDDET_MASK	D3
+#define SCHRGRIRQ1_SBATTDET_MASK	D2
+#define SCHRGRIRQ1_SDCDET_MASK		D1
+#define SCHRGRIRQ1_SVBUSDET_MASK	D0
+
+#define PMIC_CHRGR_INT0_MASK		0xB1
+#define PMIC_CHRGR_CCSM_INT0_MASK	0xB0
+#define PMIC_CHRGR_EXT_CHRGR_INT_MASK	0x01
+
+#define CHGRCTRL0_ADDR			0x4B
+#define CHGRCTRL0_WDT_NOKICK_MASK	D7
+#define CHGRCTRL0_DBPOFF_MASK		D6
+#define CHGRCTRL0_CCSM_OFF_MASK		D5
+#define CHGRCTRL0_TTLCK_MASK		D4
+#define CHGRCTRL0_SWCONTROL_MASK	D3
+#define CHGRCTRL0_EXTCHRDIS_MASK	D2
+#define	CHRCTRL0_EMRGCHREN_MASK		D1
+#define	CHRCTRL0_CHGRRESET_MASK		D0
+
+#define WDT_NOKICK_ENABLE		(0x01 << 7)
+#define WDT_NOKICK_DISABLE		(~WDT_NOKICK_ENABLE & 0xFF)
+
+#define EXTCHRDIS_ENABLE		(0x01 << 2)
+#define EXTCHRDIS_DISABLE		(~EXTCHRDIS_ENABLE & 0xFF)
+#define SWCONTROL_ENABLE		(0x01 << 3)
+#define EMRGCHREN_ENABLE		(0x01 << 1)
+
+#define CHGRCTRL1_ADDR			0x4C
+#define CHGRCTRL1_DBPEN_MASK		D7
+#define CHGRCTRL1_OTGMODE_MASK		D6
+#define CHGRCTRL1_FTEMP_EVENT_MASK	D5
+#define CHGRCTRL1_FUSB_INLMT_1500	D4
+#define CHGRCTRL1_FUSB_INLMT_900	D3
+#define CHGRCTRL1_FUSB_INLMT_500	D2
+#define CHGRCTRL1_FUSB_INLMT_150	D1
+#define CHGRCTRL1_FUSB_INLMT_100	D0
+
+#define CHGRSTATUS_ADDR			0x4D
+#define CHGRSTATUS_RSVD_MASK		(D7|D6|D5|D3)
+#define CHGRSTATUS_SDPB_MASK		D4
+#define CHGRSTATUS_CHGDISLVL_MASK	D2
+#define CHGRSTATUS_CHGDETB_LATCH_MASK	D1
+#define CHGDETB_MASK			D0
+
+#define THRMBATZONE_ADDR_BC		0xB5
+#define THRMBATZONE_ADDR_SC		0xB6
+#define THRMBATZONE_MASK		(D0|D1|D2)
+
+#define USBIDCTRL_ADDR		0x19
+#define USBIDEN_MASK		0x01
+#define ACADETEN_MASK		(0x01 << 1)
+
+#define USBIDSTAT_ADDR		0x1A
+#define ID_SHORT		D4
+#define ID_SHORT_VBUS		(1 << 4)
+#define ID_NOT_SHORT_VBUS	0
+#define ID_FLOAT_STS		D3
+#define R_ID_FLOAT_DETECT	(1 << 3)
+#define R_ID_FLOAT_NOT_DETECT	0
+#define ID_RAR_BRC_STS		((D2 | D1))
+#define ID_ACA_NOT_DETECTED	0
+#define R_ID_A			(1 << 1)
+#define R_ID_B			(2 << 1)
+#define R_ID_C			(3 << 1)
+#define ID_GND			D0
+#define ID_TYPE_A		0
+#define ID_TYPE_B		1
+#define is_aca(x) ((x & R_ID_A) || (x & R_ID_B) || (x & R_ID_C))
+
+#define WAKESRC_ADDR		0x24
+
+#define CHRTTADDR_ADDR		0x56
+#define CHRTTDATA_ADDR		0x57
+
+#define USBSRCDET_RETRY_CNT		4
+#define USBSRCDET_SLEEP_TIME		200
+#define USBSRCDETSTATUS_ADDR		0x5D
+#define USBSRCDET_SUSBHWDET_MASK	(D0|D1)
+#define USBSRCDET_USBSRCRSLT_MASK	(D2|D3|D4|D5)
+#define USBSRCDET_SDCD_MASK		(D6|D7)
+#define USBSRCDET_SUSBHWDET_DETON	(0x01 << 0)
+#define USBSRCDET_SUSBHWDET_DETSUCC	(0x01 << 1)
+#define USBSRCDET_SUSBHWDET_DETFAIL	(0x03 << 0)
+
+/* Register on I2C-dev2-0x6E */
+#define USBPATH_ADDR		0x011C
+#define USBPATH_USBSEL_MASK	D3
+
+#define TT_I2CDADDR_ADDR		0x00
+#define TT_CHGRINIT0OS_ADDR		0x01
+#define TT_CHGRINIT1OS_ADDR		0x02
+#define TT_CHGRINIT2OS_ADDR		0x03
+#define TT_CHGRINIT3OS_ADDR		0x04
+#define TT_CHGRINIT4OS_ADDR		0x05
+#define TT_CHGRINIT5OS_ADDR		0x06
+#define TT_CHGRINIT6OS_ADDR		0x07
+#define TT_CHGRINIT7OS_ADDR		0x08
+#define TT_USBINPUTICCOS_ADDR		0x09
+#define TT_USBINPUTICCMASK_ADDR		0x0A
+#define TT_CHRCVOS_ADDR			0X0B
+#define TT_CHRCVMASK_ADDR		0X0C
+#define TT_CHRCCOS_ADDR			0X0D
+#define TT_CHRCCMASK_ADDR		0X0E
+#define TT_LOWCHROS_ADDR		0X0F
+#define TT_LOWCHRMASK_ADDR		0X10
+#define TT_WDOGRSTOS_ADDR		0X11
+#define TT_WDOGRSTMASK_ADDR		0X12
+#define TT_CHGRENOS_ADDR		0X13
+#define TT_CHGRENMASK_ADDR		0X14
+
+#define TT_CUSTOMFIELDEN_ADDR		0X15
+#define TT_HOT_LC_EN			D1
+#define TT_COLD_LC_EN			D0
+#define TT_HOT_COLD_LC_MASK		(TT_HOT_LC_EN | TT_COLD_LC_EN)
+#define TT_HOT_COLD_LC_EN		(TT_HOT_LC_EN | TT_COLD_LC_EN)
+#define TT_HOT_COLD_LC_DIS		0
+
+#define TT_CHGRINIT0VAL_ADDR		0X20
+#define TT_CHGRINIT1VAL_ADDR		0X21
+#define TT_CHGRINIT2VAL_ADDR		0X22
+#define TT_CHGRINIT3VAL_ADDR		0X23
+#define TT_CHGRINIT4VAL_ADDR		0X24
+#define TT_CHGRINIT5VAL_ADDR		0X25
+#define TT_CHGRINIT6VAL_ADDR		0X26
+#define TT_CHGRINIT7VAL_ADDR		0X27
+#define TT_USBINPUTICC100VAL_ADDR	0X28
+#define TT_USBINPUTICC150VAL_ADDR	0X29
+#define TT_USBINPUTICC500VAL_ADDR	0X2A
+#define TT_USBINPUTICC900VAL_ADDR	0X2B
+#define TT_USBINPUTICC1500VAL_ADDR	0X2C
+#define TT_CHRCVEMRGLOWVAL_ADDR		0X2D
+#define TT_CHRCVCOLDVAL_ADDR		0X2E
+#define TT_CHRCVCOOLVAL_ADDR		0X2F
+#define TT_CHRCVWARMVAL_ADDR		0X30
+#define TT_CHRCVHOTVAL_ADDR		0X31
+#define TT_CHRCVEMRGHIVAL_ADDR		0X32
+#define TT_CHRCCEMRGLOWVAL_ADDR		0X33
+#define TT_CHRCCCOLDVAL_ADDR		0X34
+#define TT_CHRCCCOOLVAL_ADDR		0X35
+#define TT_CHRCCWARMVAL_ADDR		0X36
+#define TT_CHRCCHOTVAL_ADDR		0X37
+#define TT_CHRCCEMRGHIVAL_ADDR		0X38
+#define TT_LOWCHRENVAL_ADDR		0X39
+#define TT_LOWCHRDISVAL_ADDR		0X3A
+#define TT_WDOGRSTVAL_ADDR		0X3B
+#define TT_CHGRENVAL_ADDR		0X3C
+#define TT_CHGRDISVAL_ADDR		0X3D
+
+/*Interrupt registers*/
+#define BATT_CHR_BATTDET_MASK	D2
+/*Status registers*/
+#define BATT_PRESENT		1
+#define BATT_NOT_PRESENT	0
+
+#define BATT_STRING_MAX		8
+#define BATTID_STR_LEN		8
+
+#define CHARGER_PRESENT		1
+#define CHARGER_NOT_PRESENT	0
+
+/*FIXME: Modify default values */
+#define BATT_DEAD_CUTOFF_VOLT		3400	/* 3400 mV */
+#define BATT_CRIT_CUTOFF_VOLT		3700	/* 3700 mV */
+
+#define MSIC_BATT_TEMP_MAX		60	/* 60 degrees */
+#define MSIC_BATT_TEMP_MIN		0
+
+#define BATT_TEMP_WARM			45	/* 45 degrees */
+#define MIN_BATT_PROF			4
+
+#define PMIC_REG_NAME_LEN		28
+#define PMIC_REG_DEF(x) { .reg_name = #x, .addr = x }
+
+struct interrupt_info {
+	/* Interrupt register mask*/
+	u8 int_reg_mask;
+	/* interrupt status register mask */
+	u8 stat_reg_mask;
+	/* log message if interrupt is set */
+	char *log_msg_int_reg_true;
+	/* log message if stat is true or false */
+	char *log_msg_stat_true;
+	char *log_msg_stat_false;
+	/* handle if interrupt bit is set */
+	void (*int_handle) (void);
+	/* interrupt status handler */
+	void (*stat_handle) (bool);
+};
+
+enum pmic_charger_cable_type {
+	PMIC_CHARGER_TYPE_NONE = 0,
+	PMIC_CHARGER_TYPE_SDP,
+	PMIC_CHARGER_TYPE_DCP,
+	PMIC_CHARGER_TYPE_CDP,
+	PMIC_CHARGER_TYPE_ACA,
+	PMIC_CHARGER_TYPE_SE1,
+	PMIC_CHARGER_TYPE_MHL,
+	PMIC_CHARGER_TYPE_FLOAT_DP_DN,
+	PMIC_CHARGER_TYPE_OTHER,
+	PMIC_CHARGER_TYPE_DCP_EXTPHY,
+};
+
+struct pmic_chrgr_drv_context {
+	bool invalid_batt;
+	bool is_batt_present;
+	bool current_sense_enabled;
+	unsigned int irq;		/* GPE_ID or IRQ# */
+	void __iomem *pmic_intr_iomap;
+	struct device *dev;
+	int health;
+	u8 pmic_id;
+	bool is_internal_usb_phy;
+	enum pmic_charger_cable_type charger_type;
+	/* ShadyCove-WA for VBUS removal detect issue */
+	bool vbus_connect_status;
+	struct ps_batt_chg_prof *sfi_bcprof;
+	struct ps_pse_mod_prof *actual_bcprof;
+	struct ps_pse_mod_prof *runtime_bcprof;
+	struct pmic_platform_data *pdata;
+	struct usb_phy *otg;
+	struct list_head evt_queue;
+	struct work_struct evt_work;
+	struct mutex evt_queue_lock;
+};
+
+struct pmic_event {
+	struct list_head node;
+	u8 chgrirq0_int;
+	u8 chgrirq1_int;
+	u8 chgrirq0_stat;
+	u8 chgrirq1_stat;
+};
+
+struct pmic_regs_def {
+	char reg_name[PMIC_REG_NAME_LEN];
+	u16 addr;
+};
+
+#endif
diff --git a/drivers/rpmsg/virtio_rpmsg_bus.c b/drivers/rpmsg/virtio_rpmsg_bus.c
index b6135d4d54eb..a9ad4a7608c0 100644
--- a/drivers/rpmsg/virtio_rpmsg_bus.c
+++ b/drivers/rpmsg/virtio_rpmsg_bus.c
@@ -749,9 +749,9 @@ int rpmsg_send_offchannel_raw(struct rpmsg_channel *rpdev, u32 src, u32 dst,
 	dev_dbg(dev, "TX From 0x%x, To 0x%x, Len %d, Flags %d, Reserved %d\n",
 					msg->src, msg->dst, msg->len,
 					msg->flags, msg->reserved);
-	print_hex_dump(KERN_DEBUG, "rpmsg_virtio TX: ", DUMP_PREFIX_NONE, 16, 1,
+/*	print_hex_dump(KERN_DEBUG, "rpmsg_virtio TX: ", DUMP_PREFIX_NONE, 16, 1,
 					msg, sizeof(*msg) + msg->len, true);
-
+*/
 	sg_init_one(&sg, msg, sizeof(*msg) + len);
 
 	mutex_lock(&vrp->tx_lock);
@@ -786,9 +786,9 @@ static int rpmsg_recv_single(struct virtproc_info *vrp, struct device *dev,
 	dev_dbg(dev, "From: 0x%x, To: 0x%x, Len: %d, Flags: %d, Reserved: %d\n",
 					msg->src, msg->dst, msg->len,
 					msg->flags, msg->reserved);
-	print_hex_dump(KERN_DEBUG, "rpmsg_virtio RX: ", DUMP_PREFIX_NONE, 16, 1,
+/*	print_hex_dump(KERN_DEBUG, "rpmsg_virtio RX: ", DUMP_PREFIX_NONE, 16, 1,
 					msg, sizeof(*msg) + msg->len, true);
-
+*/
 	/*
 	 * We currently use fixed-sized buffers, so trivially sanitize
 	 * the reported payload length.
@@ -898,10 +898,10 @@ static void rpmsg_ns_cb(struct rpmsg_channel *rpdev, void *data, int len,
 	struct device *dev = &vrp->vdev->dev;
 	int ret;
 
-	print_hex_dump(KERN_DEBUG, "NS announcement: ",
+/*	print_hex_dump(KERN_DEBUG, "NS announcement: ",
 			DUMP_PREFIX_NONE, 16, 1,
 			data, len, true);
-
+*/
 	if (len != sizeof(*msg)) {
 		dev_err(dev, "malformed ns msg (%d)\n", len);
 		return;
diff --git a/include/linux/power/battery_id.h b/include/linux/power/battery_id.h
index 81028fae6300..417160d9d7fc 100644
--- a/include/linux/power/battery_id.h
+++ b/include/linux/power/battery_id.h
@@ -47,7 +47,7 @@ struct ps_pse_mod_prof {
 	u16 capacity;
 	u16 voltage_max;
 	/* charge termination current */
-	u16 chrg_term_mA;
+	u16 chrg_term_ma;
 	/* Low battery level voltage */
 	u16 low_batt_mV;
 	/* upper and lower temperature limits on discharging */
diff --git a/include/linux/power/bq24261_charger.h b/include/linux/power/bq24261_charger.h
new file mode 100644
index 000000000000..f1856593fa15
--- /dev/null
+++ b/include/linux/power/bq24261_charger.h
@@ -0,0 +1,56 @@
+/*
+ * bq24261_charger.h: platform data structure for bq24261 driver
+ *
+ * (C) Copyright 2012 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#ifndef __BQ24261_CHARGER_H__
+#define __BQ24261_CHARGER_H__
+
+struct bq24261_plat_data {
+	u32 irq_map;
+	u8 irq_mask;
+	char **supplied_to;
+	size_t num_supplicants;
+	struct power_supply_throttle *throttle_states;
+	size_t num_throttle_states;
+	int safety_timer;
+	int boost_mode_ma;
+	bool is_ts_enabled;
+
+	int (*enable_charging) (bool val);
+	int (*enable_charger) (bool val);
+	int (*set_inlmt) (int val);
+	int (*set_cc) (int val);
+	int (*set_cv) (int val);
+	int (*set_iterm) (int val);
+	int (*enable_vbus) (bool val);
+	/* WA for ShadyCove VBUS removal detect issue */
+	int (*handle_low_supply) (void);
+	void (*dump_master_regs) (void);
+};
+
+extern void bq24261_cv_to_reg(int, u8*);
+extern void bq24261_cc_to_reg(int, u8*);
+extern void bq24261_inlmt_to_reg(int, u8*);
+
+#ifdef CONFIG_BQ24261_CHARGER
+extern int bq24261_get_bat_health(void);
+extern int bq24261_get_bat_status(void);
+#else
+static int bq24261_get_bat_health(void)
+{
+	return 0;
+}
+static int bq24261_get_bat_status(void)
+{
+	return 0;
+}
+#endif
+
+#endif
diff --git a/include/linux/power_supply.h b/include/linux/power_supply.h
index 653f45619025..28b401eb9d11 100644
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@ -213,7 +213,7 @@ enum power_supply_charger_cable_type {
 struct power_supply_cable_props {
 	enum power_supply_charger_event	chrg_evt;
 	enum power_supply_charger_cable_type chrg_type;
-	unsigned int mA;   /* input current limit */
+	unsigned int ma;   /* input current limit */
 };
 
 #define POWER_SUPPLY_CHARGER_TYPE_USB \
-- 
2.37.3

