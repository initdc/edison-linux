From 8800e9eb9570ea54c18ca28fabed6a83b3c9a2a1 Mon Sep 17 00:00:00 2001
From: Eric Ernst <eric.ernst@intel.com>
Date: Thu, 18 Jul 2013 13:58:10 -0700
Subject: [PATCH 154/429] SPID: Pull SPID out of intel_mid

Remove SPID logic out of intel_mid code.  Tested working for SFI based
platform (RHB), and ACPI platform (baytrail)

Signed-off-by: Eric Ernst <eric.ernst@intel.com>
---
 arch/x86/include/asm/intel-mid.h            |  11 +-
 arch/x86/include/asm/spid.h                 |  24 +-
 arch/x86/platform/intel-mid/Makefile        |   3 +
 arch/x86/platform/intel-mid/intel_mid_sfi.c | 167 +---------
 arch/x86/platform/intel-mid/spid.c          | 321 ++++++++++++++++++++
 include/linux/intel_pidv_acpi.h             |  54 ++++
 6 files changed, 409 insertions(+), 171 deletions(-)
 create mode 100644 arch/x86/platform/intel-mid/spid.c
 create mode 100644 include/linux/intel_pidv_acpi.h

diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h
index 4737938d9af6..3d910b4b640b 100644
--- a/arch/x86/include/asm/intel-mid.h
+++ b/arch/x86/include/asm/intel-mid.h
@@ -54,7 +54,7 @@ struct sfi_table_oemb {
 	u8 ifwi_major_version;
 	u8 ifwi_minor_version;
 	struct soft_platform_id spid;
-	u8 ssn[INTEL_MID_SSN_SIZE];
+	u8 ssn[INTEL_PLATFORM_SSN_SIZE];
 } __packed;
 
 /*
@@ -157,15 +157,6 @@ enum intel_mid_timer_options {
 
 extern enum intel_mid_timer_options intel_mid_timer_options;
 
-#define spid_attr(_name) \
-static struct kobj_attribute _name##_attr = { \
-	.attr = {                             \
-		.name = __stringify(_name),   \
-		.mode = 0444,                 \
-	},                                    \
-	.show   = _name##_show,               \
-}
-
 /*
  * Penwell uses spread spectrum clock, so the freq number is not exactly
  * the same as reported by MSR based on SDM.
diff --git a/arch/x86/include/asm/spid.h b/arch/x86/include/asm/spid.h
index 900edf8d559d..11c667313d72 100644
--- a/arch/x86/include/asm/spid.h
+++ b/arch/x86/include/asm/spid.h
@@ -1,5 +1,5 @@
 /*
- * spid.h: Intel MID software platform ID definitions
+ * spid.h: Intel software platform ID definitions
  *
  * (C) Copyright 2012 Intel Corporation
  *
@@ -11,6 +11,28 @@
 #ifndef _ASM_X86_SPID_H
 #define _ASM_X86_SPID_H
 
+#include <linux/sfi.h>
+/* size of SPID cmdline : androidboot.spid=vend:cust:manu:plat:prod:hard */
+#define SPID_CMDLINE_SIZE 46
+#define SPID_PARAM_NAME "androidboot.spid="
+#define SPID_DEFAULT_VALUE "xxxx:xxxx:xxxx:xxxx:xxxx:xxxx"
+
+#define spid_attr(_name) \
+static struct kobj_attribute _name##_attr = { \
+	.attr = {                             \
+		.name = __stringify(_name),   \
+		.mode = 0444,                 \
+	},                                    \
+	.show   = _name##_show,               \
+}
+
+
+#define INTEL_PLATFORM_SSN_SIZE	32
+extern struct soft_platform_id spid;
+extern char intel_platform_ssn[INTEL_PLATFORM_SSN_SIZE + 1];
+
+int __init sfi_handle_spid(struct sfi_table_header *table);
+
 struct soft_platform_id {
 	u16 customer_id; /*Defines the final customer for the product */
 	u16 vendor_id; /* Defines who owns the final product delivery */
diff --git a/arch/x86/platform/intel-mid/Makefile b/arch/x86/platform/intel-mid/Makefile
index 0584d0cb6892..70cb81f80927 100644
--- a/arch/x86/platform/intel-mid/Makefile
+++ b/arch/x86/platform/intel-mid/Makefile
@@ -2,6 +2,9 @@ obj-$(CONFIG_X86_INTEL_MID) += intel-mid.o
 obj-$(CONFIG_X86_INTEL_MID)	+= intel_mid_vrtc.o
 obj-$(CONFIG_EARLY_PRINTK_INTEL_MID)	+= early_printk_intel_mid.o
 
+# SPID code
+obj-y += spid.o
+
 # SFI specific code
 obj-$(CONFIG_SFI) += intel_mid_sfi.o
 
diff --git a/arch/x86/platform/intel-mid/intel_mid_sfi.c b/arch/x86/platform/intel-mid/intel_mid_sfi.c
index d34b21062a27..4073657f273a 100644
--- a/arch/x86/platform/intel-mid/intel_mid_sfi.c
+++ b/arch/x86/platform/intel-mid/intel_mid_sfi.c
@@ -43,6 +43,7 @@
 #include <asm/apb_timer.h>
 #include <asm/reboot.h>
 #include "intel_mid_weak_decls.h"
+#include <asm/spid.h>
 
 #define	SFI_SIG_OEM0	"OEM0"
 #define MAX_IPCDEVS	24
@@ -62,9 +63,6 @@ static int gpio_num_entry;
 static u32 sfi_mtimer_usage[SFI_MTMR_MAX_NUM];
 int sfi_mrtc_num;
 int sfi_mtimer_num;
-struct kobject *spid_kobj;
-struct soft_platform_id spid;
-char intel_mid_ssn[INTEL_MID_SSN_SIZE + 1];
 
 struct sfi_rtc_table_entry sfi_mrtc_array[SFI_MRTC_MAX];
 EXPORT_SYMBOL_GPL(sfi_mrtc_array);
@@ -532,6 +530,9 @@ static int __init sfi_parse_oemb(struct sfi_table_header *table)
 	u8 oem_id[SFI_OEM_ID_SIZE + 1] = {'\0'};
 	u8 oem_table_id[SFI_OEM_TABLE_ID_SIZE + 1] = {'\0'};
 
+	/* parse SPID and SSN out from OEMB table */
+	sfi_handle_spid(table);
+
 	oemb = (struct sfi_table_oemb *) table;
 	if (!oemb) {
 		pr_err("%s: fail to read SFI OEMB Layout\n",
@@ -541,17 +542,6 @@ static int __init sfi_parse_oemb(struct sfi_table_header *table)
 
 	board_id = oemb->board_id | (oemb->board_fab << 4);
 
-	memcpy(&spid, &oemb->spid, sizeof(struct soft_platform_id));
-
-	if (oemb->header.len <
-			(char *)oemb->ssn + INTEL_MID_SSN_SIZE - (char *)oemb) {
-		pr_err("SFI OEMB does not contains SSN\n");
-		intel_mid_ssn[0] = '\0';
-	} else {
-		memcpy(intel_mid_ssn, oemb->ssn, INTEL_MID_SSN_SIZE);
-		intel_mid_ssn[INTEL_MID_SSN_SIZE] = '\0';
-	}
-
 	snprintf(sig, (SFI_SIGNATURE_SIZE + 1), "%s", oemb->header.sig);
 	snprintf(oem_id, (SFI_OEM_ID_SIZE + 1), "%s", oemb->header.oem_id);
 	snprintf(oem_table_id, (SFI_OEM_TABLE_ID_SIZE + 1), "%s",
@@ -568,16 +558,7 @@ static int __init sfi_parse_oemb(struct sfi_table_header *table)
 		"\tOEMB val_hooks version       : %03d.%03d\n"
 		"\tOEMB ia suppfw version       : %03d.%03d\n"
 		"\tOEMB scu runtime version     : %03d.%03d\n"
-		"\tOEMB ifwi version            : %03d.%03d\n"
-		"\tOEMB spid customer id        : %04x\n"
-		"\tOEMB spid vendor id          : %04x\n"
-		"\tOEMB spid manufacturer id    : %04x\n"
-		"\tOEMB spid platform family id : %04x\n"
-		"\tOEMB spid product line id    : %04x\n"
-		"\tOEMB spid hardware id        : %04x\n"
-		"\tOEMB spid fru[4..0]          : %02x %02x %02x %02x %02x\n"
-		"\tOEMB spid fru[9..5]          : %02x %02x %02x %02x %02x\n"
-		"\tOEMB ssn                     : %s\n",
+		"\tOEMB ifwi version            : %03d.%03d\n",
 		sig,
 		oemb->header.len,
 		oemb->header.rev,
@@ -594,152 +575,18 @@ static int __init sfi_parse_oemb(struct sfi_table_header *table)
 		oemb->scu_runtime_major_version,
 		oemb->scu_runtime_minor_version,
 		oemb->ifwi_major_version,
-		oemb->ifwi_minor_version,
-		spid.customer_id,
-		spid.vendor_id,
-		spid.manufacturer_id,
-		spid.platform_family_id,
-		spid.product_line_id,
-		spid.hardware_id,
-		spid.fru[4], spid.fru[3], spid.fru[2], spid.fru[1],
-		spid.fru[0], spid.fru[9], spid.fru[8], spid.fru[7],
-		spid.fru[6], spid.fru[5],
-		intel_mid_ssn);
+		oemb->ifwi_minor_version
+		);
 	return 0;
 }
 
-static ssize_t customer_id_show(struct kobject *kobj,
-				struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%04x\n", spid.customer_id);
-}
-spid_attr(customer_id);
-
-static ssize_t vendor_id_show(struct kobject *kobj, struct kobj_attribute *attr,
-			      char *buf)
-{
-	return sprintf(buf, "%04x\n", spid.vendor_id);
-}
-spid_attr(vendor_id);
-
-static ssize_t manufacturer_id_show(struct kobject *kobj,
-				    struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%04x\n", spid.manufacturer_id);
-}
-spid_attr(manufacturer_id);
-
-static ssize_t platform_family_id_show(struct kobject *kobj,
-				       struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%04x\n", spid.platform_family_id);
-}
-spid_attr(platform_family_id);
-
-static ssize_t product_line_id_show(struct kobject *kobj,
-				    struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%04x\n", spid.product_line_id);
-}
-spid_attr(product_line_id);
-
-static ssize_t hardware_id_show(struct kobject *kobj,
-				struct kobj_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%04x\n", spid.hardware_id);
-}
-spid_attr(hardware_id);
-
-static ssize_t fru_show(struct kobject *kobj, struct kobj_attribute *attr,
-			char *buf)
-{
-	return sprintf(buf, "%02x\n%02x\n%02x\n%02x\n%02x\n"
-			    "%02x\n%02x\n%02x\n%02x\n%02x\n",
-			spid.fru[0], spid.fru[1], spid.fru[2], spid.fru[3],
-			spid.fru[4], spid.fru[5], spid.fru[6], spid.fru[7],
-			spid.fru[8], spid.fru[9]);
-}
-spid_attr(fru);
-
-static struct attribute *spid_attrs[] = {
-	&customer_id_attr.attr,
-	&vendor_id_attr.attr,
-	&manufacturer_id_attr.attr,
-	&platform_family_id_attr.attr,
-	&product_line_id_attr.attr,
-	&hardware_id_attr.attr,
-	&fru_attr.attr,
-	NULL,
-};
-
-static struct attribute_group spid_attr_group = {
-	.attrs = spid_attrs,
-};
-
-/* size of SPID cmdline : androidboot.spid=vend:cust:manu:plat:prod:hard */
-#define SPID_CMDLINE_SIZE 46
-#define SPID_PARAM_NAME "androidboot.spid="
-#define SPID_DEFAULT_VALUE "xxxx:xxxx:xxxx:xxxx:xxxx:xxxx"
-
-void populate_spid_cmdline(void)
-{
-	char *spid_param, *spid_default_value;
-	char spid_cmdline[SPID_CMDLINE_SIZE+1];
-
-	/* parameter format : cust:vend:manu:plat:prod:hard */
-	snprintf(spid_cmdline, sizeof(spid_cmdline),
-		 "%04x:%04x:%04x:%04x:%04x:%04x",
-		 spid.vendor_id,
-		 spid.customer_id,
-		 spid.manufacturer_id,
-		 spid.platform_family_id,
-		 spid.product_line_id,
-		 spid.hardware_id);
-
-	/* is there a spid param ? */
-	spid_param = strstr(saved_command_line, SPID_PARAM_NAME);
-	if (spid_param) {
-		/* is the param set to default value ? */
-		spid_default_value = strstr(saved_command_line,
-					    SPID_DEFAULT_VALUE);
-		if (spid_default_value) {
-			spid_param += strlen(SPID_PARAM_NAME);
-			if (strlen(spid_param) > strlen(spid_cmdline))
-				memcpy(spid_param, spid_cmdline,
-						strlen(spid_cmdline));
-			else
-				pr_err("Not enough free space for SPID in command line.\n");
-		} else
-			pr_warning("SPID already populated. Dont overwrite.\n");
-	} else
-		pr_err("SPID not found in kernel command line.\n");
-}
-
 static int __init intel_mid_platform_init(void)
 {
-	int ret = 0;
-
-	/* create sysfs entries for soft platform id */
-	spid_kobj = kobject_create_and_add("spid", NULL);
-	if (!spid_kobj) {
-		pr_err("SPID: ENOMEM for spid_kobj\n");
-		return -ENOMEM;
-	}
-
-	ret = sysfs_create_group(spid_kobj, &spid_attr_group);
-	if (ret) {
-		pr_err("SPID: failed to create /sys/spid\n");
-		return ret;
-	}
-
 	/* Get SFI OEMB Layout */
 	sfi_table_parse(SFI_SIG_OEMB, NULL, NULL, sfi_parse_oemb);
 	sfi_table_parse(SFI_SIG_GPIO, NULL, NULL, sfi_parse_gpio);
 	sfi_table_parse(SFI_SIG_DEVS, NULL, NULL, sfi_parse_devs);
 
-	/* Populate command line with SPID values */
-	populate_spid_cmdline();
-
 	return 0;
 }
 arch_initcall(intel_mid_platform_init);
diff --git a/arch/x86/platform/intel-mid/spid.c b/arch/x86/platform/intel-mid/spid.c
new file mode 100644
index 000000000000..4332c2bcab2d
--- /dev/null
+++ b/arch/x86/platform/intel-mid/spid.c
@@ -0,0 +1,321 @@
+/*
+ * spid.c: Soft Platform ID parsing and init code
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/scatterlist.h>
+#include <linux/sfi.h>
+#include <linux/intel_pmic_gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/skbuff.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/intel_mid_pm.h>
+#include <linux/hsi/hsi.h>
+#include <linux/spinlock.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/blkdev.h>
+#include <linux/acpi.h>
+#include <linux/intel_pidv_acpi.h>
+
+#include <asm/setup.h>
+#include <asm/mpspec_def.h>
+#include <asm/hw_irq.h>
+#include <asm/apic.h>
+#include <asm/io_apic.h>
+#include <asm/intel-mid.h>
+#include <asm/io.h>
+#include <asm/i8259.h>
+#include <asm/intel_scu_ipc.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/apb_timer.h>
+#include <asm/reboot.h>
+#include "intel_mid_weak_decls.h"
+
+char intel_platform_ssn[INTEL_PLATFORM_SSN_SIZE + 1];
+struct soft_platform_id spid;
+
+#ifdef CONFIG_ACPI
+struct platform_id pidv;
+struct kobject *pidv_kobj;
+#endif
+
+struct kobject *spid_kobj;
+
+/*
+ *
+ */
+static void populate_spid_cmdline(void)
+{
+	char *spid_param, *spid_default_value;
+	char spid_cmdline[SPID_CMDLINE_SIZE+1];
+
+	/* parameter format : cust:vend:manu:plat:prod:hard */
+	snprintf(spid_cmdline, sizeof(spid_cmdline),
+		 "%04x:%04x:%04x:%04x:%04x:%04x",
+		 spid.vendor_id,
+		 spid.customer_id,
+		 spid.manufacturer_id,
+		 spid.platform_family_id,
+		 spid.product_line_id,
+		 spid.hardware_id);
+
+	/* is there a spid param ? */
+	spid_param = strstr(saved_command_line, SPID_PARAM_NAME);
+	if (spid_param) {
+		/* is the param set to default value ? */
+		spid_default_value = strstr(saved_command_line,
+					    SPID_DEFAULT_VALUE);
+		if (spid_default_value) {
+			spid_param += strlen(SPID_PARAM_NAME);
+			if (strlen(spid_param) > strlen(spid_cmdline))
+				memcpy(spid_param, spid_cmdline,
+						strlen(spid_cmdline));
+			else
+				pr_err("Not enough free space for SPID in command line.\n");
+		} else
+			pr_warn("SPID already populated. Don't overwrite.\n");
+	} else
+		pr_err("SPID not found in kernel command line.\n");
+}
+static ssize_t customer_id_show(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.customer_id);
+}
+spid_attr(customer_id);
+
+static ssize_t vendor_id_show(struct kobject *kobj, struct kobj_attribute *attr,
+			      char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.vendor_id);
+}
+spid_attr(vendor_id);
+
+static ssize_t manufacturer_id_show(struct kobject *kobj,
+				    struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.manufacturer_id);
+}
+spid_attr(manufacturer_id);
+
+static ssize_t platform_family_id_show(struct kobject *kobj,
+				       struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.platform_family_id);
+}
+spid_attr(platform_family_id);
+
+static ssize_t product_line_id_show(struct kobject *kobj,
+				    struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.product_line_id);
+}
+spid_attr(product_line_id);
+
+static ssize_t hardware_id_show(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%04x\n", spid.hardware_id);
+}
+spid_attr(hardware_id);
+
+static ssize_t fru_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%02x\n%02x\n%02x\n%02x\n%02x\n"
+			    "%02x\n%02x\n%02x\n%02x\n%02x\n",
+			spid.fru[0], spid.fru[1], spid.fru[2], spid.fru[3],
+			spid.fru[4], spid.fru[5], spid.fru[6], spid.fru[7],
+			spid.fru[8], spid.fru[9]);
+}
+spid_attr(fru);
+
+static struct attribute *spid_attrs[] = {
+	&customer_id_attr.attr,
+	&vendor_id_attr.attr,
+	&manufacturer_id_attr.attr,
+	&platform_family_id_attr.attr,
+	&product_line_id_attr.attr,
+	&hardware_id_attr.attr,
+	&fru_attr.attr,
+	NULL,
+};
+
+static struct attribute_group spid_attr_group = {
+	.attrs = spid_attrs,
+};
+
+#ifdef CONFIG_ACPI
+static ssize_t iafw_version_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%02X.%02X\n", pidv.iafw_major, pidv.iafw_minor);
+}
+pidv_attr(iafw_version);
+
+static ssize_t secfw_version_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%02X.%02X\n", pidv.secfw_major, pidv.secfw_minor);
+}
+pidv_attr(secfw_version);
+
+
+static struct attribute *pidv_attrs[] = {
+	&iafw_version_attr.attr,
+	&secfw_version_attr.attr,
+	NULL,
+};
+
+static struct attribute_group pidv_attr_group = {
+	.attrs = pidv_attrs,
+};
+
+static int __init acpi_parse_pidv(struct acpi_table_header *table)
+{
+	struct acpi_table_pidv *pidv_tbl;
+
+	pidv_tbl = (struct acpi_table_pidv *)table;
+	if (!pidv_tbl) {
+		pr_warn("Unable to map PIDV\n");
+		return -ENODEV;
+	}
+
+	memcpy(&pidv, &(pidv_tbl->pidv), sizeof(struct platform_id));
+	/*
+	 * FIXME: add spid accessor, instead of memcpy
+	 */
+	memcpy(&spid, &(pidv_tbl->pidv.ext_id_1),
+			sizeof(struct soft_platform_id));
+	/*
+	 * FIXME: add ssn accessor, instead of memcpy
+	 */
+	memcpy(&intel_platform_ssn, &(pidv_tbl->pidv.part_number),
+			INTEL_PLATFORM_SSN_SIZE);
+	intel_platform_ssn[INTEL_PLATFORM_SSN_SIZE] = '\0';
+
+	return 0;
+}
+
+static int __init acpi_spid_init(void)
+{
+	int ret = 0;
+
+	/* create sysfs entries for soft platform id */
+	spid_kobj = kobject_create_and_add("spid", NULL);
+	if (!spid_kobj) {
+		pr_err("SPID: ENOMEM for spid_kobj\n");
+		return -ENOMEM;
+	}
+
+	ret = sysfs_create_group(spid_kobj, &spid_attr_group);
+	if (ret) {
+		pr_err("SPID: failed to create /sys/spid\n");
+		goto err_sysfs_spid;
+	}
+
+	/* parse SPID table from firmware/bios */
+	ret = acpi_table_parse(ACPI_SIG_PIDV, acpi_parse_pidv);
+	if (ret) {
+		pr_err("SPID: PIDV ACPI table not found\n");
+		ret = -EINVAL;
+		goto err_acpi_parse;
+	}
+
+	pidv_kobj = kobject_create_and_add("pidv", firmware_kobj);
+	if (!pidv_kobj) {
+		pr_err("pidv: ENOMEM for pidv_kobj\n");
+		ret = -ENOMEM;
+		goto err_kobj_create_pidv;
+	}
+
+	ret = sysfs_create_group(pidv_kobj, &pidv_attr_group);
+	if (ret) {
+		pr_err("SPID: failed to create /sys/spid\n");
+		goto err_sysfs_pidv;
+	}
+
+	/* Populate command line with SPID values */
+	populate_spid_cmdline();
+
+	return 0;
+
+err_sysfs_pidv:
+	kobject_put(firmware_kobj);
+err_kobj_create_pidv:
+err_acpi_parse:
+	sysfs_remove_group(spid_kobj, &spid_attr_group);
+err_sysfs_spid:
+	kobject_put(spid_kobj);
+
+	return ret;
+
+}
+arch_initcall(acpi_spid_init);
+#endif
+
+int __init sfi_handle_spid(struct sfi_table_header *table)
+{
+	struct sfi_table_oemb *oemb;
+	int ret = 0;
+
+	/* create sysfs entries for soft platform id */
+	spid_kobj = kobject_create_and_add("spid", NULL);
+	if (!spid_kobj) {
+		pr_err("SPID: ENOMEM for spid_kobj\n");
+		return -ENOMEM;
+	}
+
+	ret = sysfs_create_group(spid_kobj, &spid_attr_group);
+	if (ret) {
+		pr_err("SPID: failed to create /sys/spid\n");
+		goto err_sfi_sysfs_spid;
+	}
+
+	oemb = (struct sfi_table_oemb *) table;
+	if (!oemb) {
+		pr_err("%s: fail to read MFD Validation SFI OEMB Layout\n",
+			__func__);
+		ret = -ENODEV;
+		goto err_sfi_oemb_tbl;
+	}
+
+	memcpy(&spid, &oemb->spid, sizeof(struct soft_platform_id));
+
+	if (oemb->header.len <
+			(char *)oemb->ssn + INTEL_PLATFORM_SSN_SIZE - (char *)oemb) {
+		pr_err("SFI OEMB does not contains SSN\n");
+		intel_platform_ssn[0] = '\0';
+	} else {
+		memcpy(intel_platform_ssn, oemb->ssn, INTEL_PLATFORM_SSN_SIZE);
+		intel_platform_ssn[INTEL_PLATFORM_SSN_SIZE] = '\0';
+	}
+
+	/* Populate command line with SPID values */
+	populate_spid_cmdline();
+
+err_sfi_oemb_tbl:
+	sysfs_remove_group(spid_kobj, &spid_attr_group);
+err_sfi_sysfs_spid:
+	kobject_put(spid_kobj);
+
+	return 0;
+}
diff --git a/include/linux/intel_pidv_acpi.h b/include/linux/intel_pidv_acpi.h
new file mode 100644
index 000000000000..77f0178bd91f
--- /dev/null
+++ b/include/linux/intel_pidv_acpi.h
@@ -0,0 +1,54 @@
+/*
+ * include/linux/intel_pidv_acpi.h
+ *
+ * Copyright (C) 2013 Intel Corp
+ * Author: Vincent Tinelli (vincent.tinelli@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ */
+
+#ifndef _INTEL_PIDV_ACPI_H
+#define _INTEL_PIDV_ACPI_H
+
+#include <linux/acpi.h>
+#ifdef CONFIG_ACPI
+#define ACPI_SIG_PIDV           "PIDV"
+
+#define pidv_attr(_name) \
+static struct kobj_attribute _name##_attr = {	\
+	.attr   = {				\
+		.name = __stringify(_name),	\
+		.mode = 0440,			\
+	},					\
+	.show   = _name##_show,			\
+}
+
+struct platform_id {
+	u8 part_number[32];
+	u8 ext_id_1[32];
+	u8 ext_id_2[32];
+	u8 uuid[16];
+	u8 iafw_major;
+	u8 iafw_minor;
+	u8 secfw_major;
+	u8 secfw_minor;
+};
+
+struct acpi_table_pidv {
+	struct acpi_table_header header;
+	struct platform_id pidv;
+};
+
+#endif
+#endif
-- 
2.37.3

