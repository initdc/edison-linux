From 7f36bc940ff0630757b552fff1575a317f0329ef Mon Sep 17 00:00:00 2001
From: Durgadoss R <durgadoss.r@intel.com>
Date: Wed, 11 Dec 2013 21:37:43 +0530
Subject: [PATCH 169/429] EM/THERMAL: Do not read cached temperature in IRQ
 handler

The update_temp() method in the coretemp driver returns
the previously cached temperature value if it is read again
within a second. This method is used in IRQ handler, where the
driver sends the current temperature as part of the UEvent
to user space. Sometimes, this read (due to very frequent
interrupts) falls within one second and hence returns a
stale value.

This patch avoids this behavior, by directly reading the
temperature from 0x19C, _everytime_ when there is an
interrupt. While we are there:
 * Remove update_temp() as that code is now used
   within show_temp() itself
 * Print threshold0/1 as part of log message
 * Send UEvent only when we go below lower threshold
   or go above upper thresholds (considered as
   valid events)
 * Print log messages only for valid events
 * For invalid events, include the prints as
   pr_debug so that they appear only during debug.

Signed-off-by: Durgadoss R <durgadoss.r@intel.com>
---
 drivers/hwmon/coretemp.c | 51 +++++++++++++++++++++++-----------------
 1 file changed, 30 insertions(+), 21 deletions(-)

diff --git a/drivers/hwmon/coretemp.c b/drivers/hwmon/coretemp.c
index cdc60a28c28e..d8b530b8019d 100644
--- a/drivers/hwmon/coretemp.c
+++ b/drivers/hwmon/coretemp.c
@@ -276,9 +276,13 @@ static ssize_t show_ttarget(struct device *dev,
 	return sprintf(buf, "%d\n", pdata->core_data[attr->index]->ttarget);
 }
 
-static void update_temp(struct temp_data *tdata)
+static ssize_t show_temp(struct device *dev,
+			struct device_attribute *devattr, char *buf)
 {
 	u32 eax, edx;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct platform_data *pdata = dev_get_drvdata(dev);
+	struct temp_data *tdata = pdata->core_data[attr->index];
 
 	mutex_lock(&tdata->update_lock);
 
@@ -296,16 +300,6 @@ static void update_temp(struct temp_data *tdata)
 	}
 
 	mutex_unlock(&tdata->update_lock);
-}
-
-static ssize_t show_temp(struct device *dev,
-			struct device_attribute *devattr, char *buf)
-{
-	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
-	struct platform_data *pdata = dev_get_drvdata(dev);
-	struct temp_data *tdata = pdata->core_data[attr->index];
-
-	update_temp(tdata);
 
 	return tdata->valid ? sprintf(buf, "%d\n", tdata->temp) : -EAGAIN;
 }
@@ -507,7 +501,7 @@ static int coretemp_interrupt(__u64 msr_val)
 static void core_threshold_work_fn(struct work_struct *work)
 {
 	u32 eax, edx;
-	int thresh, event;
+	int thresh, event, t0, t1, temp;
 	char *thermal_event[5];
 	bool notify = false;
 	unsigned int cpu = smp_processor_id();
@@ -530,7 +524,9 @@ static void core_threshold_work_fn(struct work_struct *work)
 		eax = eax & ~THERM_LOG_THRESHOLD0;
 		wrmsr_on_cpu(cpu, MSR_IA32_THERM_STATUS, eax, edx);
 
-		notify = true;
+		/* Notify only when we go below the lower threshold */
+		if (event != 1)
+			notify = true;
 
 	} else if (eax & THERM_LOG_THRESHOLD1) {
 		thresh = 1;
@@ -540,24 +536,37 @@ static void core_threshold_work_fn(struct work_struct *work)
 		eax = eax & ~THERM_LOG_THRESHOLD1;
 		wrmsr_on_cpu(cpu, MSR_IA32_THERM_STATUS, eax, edx);
 
-		notify = true;
+		/* Notify only when we go above the upper threshold */
+		if (event != 0)
+			notify = true;
 	}
 
-	if (!notify)
-		return;
-
 	/*
 	 * Read the current Temperature and send it to user land;
 	 * so that the user space can avoid a sysfs read.
 	 */
-	update_temp(tdata);
+	temp = tdata->tjmax - ((eax >> 16) & 0x7f) * 1000;
 
-	pr_info("Thermal Event: sensor: Core %u, cur_temp: %d, event: %d, level: %d\n",
-			tdata->cpu_core_id, tdata->temp, event, thresh);
+	/* Read the threshold registers (only) to print threshold values. */
+	rdmsr_on_cpu(cpu, MSR_IA32_THERM_INTERRUPT, &eax, &edx);
+	t0 = tdata->tjmax - ((eax & THERM_MASK_THRESHOLD0) >> THERM_SHIFT_THRESHOLD0) * 1000;
+	t1 = tdata->tjmax - ((eax & THERM_MASK_THRESHOLD1) >> THERM_SHIFT_THRESHOLD1) * 1000;
+
+
+	if (!notify) {
+		pr_debug("Thermal Event: Sensor: Core %u, cur_temp: %d,\
+			event: %d, level: %d, t0: %d, t1: %d\n",
+			tdata->cpu_core_id, temp, event, thresh, t0, t1);
+		return;
+	} else {
+		pr_info("Thermal Event: Sensor: Core %u, cur_temp: %d,\
+			event: %d, level: %d, t0: %d, t1: %d\n",
+			tdata->cpu_core_id, temp, event, thresh, t0, t1);
+	}
 
 	thermal_event[0] = kasprintf(GFP_KERNEL, "NAME=Core %u",
 						tdata->cpu_core_id);
-	thermal_event[1] = kasprintf(GFP_KERNEL, "TEMP=%d", tdata->temp);
+	thermal_event[1] = kasprintf(GFP_KERNEL, "TEMP=%d", temp);
 	thermal_event[2] = kasprintf(GFP_KERNEL, "EVENT=%d", event);
 	thermal_event[3] = kasprintf(GFP_KERNEL, "LEVEL=%d", thresh);
 	thermal_event[4] = NULL;
-- 
2.37.3

