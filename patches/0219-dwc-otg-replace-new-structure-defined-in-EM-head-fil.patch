From 496550716dc20a14d19fdfa914d56be1dec9f6f7 Mon Sep 17 00:00:00 2001
From: "Wang, Yu" <yu.y.wang@intel.com>
Date: Wed, 14 Aug 2013 18:40:18 +0800
Subject: [PATCH 219/429] dwc-otg: replace new structure defined in EM head
 files.

To support scalability for dwc3-otg driver. Replace structure otg_bc_cap
to power_supply_cable_props which define in linux/power_supply.h

Signed-off-by: Wang, Yu <yu.y.wang@intel.com>
---
 drivers/usb/dwc3/dwc3-intel-mrfl.c | 10 +---
 drivers/usb/dwc3/otg.c             | 95 +++++++++++++++---------------
 drivers/usb/dwc3/otg.h             | 38 ++----------
 3 files changed, 54 insertions(+), 89 deletions(-)

diff --git a/drivers/usb/dwc3/dwc3-intel-mrfl.c b/drivers/usb/dwc3/dwc3-intel-mrfl.c
index d6c169071958..6918d5e0c972 100644
--- a/drivers/usb/dwc3/dwc3-intel-mrfl.c
+++ b/drivers/usb/dwc3/dwc3-intel-mrfl.c
@@ -520,7 +520,7 @@ static int dwc3_intel_set_power(struct usb_phy *_otg,
 	spin_unlock_irqrestore(&otg->lock, flags);
 
 	dwc3_intel_notify_charger_type(otg,
-			OTG_CHR_STATE_CONNECTED);
+			POWER_SUPPLY_CHARGER_EVENT_CONNECT);
 
 		/* mA is zero mean D+/D- opened cable.
 		 * If SMIP set, then notify 500mA.
@@ -543,17 +543,13 @@ static int dwc3_intel_set_power(struct usb_phy *_otg,
 
 int dwc3_intel_enable_vbus(struct dwc_otg2 *otg, int enable)
 {
-	struct otg_bc_cap cap;
 	int ret = 0;
 	u8 ovrwr;
 
-	if (enable) {
-		cap.chrg_state = OTG_CHR_STATE_HOST;
+	if (enable)
 		ovrwr = 0x40;
-	} else {
-		cap.chrg_state = OTG_CHR_STATE_DISCONNECTED;
+	else
 		ovrwr = 0x00;
-	}
 
 		return 0;
 	}
diff --git a/drivers/usb/dwc3/otg.c b/drivers/usb/dwc3/otg.c
index 63ce977b2440..56fcba930871 100644
--- a/drivers/usb/dwc3/otg.c
+++ b/drivers/usb/dwc3/otg.c
@@ -273,7 +273,7 @@ static int dwc_otg_notify_charger_type(struct dwc_otg2 *otg,
 		enum usb_charger_state state)
 {
 	if (dwc3_otg_pdata->notify_charger_type)
-		return dwc3_otg_pdata->notify_charger_type(otg, state);
+		return dwc3_otg_pdata->notify_charger_type(otg, event);
 
 	return 0;
 }
@@ -281,7 +281,8 @@ static int dwc_otg_notify_charger_type(struct dwc_otg2 *otg,
 static int dwc_otg_get_chrg_status(struct usb_phy *x, void *data)
 {
 	unsigned long flags;
-	struct otg_bc_cap *cap = (struct otg_bc_cap *)data;
+	struct power_supply_cable_props *cap =
+		(struct power_supply_cable_props *)data;
 	struct dwc_otg2 *otg = the_transceiver;
 
 	if (!x)
@@ -292,7 +293,7 @@ static int dwc_otg_get_chrg_status(struct usb_phy *x, void *data)
 
 	spin_lock_irqsave(&otg->lock, flags);
 	cap->chrg_type = otg->charging_cap.chrg_type;
-	cap->chrg_state = otg->charging_cap.chrg_state;
+	cap->chrg_evt = otg->charging_cap.chrg_evt;
 	cap->ma = otg->charging_cap.ma;
 	spin_unlock_irqrestore(&otg->lock, flags);
 
@@ -374,9 +375,10 @@ static enum dwc_otg_state do_wait_vbus_fall(struct dwc_otg2 *otg)
 
 	if (otg_events & OEVT_A_DEV_SESS_END_DET_EVNT) {
 		otg_dbg(otg, "OEVT_A_DEV_SESS_END_DET_EVNT\n");
-		if (otg->charging_cap.chrg_type == CHRG_ACA_DOCK)
+		if (otg->charging_cap.chrg_type ==
+				POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK)
 			dwc_otg_notify_charger_type(otg,
-				OTG_CHR_STATE_DISCONNECTED);
+				POWER_SUPPLY_CHARGER_EVENT_DISCONNECT);
 		return DWC_STATE_B_IDLE;
 	}
 
@@ -411,70 +413,68 @@ static enum dwc_otg_state do_charging(struct dwc_otg2 *otg)
 	if (otg_events & OEVT_A_DEV_SESS_END_DET_EVNT) {
 		otg_dbg(otg, "OEVT_A_DEV_SESS_END_DET_EVNT\n");
 		dwc_otg_notify_charger_type(otg,
-				OTG_CHR_STATE_DISCONNECTED);
+				POWER_SUPPLY_CHARGER_EVENT_DISCONNECT);
 		return DWC_STATE_B_IDLE;
 	}
 
 	return DWC_STATE_INVALID;
 }
 
-static enum usb_charger_type get_charger_type(struct dwc_otg2 *otg)
+static enum power_supply_charger_cable_type
+		get_charger_type(struct dwc_otg2 *otg)
 {
 	if (dwc3_otg_pdata->get_charger_type)
 		return dwc3_otg_pdata->get_charger_type(otg);
 
-	return CHRG_UNKNOWN;
+	return POWER_SUPPLY_CHARGER_TYPE_NONE;
 }
 
 static enum dwc_otg_state do_charger_detection(struct dwc_otg2 *otg)
 {
 	enum dwc_otg_state state = DWC_STATE_INVALID;
-	enum usb_charger_type charger = CHRG_UNKNOWN;
+	enum power_supply_charger_cable_type charger =
+			POWER_SUPPLY_CHARGER_TYPE_NONE;
 	unsigned long flags, ma = 0;
 
 	charger = get_charger_type(otg);
 	switch (charger) {
-	case CHRG_ACA_C:
-	case CHRG_ACA_A:
-	case CHRG_ACA_B:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_A:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_B:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_C:
 		otg_err(otg, "Ignore micro ACA charger.\n");
-		charger = CHRG_UNKNOWN;
+		charger = POWER_SUPPLY_CHARGER_TYPE_NONE;
 		break;
-	case CHRG_SDP:
-	case CHRG_CDP:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
 		state = DWC_STATE_B_PERIPHERAL;
 		break;
-	case CHRG_ACA_DOCK:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
 		state = DWC_STATE_A_HOST;
 		break;
-	case CHRG_DCP:
-	case CHRG_SE1:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+	case POWER_SUPPLY_CHARGER_TYPE_SE1:
 		state = DWC_STATE_CHARGING;
 		break;
-	case CHRG_UNKNOWN:
+	case POWER_SUPPLY_CHARGER_TYPE_NONE:
 	default:
 		if (is_self_powered_b_device(otg)) {
 			state = DWC_STATE_A_HOST;
-			charger = B_DEVICE;
+			charger = POWER_SUPPLY_CHARGER_TYPE_B_DEVICE;
 			break;
 		}
 	};
 
 	switch (charger) {
-	case CHRG_ACA_DOCK:
-	case CHRG_ACA_A:
-	case CHRG_ACA_B:
-	case CHRG_ACA_C:
-	case CHRG_DCP:
-	case CHRG_CDP:
-	case CHRG_SE1:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_A:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_B:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_C:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+	case POWER_SUPPLY_CHARGER_TYPE_SE1:
 		ma = 1500;
 		break;
-<<<<<<< HEAD
 	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
-=======
-	case CHRG_SDP:
->>>>>>> dde13b2... Revert: [PORT FROM K34]dwc-otg: replace new structure defined in EM head files.
 		/* Notify SDP current is 100ma before enumeration. */
 		ma = 100;
 		break;
@@ -489,21 +489,13 @@ static enum dwc_otg_state do_charger_detection(struct dwc_otg2 *otg)
 	spin_unlock_irqrestore(&otg->lock, flags);
 
 	switch (charger) {
-<<<<<<< HEAD
 	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
 	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
 	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
 	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
 	case POWER_SUPPLY_CHARGER_TYPE_SE1:
-=======
-	case CHRG_ACA_DOCK:
-	case CHRG_DCP:
-	case CHRG_CDP:
-	case CHRG_SDP:
-	case CHRG_SE1:
->>>>>>> dde13b2... Revert: [PORT FROM K34]dwc-otg: replace new structure defined in EM head files.
 		if (dwc_otg_notify_charger_type(otg,
-					OTG_CHR_STATE_CONNECTED) < 0)
+					POWER_SUPPLY_CHARGER_EVENT_CONNECT) < 0)
 			otg_err(otg, "Notify battery type failed!\n");
 		break;
 	default:
@@ -523,9 +515,9 @@ static enum dwc_otg_state do_connector_id_status(struct dwc_otg2 *otg)
 
 	otg_dbg(otg, "\n");
 	spin_lock_irqsave(&otg->lock, flags);
-	otg->charging_cap.chrg_type = CHRG_UNKNOWN;
+	otg->charging_cap.chrg_type = POWER_SUPPLY_CHARGER_TYPE_NONE;
 	otg->charging_cap.ma = 0;
-	otg->charging_cap.chrg_state = OTG_CHR_STATE_DISCONNECTED;
+	otg->charging_cap.chrg_evt = POWER_SUPPLY_CHARGER_EVENT_DISCONNECT;
 	spin_unlock_irqrestore(&otg->lock, flags);
 
 	otg_mask = OEVT_CONN_ID_STS_CHNG_EVNT |
@@ -577,7 +569,8 @@ static enum dwc_otg_state do_a_host(struct dwc_otg2 *otg)
 	int id = RID_UNKNOWN;
 	unsigned long flags;
 
-	if (otg->charging_cap.chrg_type != CHRG_ACA_DOCK) {
+	if (otg->charging_cap.chrg_type !=
+			POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK) {
 		dwc_otg_enable_vbus(otg, 1);
 
 		/* meant receive vbus valid event*/
@@ -616,9 +609,10 @@ static enum dwc_otg_state do_a_host(struct dwc_otg2 *otg)
 		otg_dbg(otg, "OEVT_A_DEV_SESS_END_DET_EVNT\n");
 
 		/* ACA-Dock plug out */
-		if (otg->charging_cap.chrg_type == CHRG_ACA_DOCK)
+		if (otg->charging_cap.chrg_type ==
+				POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK)
 			dwc_otg_notify_charger_type(otg,
-					OTG_CHR_STATE_DISCONNECTED);
+					POWER_SUPPLY_CHARGER_EVENT_DISCONNECT);
 		else
 			dwc_otg_enable_vbus(otg, 0);
 
@@ -645,7 +639,8 @@ static enum dwc_otg_state do_a_host(struct dwc_otg2 *otg)
 
 		/* Plug out ACA_DOCK/USB device */
 		if (id == RID_FLOAT) {
-			if (otg->charging_cap.chrg_type == CHRG_ACA_DOCK) {
+			if (otg->charging_cap.chrg_type ==
+					POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK) {
 				/* ACA_DOCK plug out, receive
 				 * id change prior to vBus change
 				 */
@@ -653,7 +648,8 @@ static enum dwc_otg_state do_a_host(struct dwc_otg2 *otg)
 			} else {
 				/* Normal USB device plug out */
 				spin_lock_irqsave(&otg->lock, flags);
-				otg->charging_cap.chrg_type = CHRG_UNKNOWN;
+				otg->charging_cap.chrg_type =
+					POWER_SUPPLY_CHARGER_TYPE_NONE;
 				spin_unlock_irqrestore(&otg->lock, flags);
 
 				stop_host(otg);
@@ -662,7 +658,8 @@ static enum dwc_otg_state do_a_host(struct dwc_otg2 *otg)
 		} else {
 			otg_err(otg, "Meet invalid charger cases!");
 			spin_lock_irqsave(&otg->lock, flags);
-			otg->charging_cap.chrg_type = CHRG_UNKNOWN;
+			otg->charging_cap.chrg_type =
+				POWER_SUPPLY_CHARGER_TYPE_NONE;
 			spin_unlock_irqrestore(&otg->lock, flags);
 
 			stop_host(otg);
@@ -704,7 +701,7 @@ static int do_b_peripheral(struct dwc_otg2 *otg)
 	if (otg_events & OEVT_A_DEV_SESS_END_DET_EVNT) {
 		otg_dbg(otg, "OEVT_A_DEV_SESS_END_DET_EVNT\n");
 		dwc_otg_notify_charger_type(otg,
-				OTG_CHR_STATE_DISCONNECTED);
+				POWER_SUPPLY_CHARGER_EVENT_DISCONNECT);
 		return DWC_STATE_B_IDLE;
 	}
 
diff --git a/drivers/usb/dwc3/otg.h b/drivers/usb/dwc3/otg.h
index c258f85dad98..fde43ee170fa 100644
--- a/drivers/usb/dwc3/otg.h
+++ b/drivers/usb/dwc3/otg.h
@@ -23,6 +23,7 @@
 #include <linux/usb.h>
 #include <linux/device.h>
 #include <linux/compiler.h>
+#include <linux/power_supply.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/hcd.h>
 #include <linux/usb/ulpi.h>
@@ -255,23 +256,6 @@ struct dwc_device_par {
 #define ADPEVTEN_ADP_PRB_EVNT_EN		0x10000000
 #define ADPEVTEN_ADP_PRB_EVNT_EN_SHIFT		28
 
-
-/* charger defined in BC 1.2 */
-enum usb_charger_type {
-	CHRG_UNKNOWN,
-	CHRG_SDP,	/* Standard Downstream Port */
-	CHRG_CDP,	/* Charging Downstream Port */
-	CHRG_DCP,	/* Dedicated Charging Port */
-	CHRG_ACA,	/* Accessory Charger Adapter */
-	CHRG_ACA_DOCK,	/* Accessory Charger Adapter - Dock */
-	CHRG_ACA_A,	/* Accessory Charger Adapter - RID_A */
-	CHRG_ACA_B,	/* Accessory Charger Adapter - RID_B */
-	CHRG_ACA_C,	/* Accessory Charger Adapter - RID_C */
-	CHRG_SE1,	/* SE1 (Apple)*/
-	CHRG_MHL,	/* Moblie High-Definition Link */
-	B_DEVICE	/* Normal B Device */
-};
-
 #define RID_A		0x01
 #define RID_B		0x02
 #define RID_C		0x03
@@ -279,19 +263,6 @@ enum usb_charger_type {
 #define RID_GND		0x05
 #define RID_UNKNOWN	0x00
 
-enum usb_charger_state {
-	OTG_CHR_STATE_CONNECTED,		/* charger is connected */
-	OTG_CHR_STATE_DISCONNECTED,	/* USB port is disconnected */
-	OTG_CHR_STATE_SUSPENDED,		/* PORT goes to suspend */
-	OTG_CHR_STATE_HOST,			/* USB in host mode */
-};
-
-struct otg_bc_cap {
-	enum usb_charger_type   chrg_type;
-	enum usb_charger_state      chrg_state;
-	unsigned int            ma;
-};
-
 /** The states for the OTG driver */
 enum dwc_otg_state {
 	DWC_STATE_INVALID = -1,
@@ -368,7 +339,7 @@ struct dwc_otg2 {
 	struct platform_device *gadget;
 
 	/* Charger detection */
-	struct otg_bc_cap charging_cap;
+	struct power_supply_cable_props charging_cap;
 	struct notifier_block nb;
 
 	/* Interfaces between host/device driver */
@@ -432,8 +403,9 @@ struct dwc3_otg_hw_ops {
 	int (*b_idle)(struct dwc_otg2 *otg);
 	int (*do_charging)(struct dwc_otg2 *otg);
 	int (*notify_charger_type)(struct dwc_otg2 *otg,
-			enum usb_charger_state state);
-	enum usb_charger_type (*get_charger_type)(struct dwc_otg2 *otg);
+			enum power_supply_charger_event event);
+	enum power_supply_charger_cable_type
+		(*get_charger_type)(struct dwc_otg2 *otg);
 	int (*enable_vbus)(struct dwc_otg2 *otg, int enable);
 	int (*get_id)(struct dwc_otg2 *otg);
 };
-- 
2.37.3

