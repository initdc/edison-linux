From 035656723ad45e907fd54b90eed5ae6710fa7293 Mon Sep 17 00:00:00 2001
From: Sathyanarayanan Kuppuswamy <sathyanarayanan.kuppuswamy@intel.com>
Date: Thu, 11 Apr 2013 14:57:17 -0700
Subject: [PATCH 009/429] MFD driver added

Signed-off-by: Sathyanarayanan Kuppuswamy <sathyanarayanan.kuppuswamy@intel.com>
---
 arch/x86/include/asm/intel_mid_hsu.h          |   43 +
 .../platform/intel-mid/device_libs/Makefile   |    2 +
 .../intel-mid/device_libs/platform_hsu.c      |  381 ++++++
 .../intel-mid/device_libs/platform_hsu.h      |   43 +
 drivers/tty/serial/mfd.c                      | 1025 +++++++++++------
 include/linux/serial_mfd.h                    |   13 +-
 6 files changed, 1131 insertions(+), 376 deletions(-)
 create mode 100644 arch/x86/include/asm/intel_mid_hsu.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_hsu.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_hsu.h

diff --git a/arch/x86/include/asm/intel_mid_hsu.h b/arch/x86/include/asm/intel_mid_hsu.h
new file mode 100644
index 000000000000..6389e4225bbe
--- /dev/null
+++ b/arch/x86/include/asm/intel_mid_hsu.h
@@ -0,0 +1,43 @@
+#ifndef __INTEL_MID_HSU_H__
+#define __INTEL_MID_HSU_H__
+
+enum {
+	hsu_port0,
+	hsu_port1,
+	hsu_port2,
+	hsu_port_share,
+	hsu_port_max,
+	hsu_dma,
+};
+
+enum {
+	bt_port,
+	modem_port,
+	gps_port,
+	debug_port,
+};
+
+struct hsu_port_cfg {
+	int type;
+	int index;
+	char *name;
+	int idle;
+	int has_alt;
+	int alt;
+	int force_suspend;
+	int (*hw_init)(int port);
+	void(*hw_set_alt)(int port);
+	void(*hw_set_rts)(int port, int value);
+	void(*hw_suspend)(int port, struct device *dev, irq_handler_t wake_isr);
+	void(*hw_resume)(int port, struct device *dev);
+};
+
+void intel_mid_hsu_suspend(int port, struct device *dev,
+				irq_handler_t wake_isr);
+void intel_mid_hsu_resume(int port, struct device *dev);
+void intel_mid_hsu_rts(int port, int value);
+void intel_mid_hsu_switch(int port);
+int intel_mid_hsu_init(int port);
+extern int hsu_register_board_info(void *inf);
+
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile
index ff21024ba2b6..050825d5bf37 100644
--- a/arch/x86/platform/intel-mid/device_libs/Makefile
+++ b/arch/x86/platform/intel-mid/device_libs/Makefile
@@ -19,3 +19,5 @@ obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_tca6416.o
 obj-$(subst m,y,$(CONFIG_SERIAL_MRST_MAX3110)) += platform_max3111.o
 # MISC Devices
 obj-$(subst m,y,$(CONFIG_KEYBOARD_GPIO)) += platform_gpio_keys.o
+# UART Devices
+obj-$(subst m,y,$(CONFIG_SERIAL_MFD_HSU))				+= platform_hsu.o
\ No newline at end of file
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_hsu.c b/arch/x86/platform/intel-mid/device_libs/platform_hsu.c
new file mode 100644
index 000000000000..ac99074c56eb
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_hsu.c
@@ -0,0 +1,381 @@
+/*
+ * platform_hsu.c: hsu platform data initilization file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <linux/lnw_gpio.h>
+#include <linux/gpio.h>
+#include <asm/setup.h>
+#include <asm/intel_mid_hsu.h>
+#include <asm/intel-mid.h>
+#include "platform_hsu.h"
+
+static struct hsu_port_pin_cfg hsu_port_pin_cfgs[][hsu_port_max] = {
+	[hsu_pnw] = {
+		[hsu_port0] = {
+			.id = 0,
+			.name = HSU_BT_PORT,
+			.wake_gpio = 13,
+			.rx_gpio = 96+26,
+			.rx_alt = 1,
+			.tx_gpio = 96+27,
+			.tx_alt = 1,
+			.cts_gpio = 96+28,
+			.cts_alt = 1,
+			.rts_gpio = 96+29,
+			.rts_alt = 1,
+		},
+		[hsu_port1] = {
+			.id = 1,
+			.name = HSU_MODEM_PORT,
+			.wake_gpio = 64,
+			.rx_gpio = 64,
+			.rx_alt = 1,
+			.tx_gpio = 65,
+			.tx_alt = 1,
+			.cts_gpio = 68,
+			.cts_alt = 1,
+			.rts_gpio = 66,
+			.rts_alt = 2,
+		},
+		[hsu_port2] = {
+			.id = 2,
+			.name = HSU_GPS_PORT,
+		},
+		[hsu_port_share] = {
+			.id = 1,
+			.name = HSU_DEBUG_PORT,
+			.wake_gpio = 96+30,
+			.rx_gpio = 96+30,
+			.rx_alt = 1,
+			.tx_gpio = 96+31,
+			.tx_alt = 1,
+		},
+	},
+	[hsu_clv] = {
+		[hsu_port0] = {
+			.id = 0,
+			.name = HSU_BT_PORT,
+			.wake_gpio = 42,
+			.rx_gpio = 96+26,
+			.rx_alt = 1,
+			.tx_gpio = 96+27,
+			.tx_alt = 1,
+			.cts_gpio = 96+28,
+			.cts_alt = 1,
+			.rts_gpio = 96+29,
+			.rts_alt = 1,
+		},
+		[hsu_port1] = {
+			.id = 1,
+			.name = HSU_MODEM_PORT,
+			.wake_gpio = 64,
+			.rx_gpio = 64,
+			.rx_alt = 1,
+			.tx_gpio = 65,
+			.tx_alt = 1,
+			.cts_gpio = 68,
+			.cts_alt = 1,
+			.rts_gpio = 66,
+			.rts_alt = 2,
+		},
+		[hsu_port2] = {
+			.id = 2,
+			.name = HSU_DEBUG_PORT,
+			.wake_gpio = 67,
+			.rx_gpio = 67,
+			.rx_alt = 1,
+		},
+		[hsu_port_share] = {
+			.id = 1,
+			.name = HSU_GPS_PORT,
+			.wake_gpio = 96+30,
+			.rx_gpio = 96+30,
+			.rx_alt = 1,
+			.tx_gpio = 96+31,
+			.tx_alt = 1,
+			.cts_gpio = 96+33,
+			.cts_alt = 1,
+			.rts_gpio = 96+32,
+			.rts_alt = 2,
+		},
+	},
+};
+
+static struct hsu_port_cfg hsu_port_cfgs[][hsu_port_max] = {
+	[hsu_pnw] = {
+		[hsu_port0] = {
+			.type = bt_port,
+			.index = 0,
+			.name = HSU_BT_PORT,
+			.idle = 20,
+			.hw_init = intel_mid_hsu_init,
+			.hw_set_alt = intel_mid_hsu_switch,
+			.hw_set_rts = intel_mid_hsu_rts,
+			.hw_suspend = intel_mid_hsu_suspend,
+			.hw_resume = intel_mid_hsu_resume,
+		},
+		[hsu_port1] = {
+			.type = modem_port,
+			.index = 1,
+			.name = HSU_MODEM_PORT,
+			.idle = 100,
+			.hw_init = intel_mid_hsu_init,
+			.hw_set_alt = intel_mid_hsu_switch,
+			.hw_set_rts = intel_mid_hsu_rts,
+			.hw_suspend = intel_mid_hsu_suspend,
+			.hw_resume = intel_mid_hsu_resume,
+			.has_alt = 1,
+			.alt = hsu_port_share,
+			.force_suspend = 0,
+		},
+		[hsu_port2] = {
+			.type = gps_port,
+			.index = 2,
+			.name = HSU_GPS_PORT,
+			.idle = 100,
+			.hw_init = intel_mid_hsu_init,
+			.hw_set_alt = intel_mid_hsu_switch,
+			.hw_set_rts = intel_mid_hsu_rts,
+			.hw_suspend = intel_mid_hsu_suspend,
+			.hw_resume = intel_mid_hsu_resume,
+		},
+		[hsu_port_share] = {
+			.type = debug_port,
+			.index = 3,
+			.name = HSU_DEBUG_PORT,
+			.idle = 2000,
+			.hw_init = intel_mid_hsu_init,
+			.hw_set_alt = intel_mid_hsu_switch,
+			.hw_set_rts = intel_mid_hsu_rts,
+			.hw_suspend = intel_mid_hsu_suspend,
+			.hw_resume = intel_mid_hsu_resume,
+			.has_alt = 1,
+			.alt = hsu_port1,
+			.force_suspend = 1,
+		},
+	},
+	[hsu_clv] = {
+		[hsu_port0] = {
+			.type = bt_port,
+			.index = 0,
+			.name = HSU_BT_PORT,
+			.idle = 20,
+			.hw_init = intel_mid_hsu_init,
+			.hw_set_alt = intel_mid_hsu_switch,
+			.hw_set_rts = intel_mid_hsu_rts,
+			.hw_suspend = intel_mid_hsu_suspend,
+			.hw_resume = intel_mid_hsu_resume,
+		},
+		[hsu_port1] = {
+			.type = modem_port,
+			.index = 1,
+			.name = HSU_MODEM_PORT,
+			.idle = 100,
+			.hw_init = intel_mid_hsu_init,
+			.hw_set_alt = intel_mid_hsu_switch,
+			.hw_set_rts = intel_mid_hsu_rts,
+			.hw_suspend = intel_mid_hsu_suspend,
+			.hw_resume = intel_mid_hsu_resume,
+			.has_alt = 1,
+			.alt = hsu_port_share,
+			.force_suspend = 0,
+		},
+		[hsu_port2] = {
+			.type = debug_port,
+			.index = 2,
+			.name = HSU_DEBUG_PORT,
+			.idle = 2000,
+			.hw_init = intel_mid_hsu_init,
+			.hw_set_alt = intel_mid_hsu_switch,
+			.hw_set_rts = intel_mid_hsu_rts,
+			.hw_suspend = intel_mid_hsu_suspend,
+			.hw_resume = intel_mid_hsu_resume,
+		},
+		[hsu_port_share] = {
+			.type = gps_port,
+			.index = 3,
+			.name = HSU_GPS_PORT,
+			.idle = 100,
+			.hw_init = intel_mid_hsu_init,
+			.hw_set_alt = intel_mid_hsu_switch,
+			.hw_set_rts = intel_mid_hsu_rts,
+			.hw_suspend = intel_mid_hsu_suspend,
+			.hw_resume = intel_mid_hsu_resume,
+			.has_alt = 1,
+			.alt = hsu_port1,
+			.force_suspend = 1,
+		},
+	},
+};
+
+struct hsu_port_pin_cfg *hsu_port_gpio_mux;
+
+static void hsu_port_enable(int port)
+{
+	struct hsu_port_pin_cfg *info = hsu_port_gpio_mux + port;
+
+	if (info->rx_gpio) {
+		lnw_gpio_set_alt(info->rx_gpio, info->rx_alt);
+		gpio_direction_input(info->rx_gpio);
+	}
+	if (info->tx_gpio) {
+		gpio_direction_output(info->tx_gpio, 0);
+		lnw_gpio_set_alt(info->tx_gpio, info->tx_alt);
+
+	}
+	if (info->cts_gpio) {
+		lnw_gpio_set_alt(info->cts_gpio, info->cts_alt);
+		gpio_direction_input(info->cts_gpio);
+	}
+	if (info->rts_gpio) {
+		gpio_direction_output(info->rts_gpio, 0);
+		lnw_gpio_set_alt(info->rts_gpio, info->rts_alt);
+	}
+}
+
+static void hsu_port_disable(int port)
+{
+	struct hsu_port_pin_cfg *info = hsu_port_gpio_mux + port;
+
+	if (info->rx_gpio) {
+		lnw_gpio_set_alt(info->rx_gpio, LNW_GPIO);
+		gpio_direction_input(info->rx_gpio);
+	}
+	if (info->tx_gpio) {
+		lnw_gpio_set_alt(info->tx_gpio, LNW_GPIO);
+		gpio_direction_input(info->tx_gpio);
+	}
+	if (info->cts_gpio) {
+		lnw_gpio_set_alt(info->cts_gpio, LNW_GPIO);
+		gpio_direction_input(info->cts_gpio);
+	}
+	if (info->rts_gpio) {
+		lnw_gpio_set_alt(info->rts_gpio, LNW_GPIO);
+		gpio_direction_input(info->rts_gpio);
+	}
+}
+
+void intel_mid_hsu_suspend(int port, struct device *dev, irq_handler_t wake_isr)
+{
+	int ret;
+	struct hsu_port_pin_cfg *info = hsu_port_gpio_mux + port;
+
+	info->dev = dev;
+	info->wake_isr = wake_isr;
+	if (info->rts_gpio) {
+		gpio_direction_output(info->rts_gpio, 1);
+		lnw_gpio_set_alt(info->rts_gpio, LNW_GPIO);
+	}
+	if (info->wake_gpio) {
+		lnw_gpio_set_alt(info->wake_gpio, LNW_GPIO);
+		gpio_direction_input(info->wake_gpio);
+		udelay(100);
+		ret = request_irq(gpio_to_irq(info->wake_gpio), info->wake_isr,
+				IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING,
+				info->name, info->dev);
+		if (ret)
+			dev_err(info->dev, "failed to register wakeup irq\n");
+	}
+}
+
+void intel_mid_hsu_resume(int port, struct device *dev)
+{
+	struct hsu_port_pin_cfg *info = hsu_port_gpio_mux + port;
+
+	if (info->wake_gpio)
+		free_irq(gpio_to_irq(info->wake_gpio), info->dev);
+
+	hsu_port_enable(port);
+}
+
+void intel_mid_hsu_switch(int port)
+{
+	int i;
+	struct hsu_port_pin_cfg *tmp;
+	struct hsu_port_pin_cfg *info = hsu_port_gpio_mux + port;
+
+	for (i = 0; i < hsu_port_max; i++) {
+		tmp = hsu_port_gpio_mux + i;
+		if (tmp != info && tmp->id == info->id)
+			hsu_port_disable(i);
+	}
+	hsu_port_enable(port);
+}
+
+void intel_mid_hsu_rts(int port, int value)
+{
+	struct hsu_port_pin_cfg *info = hsu_port_gpio_mux + port;
+
+	if (value) {
+		if (info->rts_gpio) {
+			gpio_direction_output(info->rts_gpio, 1);
+			lnw_gpio_set_alt(info->rts_gpio, LNW_GPIO);
+		}
+	} else {
+		if (info->rts_gpio)
+			lnw_gpio_set_alt(info->rts_gpio, info->rts_alt);
+	}
+}
+
+int intel_mid_hsu_init(int port)
+{
+	struct hsu_port_pin_cfg *info;
+	switch (intel_mid_identify_cpu()) {
+	case INTEL_MID_CPU_CHIP_CLOVERVIEW:
+		hsu_port_gpio_mux = &hsu_port_pin_cfgs[hsu_clv][0];
+		break;
+
+	case INTEL_MID_CPU_CHIP_PENWELL:
+	default:
+		hsu_port_gpio_mux = &hsu_port_pin_cfgs[hsu_pnw][0];
+		break;
+	}
+
+	if (hsu_port_gpio_mux == NULL)
+		return -ENODEV;
+
+	if (port >= hsu_port_max)
+		return -ENODEV;
+
+	info = hsu_port_gpio_mux + port;
+	if (info->wake_gpio)
+		gpio_request(info->wake_gpio, "hsu");
+	if (info->rx_gpio)
+		gpio_request(info->rx_gpio, "hsu");
+	if (info->tx_gpio)
+		gpio_request(info->tx_gpio, "hsu");
+	if (info->cts_gpio)
+		gpio_request(info->cts_gpio, "hsu");
+	if (info->rts_gpio)
+		gpio_request(info->rts_gpio, "hsu");
+
+	return 1;
+}
+
+void *hsu_dev_platform_data(void *data)
+{
+	switch (intel_mid_identify_cpu()) {
+	case INTEL_MID_CPU_CHIP_CLOVERVIEW:
+		hsu_register_board_info(&hsu_port_cfgs[hsu_clv][0]);
+		break;
+
+	case INTEL_MID_CPU_CHIP_PENWELL:
+	default:
+		hsu_register_board_info(&hsu_port_cfgs[hsu_pnw][0]);
+		break;
+	}
+}
+arch_initcall(hsu_dev_platform_data);
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_hsu.h b/arch/x86/platform/intel-mid/device_libs/platform_hsu.h
new file mode 100644
index 000000000000..145503762326
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_hsu.h
@@ -0,0 +1,43 @@
+/*
+ * platform_hsu.h: hsu platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_HSU_H_
+#define _PLATFORM_HSU_H_
+
+#define HSU_BT_PORT "hsu_bt_port"
+#define HSU_MODEM_PORT "hsu_modem_port"
+#define HSU_GPS_PORT "hsu_gps_port"
+#define HSU_DEBUG_PORT "hsu_debug_port"
+
+enum hsu_core {
+	hsu_pnw,
+	hsu_clv,
+	hsu_tgr,
+};
+
+struct hsu_port_pin_cfg {
+	char *name;
+	int id;
+	int wake_gpio;
+	int rx_gpio;
+	int rx_alt;
+	int tx_gpio;
+	int tx_alt;
+	int cts_gpio;
+	int cts_alt;
+	int rts_gpio;
+	int rts_alt;
+	struct device *dev;
+	irq_handler_t wake_isr;
+};
+
+extern void *hsu_dev_platform_data(void *data) __attribute__((weak));
+#endif
diff --git a/drivers/tty/serial/mfd.c b/drivers/tty/serial/mfd.c
index 5f4765a7a5c5..185a7843b985 100644
--- a/drivers/tty/serial/mfd.c
+++ b/drivers/tty/serial/mfd.c
@@ -40,8 +40,13 @@
 #include <linux/io.h>
 #include <linux/debugfs.h>
 #include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
+#include <asm/intel_mid_hsu.h>
 
+#define HSU_PORT_MAX		8
 #define HSU_DMA_BUF_SIZE	2048
+#define HSU_Q_MAX		1024
+#define HSU_CL_BUF_LEN		(1 << CONFIG_LOG_BUF_SHIFT)
 
 #define chan_readl(chan, offset)	readl(chan->reg + offset)
 #define chan_writel(chan, offset, val)	writel(val, chan->reg + offset)
@@ -49,11 +54,37 @@
 #define mfd_readl(obj, offset)		readl(obj->reg + offset)
 #define mfd_writel(obj, offset, val)	writel(val, obj->reg + offset)
 
-static int hsu_dma_enable;
+static int hsu_dma_enable = 0x7;
 module_param(hsu_dma_enable, int, 0);
 MODULE_PARM_DESC(hsu_dma_enable,
 		 "It is a bitmap to set working mode, if bit[x] is 1, then port[x] will work in DMA mode, otherwise in PIO mode.");
 
+enum {
+	flag_init = 1,
+	flag_startup,
+	flag_console,
+	flag_suspend,
+	flag_wakeup,
+	flag_set_alt,
+};
+
+enum {
+	qcmd_overflow = 1,
+	qcmd_set_mcr,
+	qcmd_set_ier,
+	qcmd_set_lcr,
+	qcmd_set_speed,
+	qcmd_stop_rx,
+	qcmd_start_tx,
+	qcmd_stop_tx,
+	qcmd_startup,
+	qcmd_shutdown,
+	qcmd_cl,
+	qcmd_set_alt,
+	qcmd_clear_alt,
+	qcmd_reg_port,
+};
+
 struct hsu_dma_buffer {
 	u8		*buf;
 	dma_addr_t	dma_addr;
@@ -70,9 +101,26 @@ struct hsu_dma_chan {
 
 struct uart_hsu_port {
 	struct uart_port        port;
+
+	struct workqueue_struct *workqueue;
+	struct work_struct	work;
+	struct circ_buf		qcirc;
+	int			qbuf[HSU_Q_MAX];
+	struct circ_buf		cl_circ;
+	spinlock_t		cl_lock;
+
+	unsigned char           lsr;
+	unsigned char           msr;
+	unsigned char           dll;
+	unsigned char           dlm;
+	unsigned char		fcr;
 	unsigned char           ier;
 	unsigned char           lcr;
 	unsigned char           mcr;
+
+	unsigned int		mul;
+	unsigned int		ps;
+
 	unsigned int            lsr_break_flag;
 	char			name[12];
 	int			index;
@@ -82,24 +130,105 @@ struct uart_hsu_port {
 	struct hsu_dma_chan	*rxc;
 	struct hsu_dma_buffer	txbuf;
 	struct hsu_dma_buffer	rxbuf;
+	unsigned char		rxc_chcr_save;
 	int			use_dma;	/* flag for DMA/PIO */
 	int			running;
 	int			dma_tx_on;
+	unsigned long		flags;
+	struct pm_qos_request	qos;
 };
 
 /* Top level data structure of HSU */
 struct hsu_port {
+	int dma_irq;
+	int init_completion;
+	struct hsu_port_cfg	*configs[HSU_PORT_MAX];
 	void __iomem	*reg;
-	unsigned long	paddr;
-	unsigned long	iolen;
-	u32		irq;
-
-	struct uart_hsu_port	port[3];
-	struct hsu_dma_chan	chans[10];
-
+	struct uart_hsu_port	port[HSU_PORT_MAX];
+	struct hsu_dma_chan	chans[HSU_PORT_MAX * 2];
 	struct dentry *debugfs;
 };
 
+static struct hsu_port hsu;
+static struct hsu_port *phsu = &hsu;
+static struct uart_driver serial_hsu_reg;
+static struct hsu_port_cfg *hsu_port_func_cfg;
+
+int hsu_register_board_info(void *inf)
+{
+	hsu_port_func_cfg = inf;
+	return 0;
+}
+
+static inline void insert_qcmd(struct uart_hsu_port *up, char cmd)
+{
+	struct circ_buf *circ = &up->qcirc;
+	char *buf;
+
+	buf = circ->buf + circ->head;
+	if (CIRC_SPACE(circ->head, circ->tail, HSU_Q_MAX) < 1)
+		*buf = qcmd_overflow;
+	else {
+		*buf = cmd;
+		circ->head++;
+		if (circ->head == HSU_Q_MAX)
+			circ->head = 0;
+	}
+}
+
+static inline int get_qcmd(struct uart_hsu_port *up, char *cmd)
+{
+	struct circ_buf *circ = &up->qcirc;
+	char *buf;
+
+	if (!CIRC_CNT(circ->head, circ->tail, HSU_Q_MAX))
+		return 0;
+	buf = circ->buf + circ->tail;
+	*cmd = *buf;
+	circ->tail++;
+	if (circ->tail == HSU_Q_MAX)
+		circ->tail = 0;
+	return 1;
+}
+
+static inline void cl_put_char(struct uart_hsu_port *up, char c)
+{
+	struct circ_buf *circ = &up->cl_circ;
+	char *buf;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->cl_lock, flags);
+	buf = circ->buf + circ->head;
+	if (CIRC_SPACE(circ->head, circ->tail, HSU_CL_BUF_LEN) > 1) {
+		*buf = c;
+		circ->head++;
+		if (circ->head == HSU_CL_BUF_LEN)
+			circ->head = 0;
+	}
+	spin_unlock_irqrestore(&up->cl_lock, flags);
+}
+
+static inline int cl_get_char(struct uart_hsu_port *up, char *c)
+{
+	struct circ_buf *circ = &up->cl_circ;
+	char *buf;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->cl_lock, flags);
+	if (!CIRC_CNT(circ->head, circ->tail, HSU_CL_BUF_LEN)) {
+		spin_unlock_irqrestore(&up->cl_lock, flags);
+		return 0;
+	}
+	buf = circ->buf + circ->tail;
+	*c = *buf;
+	circ->tail++;
+	if (circ->tail == HSU_CL_BUF_LEN)
+		circ->tail = 0;
+	spin_unlock_irqrestore(&up->cl_lock, flags);
+	return 1;
+}
+
+
 static inline unsigned int serial_in(struct uart_hsu_port *up, int offset)
 {
 	unsigned int val;
@@ -124,10 +253,49 @@ static inline void serial_out(struct uart_hsu_port *up, int offset, int value)
 	}
 }
 
+static void serial_set_alt(int index)
+{
+	struct uart_hsu_port *up = phsu->port + index;
+	struct hsu_dma_chan *txc = up->txc;
+	struct hsu_dma_chan *rxc = up->rxc;
+	struct hsu_port_cfg *cfg = phsu->configs[index];
+	struct pci_dev *pdev = container_of(up->dev, struct pci_dev, dev);
+
+	if (test_bit(flag_set_alt, &up->flags))
+		return;
+
+	txc->uport = up;
+	rxc->uport = up;
+	pci_set_drvdata(pdev, up);
+	if (cfg->hw_set_alt)
+		cfg->hw_set_alt(index);
+	if (cfg->hw_set_rts)
+		cfg->hw_set_rts(up->index, 0);
+	set_bit(flag_set_alt, &up->flags);
+}
+
+static void serial_clear_alt(int index)
+{
+	struct uart_hsu_port *up = phsu->port + index;
+	struct hsu_port_cfg *cfg = phsu->configs[index];
+
+	if (!test_bit(flag_set_alt, &up->flags))
+		return;
+
+	if (cfg->hw_set_rts)
+		cfg->hw_set_rts(up->index, 1);
+	clear_bit(flag_set_alt, &up->flags);
+}
+
 #ifdef CONFIG_DEBUG_FS
 
 #define HSU_REGS_BUFSIZE	1024
 
+static int hsu_show_regs_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
 
 static ssize_t port_show_regs(struct file *file, char __user *user_buf,
 				size_t count, loff_t *ppos)
@@ -227,14 +395,14 @@ static ssize_t dma_show_regs(struct file *file, char __user *user_buf,
 
 static const struct file_operations port_regs_ops = {
 	.owner		= THIS_MODULE,
-	.open		= simple_open,
+	.open		= hsu_show_regs_open,
 	.read		= port_show_regs,
 	.llseek		= default_llseek,
 };
 
 static const struct file_operations dma_regs_ops = {
 	.owner		= THIS_MODULE,
-	.open		= simple_open,
+	.open		= hsu_show_regs_open,
 	.read		= dma_show_regs,
 	.llseek		= default_llseek,
 };
@@ -286,7 +454,8 @@ static void serial_hsu_enable_ms(struct uart_port *port)
 		container_of(port, struct uart_hsu_port, port);
 
 	up->ier |= UART_IER_MSI;
-	serial_out(up, UART_IER, up->ier);
+	insert_qcmd(up, qcmd_set_ier);
+	queue_work(up->workqueue, &up->work);
 }
 
 void hsu_dma_tx(struct uart_hsu_port *up)
@@ -325,8 +494,7 @@ void hsu_dma_tx(struct uart_hsu_port *up)
 		/* Reenable the channel */
 		chan_writel(up->txc, HSU_CH_DCR, 0x1
 						 | (0x1 << 8)
-						 | (0x1 << 16)
-						 | (0x1 << 24));
+						 | (0x1 << 16));
 		up->dma_tx_on = 1;
 		chan_writel(up->txc, HSU_CH_CR, 0x1);
 	}
@@ -336,7 +504,8 @@ void hsu_dma_tx(struct uart_hsu_port *up)
 }
 
 /* The buffer is already cache coherent */
-void hsu_dma_start_rx_chan(struct hsu_dma_chan *rxc, struct hsu_dma_buffer *dbuf)
+void hsu_dma_start_rx_chan(struct hsu_dma_chan *rxc,
+			struct hsu_dma_buffer *dbuf)
 {
 	dbuf->ofs = 0;
 
@@ -358,26 +527,17 @@ static void serial_hsu_start_tx(struct uart_port *port)
 	struct uart_hsu_port *up =
 		container_of(port, struct uart_hsu_port, port);
 
-	if (up->use_dma) {
-		hsu_dma_tx(up);
-	} else if (!(up->ier & UART_IER_THRI)) {
-		up->ier |= UART_IER_THRI;
-		serial_out(up, UART_IER, up->ier);
-	}
+	insert_qcmd(up, qcmd_start_tx);
+	queue_work(up->workqueue, &up->work);
 }
 
 static void serial_hsu_stop_tx(struct uart_port *port)
 {
 	struct uart_hsu_port *up =
 		container_of(port, struct uart_hsu_port, port);
-	struct hsu_dma_chan *txc = up->txc;
 
-	if (up->use_dma)
-		chan_writel(txc, HSU_CH_CR, 0x0);
-	else if (up->ier & UART_IER_THRI) {
-		up->ier &= ~UART_IER_THRI;
-		serial_out(up, UART_IER, up->ier);
-	}
+	insert_qcmd(up, qcmd_stop_tx);
+	queue_work(up->workqueue, &up->work);
 }
 
 /* This is always called in spinlock protected mode, so
@@ -444,15 +604,9 @@ static void serial_hsu_stop_rx(struct uart_port *port)
 {
 	struct uart_hsu_port *up =
 		container_of(port, struct uart_hsu_port, port);
-	struct hsu_dma_chan *chan = up->rxc;
 
-	if (up->use_dma)
-		chan_writel(chan, HSU_CH_CR, 0x2);
-	else {
-		up->ier &= ~UART_IER_RLSI;
-		up->port.read_status_mask &= ~UART_LSR_DR;
-		serial_out(up, UART_IER, up->ier);
-	}
+	insert_qcmd(up, qcmd_stop_rx);
+	queue_work(up->workqueue, &up->work);
 }
 
 static inline void receive_chars(struct uart_hsu_port *up, int *status)
@@ -585,6 +739,9 @@ static irqreturn_t port_irq(int irq, void *dev_id)
 	unsigned int iir, lsr;
 	unsigned long flags;
 
+	if (unlikely(!test_bit(flag_set_alt, &up->flags)))
+		return IRQ_NONE;
+
 	if (unlikely(!up->running))
 		return IRQ_NONE;
 
@@ -674,26 +831,17 @@ static unsigned int serial_hsu_tx_empty(struct uart_port *port)
 {
 	struct uart_hsu_port *up =
 		container_of(port, struct uart_hsu_port, port);
-	unsigned long flags;
-	unsigned int ret;
 
-	spin_lock_irqsave(&up->port.lock, flags);
-	ret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
-	spin_unlock_irqrestore(&up->port.lock, flags);
-
-	return ret;
+	return  up->lsr & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
 }
 
 static unsigned int serial_hsu_get_mctrl(struct uart_port *port)
 {
 	struct uart_hsu_port *up =
 		container_of(port, struct uart_hsu_port, port);
-	unsigned char status;
-	unsigned int ret;
+	unsigned char status = up->msr;
+	unsigned int ret = 0;
 
-	status = serial_in(up, UART_MSR);
-
-	ret = 0;
 	if (status & UART_MSR_DCD)
 		ret |= TIOCM_CAR;
 	if (status & UART_MSR_RI)
@@ -709,22 +857,19 @@ static void serial_hsu_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
 	struct uart_hsu_port *up =
 		container_of(port, struct uart_hsu_port, port);
-	unsigned char mcr = 0;
 
 	if (mctrl & TIOCM_RTS)
-		mcr |= UART_MCR_RTS;
+		up->mcr |= UART_MCR_RTS;
 	if (mctrl & TIOCM_DTR)
-		mcr |= UART_MCR_DTR;
+		up->mcr |= UART_MCR_DTR;
 	if (mctrl & TIOCM_OUT1)
-		mcr |= UART_MCR_OUT1;
+		up->mcr |= UART_MCR_OUT1;
 	if (mctrl & TIOCM_OUT2)
-		mcr |= UART_MCR_OUT2;
+		up->mcr |= UART_MCR_OUT2;
 	if (mctrl & TIOCM_LOOP)
-		mcr |= UART_MCR_LOOP;
-
-	mcr |= up->mcr;
-
-	serial_out(up, UART_MCR, mcr);
+		up->mcr |= UART_MCR_LOOP;
+	insert_qcmd(up, qcmd_set_mcr);
+	queue_work(up->workqueue, &up->work);
 }
 
 static void serial_hsu_break_ctl(struct uart_port *port, int break_state)
@@ -738,7 +883,8 @@ static void serial_hsu_break_ctl(struct uart_port *port, int break_state)
 		up->lcr |= UART_LCR_SBC;
 	else
 		up->lcr &= ~UART_LCR_SBC;
-	serial_out(up, UART_LCR, up->lcr);
+	insert_qcmd(up, qcmd_set_lcr);
+	queue_work(up->workqueue, &up->work);
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
@@ -750,121 +896,70 @@ static void serial_hsu_break_ctl(struct uart_port *port, int break_state)
  */
 static int serial_hsu_startup(struct uart_port *port)
 {
+	int run_cnt = 0;
+	static DEFINE_MUTEX(lock);
 	struct uart_hsu_port *up =
 		container_of(port, struct uart_hsu_port, port);
-	unsigned long flags;
-
-	pm_runtime_get_sync(up->dev);
-
-	/*
-	 * Clear the FIFO buffers and disable them.
-	 * (they will be reenabled in set_termios())
-	 */
-	serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-	serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |
-			UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
-	serial_out(up, UART_FCR, 0);
-
-	/* Clear the interrupt registers. */
-	(void) serial_in(up, UART_LSR);
-	(void) serial_in(up, UART_RX);
-	(void) serial_in(up, UART_IIR);
-	(void) serial_in(up, UART_MSR);
-
-	/* Now, initialize the UART, default is 8n1 */
-	serial_out(up, UART_LCR, UART_LCR_WLEN8);
-
-	spin_lock_irqsave(&up->port.lock, flags);
-
-	up->port.mctrl |= TIOCM_OUT2;
-	serial_hsu_set_mctrl(&up->port, up->port.mctrl);
-
-	/*
-	 * Finally, enable interrupts.  Note: Modem status interrupts
-	 * are set via set_termios(), which will be occurring imminently
-	 * anyway, so we don't enable them here.
-	 */
-	if (!up->use_dma)
-		up->ier = UART_IER_RLSI | UART_IER_RDI | UART_IER_RTOIE;
-	else
-		up->ier = 0;
-	serial_out(up, UART_IER, up->ier);
-
-	spin_unlock_irqrestore(&up->port.lock, flags);
-
-	/* DMA init */
-	if (up->use_dma) {
-		struct hsu_dma_buffer *dbuf;
-		struct circ_buf *xmit = &port->state->xmit;
-
-		up->dma_tx_on = 0;
-
-		/* First allocate the RX buffer */
-		dbuf = &up->rxbuf;
-		dbuf->buf = kzalloc(HSU_DMA_BUF_SIZE, GFP_KERNEL);
-		if (!dbuf->buf) {
-			up->use_dma = 0;
-			goto exit;
+	struct hsu_port_cfg *cfg = phsu->configs[up->index];
+
+	mutex_lock(&lock);
+	if (cfg->has_alt) {
+		struct hsu_port_cfg *alt_cfg = hsu_port_func_cfg + cfg->alt;
+		struct uart_hsu_port *alt_up = phsu->port + alt_cfg->index;
+
+		if (alt_up->running && alt_cfg->force_suspend) {
+			uart_suspend_port(&serial_hsu_reg, &alt_up->port);
+		} else {
+			while (alt_up->running) {
+				msleep(20);
+				if (++run_cnt >= 50) {
+					dev_warn(up->dev, "waite alt port %d 1S\n",
+						 alt_up->index);
+					run_cnt = 0;
+				}
+			}
 		}
-		dbuf->dma_addr = dma_map_single(port->dev,
-						dbuf->buf,
-						HSU_DMA_BUF_SIZE,
-						DMA_FROM_DEVICE);
-		dbuf->dma_size = HSU_DMA_BUF_SIZE;
-
-		/* Start the RX channel right now */
-		hsu_dma_start_rx_chan(up->rxc, dbuf);
-
-		/* Next init the TX DMA */
-		dbuf = &up->txbuf;
-		dbuf->buf = xmit->buf;
-		dbuf->dma_addr = dma_map_single(port->dev,
-					       dbuf->buf,
-					       UART_XMIT_SIZE,
-					       DMA_TO_DEVICE);
-		dbuf->dma_size = UART_XMIT_SIZE;
-
-		/* This should not be changed all around */
-		chan_writel(up->txc, HSU_CH_BSR, 32);
-		chan_writel(up->txc, HSU_CH_MOTSR, 4);
-		dbuf->ofs = 0;
+		insert_qcmd(alt_up, qcmd_clear_alt);
+		queue_work(alt_up->workqueue, &alt_up->work);
+		flush_workqueue(alt_up->workqueue);
 	}
-
-exit:
-	 /* And clear the interrupt registers again for luck. */
-	(void) serial_in(up, UART_LSR);
-	(void) serial_in(up, UART_RX);
-	(void) serial_in(up, UART_IIR);
-	(void) serial_in(up, UART_MSR);
-
+	insert_qcmd(up, qcmd_set_alt);
+	queue_work(up->workqueue, &up->work);
 	up->running = 1;
+	mutex_unlock(&lock);
+
+	insert_qcmd(up, qcmd_startup);
+	queue_work(up->workqueue, &up->work);
+	flush_workqueue(up->workqueue);
 	return 0;
 }
 
 static void serial_hsu_shutdown(struct uart_port *port)
 {
+	static DEFINE_MUTEX(lock);
 	struct uart_hsu_port *up =
 		container_of(port, struct uart_hsu_port, port);
-	unsigned long flags;
-
-	/* Disable interrupts from this port */
-	up->ier = 0;
-	serial_out(up, UART_IER, 0);
-	up->running = 0;
-
-	spin_lock_irqsave(&up->port.lock, flags);
-	up->port.mctrl &= ~TIOCM_OUT2;
-	serial_hsu_set_mctrl(&up->port, up->port.mctrl);
-	spin_unlock_irqrestore(&up->port.lock, flags);
-
-	/* Disable break condition and FIFOs */
-	serial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);
-	serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |
-				  UART_FCR_CLEAR_RCVR |
-				  UART_FCR_CLEAR_XMIT);
-	serial_out(up, UART_FCR, 0);
-
-	pm_runtime_put(up->dev);
+	struct hsu_port_cfg *cfg = phsu->configs[up->index];
+
+	insert_qcmd(up, qcmd_shutdown);
+	insert_qcmd(up, qcmd_clear_alt);
+	queue_work(up->workqueue, &up->work);
+	flush_workqueue(up->workqueue);
+
+	mutex_lock(&lock);
+	if (cfg->has_alt) {
+		struct hsu_port_cfg *alt_cfg = hsu_port_func_cfg + cfg->alt;
+		struct uart_hsu_port *alt_up = phsu->port + alt_cfg->index;
+
+		if (alt_up->running) {
+			insert_qcmd(alt_up, qcmd_set_alt);
+			queue_work(alt_up->workqueue, &alt_up->work);
+			uart_resume_port(&serial_hsu_reg, &alt_up->port);
+		}
+	}
+	if (!test_bit(flag_console, &up->flags))
+		up->running = 0;
+	mutex_unlock(&lock);
 }
 
 static void
@@ -993,23 +1088,21 @@ serial_hsu_set_termios(struct uart_port *port, struct ktermios *termios,
 	up->ier &= ~UART_IER_MSI;
 	if (UART_ENABLE_MS(&up->port, termios->c_cflag))
 		up->ier |= UART_IER_MSI;
-
-	serial_out(up, UART_IER, up->ier);
+	insert_qcmd(up, qcmd_set_ier);
 
 	if (termios->c_cflag & CRTSCTS)
 		up->mcr |= UART_MCR_AFE | UART_MCR_RTS;
 	else
 		up->mcr &= ~UART_MCR_AFE;
-
-	serial_out(up, UART_LCR, cval | UART_LCR_DLAB);	/* set DLAB */
-	serial_out(up, UART_DLL, quot & 0xff);		/* LS of divisor */
-	serial_out(up, UART_DLM, quot >> 8);		/* MS of divisor */
-	serial_out(up, UART_LCR, cval);			/* reset DLAB */
-	serial_out(up, UART_MUL, mul);			/* set MUL */
-	serial_out(up, UART_PS, ps);			/* set PS */
-	up->lcr = cval;					/* Save LCR */
+	up->lcr = cval;
+	up->dll = quot & 0xff;
+	up->dlm = quot >> 8;
+	up->mul = mul;
+	up->ps = ps;
+	up->fcr = fcr;
+	insert_qcmd(up, qcmd_set_speed);
+	queue_work(up->workqueue, &up->work);
 	serial_hsu_set_mctrl(&up->port, up->port.mctrl);
-	serial_out(up, UART_FCR, fcr);
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
@@ -1050,10 +1143,6 @@ serial_hsu_type(struct uart_port *port)
 	return up->name;
 }
 
-/* Mainly for uart console use */
-static struct uart_hsu_port *serial_hsu_ports[3];
-static struct uart_driver serial_hsu_reg;
-
 #ifdef CONFIG_SERIAL_MFD_HSU_CONSOLE
 
 #define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
@@ -1088,9 +1177,7 @@ static void serial_hsu_console_putchar(struct uart_port *port, int ch)
 {
 	struct uart_hsu_port *up =
 		container_of(port, struct uart_hsu_port, port);
-
-	wait_for_xmitr(up);
-	serial_out(up, UART_TX, ch);
+	cl_put_char(up, ch);
 }
 
 /*
@@ -1102,37 +1189,14 @@ static void serial_hsu_console_putchar(struct uart_port *port, int ch)
 static void
 serial_hsu_console_write(struct console *co, const char *s, unsigned int count)
 {
-	struct uart_hsu_port *up = serial_hsu_ports[co->index];
+	struct uart_hsu_port *up = phsu->port + co->index;
 	unsigned long flags;
-	unsigned int ier;
-	int locked = 1;
-
-	touch_nmi_watchdog();
-
-	local_irq_save(flags);
-	if (up->port.sysrq)
-		locked = 0;
-	else if (oops_in_progress) {
-		locked = spin_trylock(&up->port.lock);
-	} else
-		spin_lock(&up->port.lock);
-
-	/* First save the IER then disable the interrupts */
-	ier = serial_in(up, UART_IER);
-	serial_out(up, UART_IER, 0);
 
 	uart_console_write(&up->port, s, count, serial_hsu_console_putchar);
-
-	/*
-	 * Finally, wait for transmitter to become empty
-	 * and restore the IER
-	 */
-	wait_for_xmitr(up);
-	serial_out(up, UART_IER, ier);
-
-	if (locked)
-		spin_unlock(&up->port.lock);
-	local_irq_restore(flags);
+	spin_lock_irqsave(&up->cl_lock, flags);
+	insert_qcmd(up, qcmd_cl);
+	spin_unlock_irqrestore(&up->cl_lock, flags);
+	queue_work(up->workqueue, &up->work);
 }
 
 static struct console serial_hsu_console;
@@ -1140,21 +1204,25 @@ static struct console serial_hsu_console;
 static int __init
 serial_hsu_console_setup(struct console *co, char *options)
 {
-	struct uart_hsu_port *up;
+	struct uart_hsu_port *up = phsu->port + co->index;
 	int baud = 115200;
 	int bits = 8;
 	int parity = 'n';
 	int flow = 'n';
 
-	if (co->index == -1 || co->index >= serial_hsu_reg.nr)
-		co->index = 0;
-	up = serial_hsu_ports[co->index];
-	if (!up)
+	if (co->index < 0 || co->index >= hsu_port_max)
 		return -ENODEV;
 
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
 
+	set_bit(flag_console, &up->flags);
+	up->running = 1;
+	insert_qcmd(up, qcmd_set_alt);
+	queue_work(up->workqueue, &up->work);
+	up->cl_circ.buf = kzalloc(HSU_CL_BUF_LEN, GFP_KERNEL);
+	if (up->cl_circ.buf == NULL)
+		return -ENOMEM;
 	return uart_set_options(&up->port, co, baud, parity, bits, flow);
 }
 
@@ -1199,47 +1267,66 @@ static struct uart_driver serial_hsu_reg = {
 	.dev_name	= "ttyMFD",
 	.major		= TTY_MAJOR,
 	.minor		= 128,
-	.nr		= 3,
-	.cons		= SERIAL_HSU_CONSOLE,
+	.nr		= HSU_PORT_MAX,
 };
 
-#ifdef CONFIG_PM
-static int serial_hsu_suspend(struct pci_dev *pdev, pm_message_t state)
+static irqreturn_t wakeup_irq(int irq, void *dev)
 {
-	void *priv = pci_get_drvdata(pdev);
-	struct uart_hsu_port *up;
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	struct uart_hsu_port *up = pci_get_drvdata(pdev);
 
-	/* Make sure this is not the internal dma controller */
-	if (priv && (pdev->device != 0x081E)) {
-		up = priv;
-		uart_suspend_port(&serial_hsu_reg, &up->port);
-	}
-
-	pci_save_state(pdev);
-	pci_set_power_state(pdev, pci_choose_state(pdev, state));
-        return 0;
+	set_bit(flag_wakeup, &up->flags);
+	pm_runtime_get(dev);
+	pm_runtime_put(dev);
+	return IRQ_HANDLED;
 }
 
-static int serial_hsu_resume(struct pci_dev *pdev)
+#if defined(CONFIG_PM) || defined(CONFIG_PM_RUNTIME)
+static int serial_hsu_do_suspend(struct pci_dev *pdev)
 {
-	void *priv = pci_get_drvdata(pdev);
-	struct uart_hsu_port *up;
-	int ret;
+	struct uart_hsu_port *up = pci_get_drvdata(pdev);
+	struct hsu_port_cfg *cfg = phsu->configs[up->index];
 
-	pci_set_power_state(pdev, PCI_D0);
-	pci_restore_state(pdev);
+	if (unlikely(!phsu->init_completion))
+		return -EBUSY;
 
-	ret = pci_enable_device(pdev);
-	if (ret)
-		dev_warn(&pdev->dev,
-			"HSU: can't re-enable device, try to continue\n");
+	if (cfg->hw_set_rts)
+		cfg->hw_set_rts(up->index, 1);
+	disable_irq(up->port.irq);
+	up->rxc_chcr_save = chan_readl(up->rxc, HSU_CH_CR);
+	chan_writel(up->rxc, HSU_CH_CR, 0x2);
+	udelay(10);
+	synchronize_irq(phsu->dma_irq);
+	if (cfg->hw_suspend)
+		cfg->hw_suspend(up->index, &pdev->dev, wakeup_irq);
+	return 0;
+}
 
-	if (priv && (pdev->device != 0x081E)) {
-		up = priv;
-		uart_resume_port(&serial_hsu_reg, &up->port);
-	}
+static int serial_hsu_do_resume(struct pci_dev *pdev)
+{
+	struct uart_hsu_port *up = pci_get_drvdata(pdev);
+	struct hsu_port_cfg *cfg = phsu->configs[up->index];
+
+	if (cfg->hw_resume)
+		cfg->hw_resume(up->index, &pdev->dev);
+	if (cfg->hw_set_rts)
+		cfg->hw_set_rts(up->index, 0);
+	enable_irq(up->port.irq);
+	chan_writel(up->rxc, HSU_CH_CR, up->rxc_chcr_save);
 	return 0;
 }
+#endif
+
+#ifdef CONFIG_PM
+static int serial_hsu_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	return serial_hsu_do_suspend(pdev);
+}
+
+static int serial_hsu_resume(struct pci_dev *pdev)
+{
+	return serial_hsu_do_resume(pdev);
+}
 #else
 #define serial_hsu_suspend	NULL
 #define serial_hsu_resume	NULL
@@ -1248,23 +1335,31 @@ static int serial_hsu_resume(struct pci_dev *pdev)
 #ifdef CONFIG_PM_RUNTIME
 static int serial_hsu_runtime_idle(struct device *dev)
 {
-	int err;
-
-	err = pm_schedule_suspend(dev, 500);
-	if (err)
-		return -EBUSY;
-
-	return 0;
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	struct uart_hsu_port *up = pci_get_drvdata(pdev);
+	struct hsu_port_cfg *cfg = phsu->configs[up->index];
+
+	if (test_bit(flag_console, &up->flags) &&
+		test_bit(flag_wakeup, &up->flags)) {
+		pm_schedule_suspend(dev, 2000);
+		clear_bit(flag_wakeup, &up->flags);
+	} else
+		pm_schedule_suspend(dev, cfg->idle);
+	return -EBUSY;
 }
 
 static int serial_hsu_runtime_suspend(struct device *dev)
 {
-	return 0;
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+
+	return serial_hsu_do_suspend(pdev);
 }
 
 static int serial_hsu_runtime_resume(struct device *dev)
 {
-	return 0;
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+
+	return serial_hsu_do_resume(pdev);
 }
 #else
 #define serial_hsu_runtime_idle		NULL
@@ -1272,161 +1367,344 @@ static int serial_hsu_runtime_resume(struct device *dev)
 #define serial_hsu_runtime_resume	NULL
 #endif
 
+static void serial_hsu_work(struct work_struct *work)
+{
+	struct uart_hsu_port *up =
+		container_of(work, struct uart_hsu_port, work);
+	char cmd, c;
+	unsigned long flags;
+
+	while (unlikely(!phsu->init_completion))
+		msleep(100);
+	pm_qos_add_request(&up->qos,
+			PM_QOS_CPU_DMA_LATENCY,	1040-1);
+	pm_runtime_get_sync(up->dev);
+	spin_lock_irqsave(&up->port.lock, flags);
+	while (get_qcmd(up, &cmd)) {
+		spin_unlock_irqrestore(&up->port.lock, flags);
+		switch (cmd) {
+		case qcmd_overflow:
+			dev_err(up->dev, "queue overflow!!\n");
+			break;
+		case qcmd_set_mcr:
+			serial_out(up, UART_MCR, up->mcr);
+			break;
+		case qcmd_set_ier:
+			serial_out(up, UART_IER, up->ier);
+			break;
+		case qcmd_set_lcr:
+			serial_out(up, UART_LCR, up->lcr);
+			break;
+		case qcmd_set_speed:
+			serial_out(up, UART_LCR, up->lcr | UART_LCR_DLAB);
+			serial_out(up, UART_DLL, up->dll);
+			serial_out(up, UART_DLM, up->dlm);
+			serial_out(up, UART_LCR, up->lcr);
+			serial_out(up, UART_MUL, up->mul);
+			serial_out(up, UART_PS, up->ps);
+			serial_out(up, UART_FCR, up->fcr);
+			break;
+		case qcmd_stop_rx:
+			if (up->use_dma) {
+				chan_writel(up->rxc, HSU_CH_CR, 0x2);
+			} else {
+				up->ier &= ~UART_IER_RLSI;
+				up->port.read_status_mask &= ~UART_LSR_DR;
+				serial_out(up, UART_IER, up->ier);
+			}
+			break;
+		case qcmd_start_tx:
+			if (up->use_dma) {
+				hsu_dma_tx(up);
+			} else if (!(up->ier & UART_IER_THRI)) {
+				up->ier |= UART_IER_THRI;
+				serial_out(up, UART_IER, up->ier);
+			}
+			break;
+		case qcmd_stop_tx:
+			if (up->use_dma)
+				chan_writel(up->txc, HSU_CH_CR, 0x0);
+			else if (up->ier & UART_IER_THRI) {
+				up->ier &= ~UART_IER_THRI;
+				serial_out(up, UART_IER, up->ier);
+			}
+			break;
+		case qcmd_startup:
+			/*
+			 * Clear the FIFO buffers and disable them.
+			 * (they will be reenabled in set_termios())
+			 */
+			serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);
+			serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |
+					UART_FCR_CLEAR_RCVR |
+					UART_FCR_CLEAR_XMIT);
+			serial_out(up, UART_FCR, 0);
+			up->fcr = 0;
+
+			/* Clear the interrupt registers. */
+			(void) serial_in(up, UART_LSR);
+			(void) serial_in(up, UART_RX);
+			(void) serial_in(up, UART_IIR);
+			(void) serial_in(up, UART_MSR);
+
+			/* Now, initialize the UART, default is 8n1 */
+			serial_out(up, UART_LCR, UART_LCR_WLEN8);
+			up->lcr = UART_LCR_WLEN8;
+
+			up->port.mctrl |= TIOCM_OUT2;
+			serial_hsu_set_mctrl(&up->port, up->port.mctrl);
+
+			/*
+			 * Finally, enable interrupts.  Note: Modem status
+			 * interrupts are set via set_termios(), which will
+			 *  be occurring imminently
+			 * anyway, so we don't enable them here.
+			 */
+			if (!up->use_dma)
+				up->ier = UART_IER_RLSI | UART_IER_RDI |
+						UART_IER_RTOIE;
+			else
+				up->ier = 0;
+			serial_out(up, UART_IER, up->ier);
+
+			/* DMA init */
+			if (up->use_dma) {
+				struct hsu_dma_buffer *dbuf;
+				struct circ_buf *xmit = &up->port.state->xmit;
+
+				up->dma_tx_on = 0;
+
+				/* First allocate the RX buffer */
+				dbuf = &up->rxbuf;
+				dbuf->buf = kzalloc(HSU_DMA_BUF_SIZE,
+							GFP_KERNEL);
+				if (!dbuf->buf) {
+					up->use_dma = 0;
+					dev_err(up->dev, "allocate DMA buffer failed!!\n");
+					break;
+				}
+				dbuf->dma_addr = dma_map_single(up->dev,
+						dbuf->buf,
+						HSU_DMA_BUF_SIZE,
+						DMA_FROM_DEVICE);
+				dbuf->dma_size = HSU_DMA_BUF_SIZE;
+
+				/* Start the RX channel right now */
+				hsu_dma_start_rx_chan(up->rxc, dbuf);
+
+				/* Next init the TX DMA */
+				dbuf = &up->txbuf;
+				dbuf->buf = xmit->buf;
+				dbuf->dma_addr = dma_map_single(up->dev,
+						dbuf->buf,
+						UART_XMIT_SIZE,
+						DMA_TO_DEVICE);
+				dbuf->dma_size = UART_XMIT_SIZE;
+
+				/* This should not be changed all around */
+				chan_writel(up->txc, HSU_CH_BSR, 32);
+				chan_writel(up->txc, HSU_CH_MOTSR, 4);
+				dbuf->ofs = 0;
+			}
+
+			/* And clear the interrupt registers again for luck. */
+			(void) serial_in(up, UART_LSR);
+			(void) serial_in(up, UART_RX);
+			(void) serial_in(up, UART_IIR);
+			(void) serial_in(up, UART_MSR);
+
+			break;
+		case qcmd_shutdown:
+			/* Disable interrupts from this port */
+			up->ier = 0;
+			serial_out(up, UART_IER, 0);
+
+			up->port.mctrl &= ~TIOCM_OUT2;
+			serial_hsu_set_mctrl(&up->port, up->port.mctrl);
+
+			/* Disable break condition and FIFOs */
+			serial_out(up, UART_LCR,
+				serial_in(up, UART_LCR) & ~UART_LCR_SBC);
+			serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |
+					UART_FCR_CLEAR_RCVR |
+					UART_FCR_CLEAR_XMIT);
+			serial_out(up, UART_FCR, 0);
+			up->fcr = 0;
+			break;
+		case qcmd_cl:
+			serial_out(up, UART_IER, 0);
+			while (cl_get_char(up, &c)) {
+				wait_for_xmitr(up);
+				serial_out(up, UART_TX, c);
+			}
+			serial_out(up, UART_IER, up->ier);
+			break;
+		case qcmd_set_alt:
+			serial_set_alt(up->index);
+			break;
+		case qcmd_clear_alt:
+			serial_clear_alt(up->index);
+			break;
+		default:
+			dev_err(up->dev, "invalid command!!\n");
+			break;
+		}
+		spin_lock_irqsave(&up->port.lock, flags);
+	}
+	up->lsr = serial_in(up, UART_LSR);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+	pm_runtime_put(up->dev);
+	pm_qos_remove_request(&up->qos);
+}
+
 static const struct dev_pm_ops serial_hsu_pm_ops = {
 	.runtime_suspend = serial_hsu_runtime_suspend,
 	.runtime_resume = serial_hsu_runtime_resume,
 	.runtime_idle = serial_hsu_runtime_idle,
 };
 
-/* temp global pointer before we settle down on using one or four PCI dev */
-static struct hsu_port *phsu;
-
 static int serial_hsu_probe(struct pci_dev *pdev,
 				const struct pci_device_id *ent)
 {
 	struct uart_hsu_port *uport;
-	int index, ret;
+	struct hsu_dma_chan *dchan;
+	int i, index, ret;
 
 	printk(KERN_INFO "HSU: found PCI Serial controller(ID: %04x:%04x)\n",
 		pdev->vendor, pdev->device);
 
-	switch (pdev->device) {
-	case 0x081B:
-		index = 0;
-		break;
-	case 0x081C:
-		index = 1;
-		break;
-	case 0x081D:
-		index = 2;
-		break;
-	case 0x081E:
-		/* internal DMA controller */
-		index = 3;
-		break;
-	default:
-		dev_err(&pdev->dev, "HSU: out of index!");
-		return -ENODEV;
-	}
-
 	ret = pci_enable_device(pdev);
 	if (ret)
 		return ret;
 
-	if (index == 3) {
-		/* DMA controller */
-		ret = request_irq(pdev->irq, dma_irq, 0, "hsu_dma", phsu);
+	if (ent->driver_data == hsu_dma) {
+		ret = pci_request_region(pdev, 0, "hsu dma");
+		if (ret)
+			goto err_disable;
+
+		phsu->reg = ioremap_nocache(pci_resource_start(pdev, 0),
+						pci_resource_len(pdev, 0));
+		dchan = phsu->chans;
+		for (i = 0; i < 6; i++) {
+			dchan->id = i;
+			dchan->dirt = (i & 0x1) ? DMA_FROM_DEVICE :
+						DMA_TO_DEVICE;
+			dchan->uport = &phsu->port[i/2];
+			dchan->reg = phsu->reg + HSU_DMA_CHANS_REG_OFFSET +
+					i * HSU_DMA_CHANS_REG_LENGTH;
+
+			dchan++;
+		}
+		phsu->dma_irq = pdev->irq;
+		ret = request_irq(pdev->irq, dma_irq, 0, "hsu dma", phsu);
 		if (ret) {
 			dev_err(&pdev->dev, "can not get IRQ\n");
 			goto err_disable;
 		}
 		pci_set_drvdata(pdev, phsu);
+		phsu->init_completion = 1;
 	} else {
-		/* UART port 0~2 */
-		uport = &phsu->port[index];
-		uport->port.irq = pdev->irq;
-		uport->port.dev = &pdev->dev;
-		uport->dev = &pdev->dev;
+		struct hsu_port_cfg *cfg = hsu_port_func_cfg + ent->driver_data;
+		index = cfg->index;
+		phsu->configs[index] = cfg;
+		uport = phsu->port + index;
 
-		ret = request_irq(pdev->irq, port_irq, 0, uport->name, uport);
-		if (ret) {
-			dev_err(&pdev->dev, "can not get IRQ\n");
+		ret = pci_request_region(pdev, 0, cfg->name);
+		if (ret)
 			goto err_disable;
-		}
-		uart_add_one_port(&serial_hsu_reg, &uport->port);
-
-		pci_set_drvdata(pdev, uport);
-	}
-
-	pm_runtime_put_noidle(&pdev->dev);
-	pm_runtime_allow(&pdev->dev);
-
-	return 0;
-
-err_disable:
-	pci_disable_device(pdev);
-	return ret;
-}
-
-static void hsu_global_init(void)
-{
-	struct hsu_port *hsu;
-	struct uart_hsu_port *uport;
-	struct hsu_dma_chan *dchan;
-	int i, ret;
-
-	hsu = kzalloc(sizeof(struct hsu_port), GFP_KERNEL);
-	if (!hsu)
-		return;
 
-	/* Get basic io resource and map it */
-	hsu->paddr = 0xffa28000;
-	hsu->iolen = 0x1000;
+		if (cfg->hw_init)
+			cfg->hw_init(index);
 
-	if (!(request_mem_region(hsu->paddr, hsu->iolen, "HSU global")))
-		pr_warning("HSU: error in request mem region\n");
-
-	hsu->reg = ioremap_nocache((unsigned long)hsu->paddr, hsu->iolen);
-	if (!hsu->reg) {
-		pr_err("HSU: error in ioremap\n");
-		ret = -ENOMEM;
-		goto err_free_region;
-	}
-
-	/* Initialise the 3 UART ports */
-	uport = hsu->port;
-	for (i = 0; i < 3; i++) {
+		uport->dev = &pdev->dev;
 		uport->port.type = PORT_MFD;
 		uport->port.iotype = UPIO_MEM;
-		uport->port.mapbase = (resource_size_t)hsu->paddr
-					+ HSU_PORT_REG_OFFSET
-					+ i * HSU_PORT_REG_LENGTH;
-		uport->port.membase = hsu->reg + HSU_PORT_REG_OFFSET
-					+ i * HSU_PORT_REG_LENGTH;
-
-		sprintf(uport->name, "hsu_port%d", i);
+		uport->port.mapbase = pci_resource_start(pdev, 0);
+		uport->port.membase = ioremap_nocache(uport->port.mapbase,
+						pci_resource_len(pdev, 0));
+		strcpy(uport->name, cfg->name);
 		uport->port.fifosize = 64;
 		uport->port.ops = &serial_hsu_pops;
-		uport->port.line = i;
+		uport->port.line = index;
 		uport->port.flags = UPF_IOREMAP;
 		/* set the scalable maxim support rate to 2746800 bps */
 		uport->port.uartclk = 115200 * 24 * 16;
+		uport->port.irq = pdev->irq;
+		uport->port.dev = &pdev->dev;
 
 		uport->running = 0;
-		uport->txc = &hsu->chans[i * 2];
-		uport->rxc = &hsu->chans[i * 2 + 1];
+		uport->txc = &phsu->chans[index * 2];
+		uport->rxc = &phsu->chans[index * 2 + 1];
 
-		serial_hsu_ports[i] = uport;
-		uport->index = i;
+		uport->index = index;
 
-		if (hsu_dma_enable & (1<<i))
+		if (hsu_dma_enable & (1<<index))
 			uport->use_dma = 1;
 		else
 			uport->use_dma = 0;
 
-		uport++;
-	}
-
-	/* Initialise 6 dma channels */
-	dchan = hsu->chans;
-	for (i = 0; i < 6; i++) {
-		dchan->id = i;
-		dchan->dirt = (i & 0x1) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
-		dchan->uport = &hsu->port[i/2];
-		dchan->reg = hsu->reg + HSU_DMA_CHANS_REG_OFFSET +
-				i * HSU_DMA_CHANS_REG_LENGTH;
-
-		dchan++;
+		uport->workqueue = create_singlethread_workqueue(uport->name);
+		INIT_WORK(&uport->work, serial_hsu_work);
+		uport->qcirc.buf = (char *)uport->qbuf;
+		spin_lock_init(&uport->cl_lock);
+		ret = request_irq(pdev->irq, port_irq, IRQF_SHARED,
+					uport->name, uport);
+		if (ret) {
+			dev_err(&pdev->dev, "can not get IRQ\n");
+			goto err_disable;
+		}
+		if (cfg->type == debug_port) {
+			serial_hsu_reg.cons = SERIAL_HSU_CONSOLE;
+			serial_hsu_reg.cons->index = index;
+		} else
+			serial_hsu_reg.cons = NULL;
+		uart_add_one_port(&serial_hsu_reg, &uport->port);
+		pci_set_drvdata(pdev, uport);
+		pm_runtime_put_noidle(&pdev->dev);
+		pm_runtime_allow(&pdev->dev);
+
+		if (cfg->has_alt) {
+			struct uart_hsu_port *alt_uport;
+			struct hsu_port_cfg *alt_cfg =
+				hsu_port_func_cfg + cfg->alt;
+			int alt_index = alt_cfg->index;
+
+			phsu->configs[alt_index] = alt_cfg;
+			alt_uport = phsu->port + alt_index;
+			memcpy(alt_uport, uport, sizeof(*uport));
+			alt_uport->port.line = alt_index;
+			strcpy(alt_uport->name, alt_cfg->name);
+			alt_uport->index = alt_index;
+			if (hsu_dma_enable & (1<<alt_index))
+				alt_uport->use_dma = 1;
+			else
+				alt_uport->use_dma = 0;
+			if (alt_cfg->hw_init)
+				alt_cfg->hw_init(alt_index);
+			alt_uport->workqueue =
+				create_singlethread_workqueue(alt_uport->name);
+			INIT_WORK(&alt_uport->work, serial_hsu_work);
+			alt_uport->qcirc.buf = (char *)alt_uport->qbuf;
+			spin_lock_init(&alt_uport->cl_lock);
+			ret = request_irq(pdev->irq, port_irq, IRQF_SHARED,
+						alt_uport->name, alt_uport);
+			if (ret) {
+				dev_err(&pdev->dev, "can not get IRQ\n");
+				goto err_disable;
+			}
+			if (alt_cfg->type == debug_port) {
+				serial_hsu_reg.cons = SERIAL_HSU_CONSOLE;
+				serial_hsu_reg.cons->index = alt_index;
+			} else
+				serial_hsu_reg.cons = NULL;
+			uart_add_one_port(&serial_hsu_reg, &alt_uport->port);
+		}
 	}
 
-	phsu = hsu;
-	hsu_debugfs_init(hsu);
-	return;
-
-err_free_region:
-	release_mem_region(hsu->paddr, hsu->iolen);
-	kfree(hsu);
-	return;
+	return 0;
+err_disable:
+	pci_disable_device(pdev);
+	return ret;
 }
 
 static void serial_hsu_remove(struct pci_dev *pdev)
@@ -1441,7 +1719,7 @@ static void serial_hsu_remove(struct pci_dev *pdev)
 	pm_runtime_get_noresume(&pdev->dev);
 
 	/* For port 0/1/2, priv is the address of uart_hsu_port */
-	if (pdev->device != 0x081E) {
+	if ((pdev->device != 0x081E) && (pdev->device != 0x08FF)) {
 		up = priv;
 		uart_remove_one_port(&serial_hsu_reg, &up->port);
 	}
@@ -1451,18 +1729,23 @@ static void serial_hsu_remove(struct pci_dev *pdev)
 	pci_disable_device(pdev);
 }
 
-/* First 3 are UART ports, and the 4th is the DMA */
-static const struct pci_device_id pci_ids[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x081B) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x081C) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x081D) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x081E) },
+DEFINE_PCI_DEVICE_TABLE(hsu_pci_ids) = {
+	{ PCI_VDEVICE(INTEL, 0x081B), hsu_port0 },
+	{ PCI_VDEVICE(INTEL, 0x081C), hsu_port1 },
+	{ PCI_VDEVICE(INTEL, 0x081D), hsu_port2 },
+	{ PCI_VDEVICE(INTEL, 0x081E), hsu_dma },
+
+	/* Cloverview support */
+	{ PCI_VDEVICE(INTEL, 0x08FC), hsu_port0 },
+	{ PCI_VDEVICE(INTEL, 0x08FD), hsu_port1 },
+	{ PCI_VDEVICE(INTEL, 0x08FE), hsu_port2 },
+	{ PCI_VDEVICE(INTEL, 0x08FF), hsu_dma },
 	{},
 };
 
 static struct pci_driver hsu_pci_driver = {
 	.name =		"HSU serial",
-	.id_table =	pci_ids,
+	.id_table =	hsu_pci_ids,
 	.probe =	serial_hsu_probe,
 	.remove =	serial_hsu_remove,
 	.suspend =	serial_hsu_suspend,
@@ -1476,12 +1759,11 @@ static int __init hsu_pci_init(void)
 {
 	int ret;
 
-	hsu_global_init();
-
 	ret = uart_register_driver(&serial_hsu_reg);
 	if (ret)
 		return ret;
 
+	hsu_debugfs_init(phsu);
 	return pci_register_driver(&hsu_pci_driver);
 }
 
@@ -1489,10 +1771,7 @@ static void __exit hsu_pci_exit(void)
 {
 	pci_unregister_driver(&hsu_pci_driver);
 	uart_unregister_driver(&serial_hsu_reg);
-
 	hsu_debugfs_remove(phsu);
-
-	kfree(phsu);
 }
 
 module_init(hsu_pci_init);
diff --git a/include/linux/serial_mfd.h b/include/linux/serial_mfd.h
index 2b071e0b034d..ca65d8ca8360 100644
--- a/include/linux/serial_mfd.h
+++ b/include/linux/serial_mfd.h
@@ -18,8 +18,8 @@
 #define HSU_GBL_INT_BIT_DMA	0x5
 
 #define HSU_GBL_ISR	0x8
-#define HSU_GBL_DMASR	0x400
-#define HSU_GBL_DMAISR	0x404
+#define HSU_GBL_DMASR	0x000
+#define HSU_GBL_DMAISR	0x004
 
 #define HSU_PORT_REG_OFFSET	0x80
 #define HSU_PORT0_REG_OFFSET	0x80
@@ -27,7 +27,7 @@
 #define HSU_PORT2_REG_OFFSET	0x180
 #define HSU_PORT_REG_LENGTH	0x80
 
-#define HSU_DMA_CHANS_REG_OFFSET	0x500
+#define HSU_DMA_CHANS_REG_OFFSET	0x100
 #define HSU_DMA_CHANS_REG_LENGTH	0x40
 
 #define HSU_CH_SR		0x0	/* channel status reg */
@@ -44,4 +44,11 @@
 #define HSU_CH_D3SAR		0x38
 #define HSU_CH_D3TSR		0x3C
 
+#if defined(CONFIG_X86_MDFLD)
+void mfld_hsu_port1_switch(int on);
+#else
+inline void mfld_hsu_port1_switch(int on)
+{
+}
+#endif
 #endif
-- 
2.37.3

