From a2de74868c070dee97808c7c2fb8b38b6e96bfd5 Mon Sep 17 00:00:00 2001
From: David Cohen <david.a.cohen@intel.com>
Date: Mon, 26 Aug 2013 19:49:18 -0700
Subject: [PATCH 044/429] intel_mid, pci: move pci helper functions to their
 own file

BYT platform may need pci helper functions implemented inside
intel-mid.c file. Since they are not really intel-mid specific, move it
to their own file because BYT does not compile intel-mid.c

Signed-off-by: David Cohen <david.a.cohen@intel.com>
---
 arch/x86/include/asm/intel-mid.h              |  31 +-----
 arch/x86/include/asm/intel_mid_pcihelpers.h   |  25 +++++
 arch/x86/platform/intel-mid/Makefile          |   2 +-
 arch/x86/platform/intel-mid/intel-mid.c       |  94 ----------------
 .../platform/intel-mid/intel_mid_pcihelpers.c | 105 ++++++++++++++++++
 5 files changed, 133 insertions(+), 124 deletions(-)
 create mode 100644 arch/x86/include/asm/intel_mid_pcihelpers.h
 create mode 100644 arch/x86/platform/intel-mid/intel_mid_pcihelpers.c

diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h
index 14303ae334b6..43e73a563894 100644
--- a/arch/x86/include/asm/intel-mid.h
+++ b/arch/x86/include/asm/intel-mid.h
@@ -15,11 +15,7 @@
 #include <linux/pci.h>
 #include <linux/platform_device.h>
 #include <asm/spid.h>
-
-#define INTEL_MID_SSN_SIZE	32
-
-extern struct soft_platform_id spid;
-extern char intel_mid_ssn[INTEL_MID_SSN_SIZE + 1];
+#include <asm/intel_mid_pcihelpers.h>
 
 #ifdef CONFIG_SFI
 extern int get_gpio_by_name(const char *name);
@@ -27,26 +23,6 @@ extern int get_gpio_by_name(const char *name);
 static inline int get_gpio_by_name(const char *name) { return -1; }
 #endif
 
-/*
- * Access to message bus through three registers
- * in CUNIT(0:0:0) PCI configuration space.
- * MSGBUS_CTRL_REG(0xD0):
- *   31:24	= message bus opcode
- *   23:16	= message bus port
- *   15:8	= message bus address, low 8 bits.
- *   7:4	= message bus byte enables
- * MSGBUS_CTRL_EXT_REG(0xD8):
- *   31:8	= message bus address, high 24 bits.
- * MSGBUS_DATA_REG(0xD4):
- *   hold the data for write or read
- */
-#define PCI_ROOT_MSGBUS_CTRL_REG	0xD0
-#define PCI_ROOT_MSGBUS_DATA_REG	0xD4
-#define PCI_ROOT_MSGBUS_CTRL_EXT_REG	0xD8
-#define PCI_ROOT_MSGBUS_READ		0x10
-#define PCI_ROOT_MSGBUS_WRITE		0x11
-#define PCI_ROOT_MSGBUS_DWORD_ENABLE	0xf0
-
 extern int intel_mid_pci_init(void);
 extern void intel_delayed_device_register(void *dev,
 			void (*delayed_callback)(void *dev_desc));
@@ -56,10 +32,7 @@ extern int __init sfi_parse_mrtc(struct sfi_table_header *table);
 extern int __init sfi_parse_mtmr(struct sfi_table_header *table);
 extern int sfi_mrtc_num;
 extern struct sfi_rtc_table_entry sfi_mrtc_array[];
-extern u32 intel_mid_msgbus_read32_raw(u32 cmd);
-extern void intel_mid_msgbus_write32_raw(u32 cmd, u32 data);
-extern u32 intel_mid_msgbus_read32(u8 port, u32 addr);
-extern void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data);
+extern void *get_oem0_table(void);
 extern void register_rpmsg_service(char *name, int id, u32 addr);
 extern int sdhci_pci_request_regulators(void);
 
diff --git a/arch/x86/include/asm/intel_mid_pcihelpers.h b/arch/x86/include/asm/intel_mid_pcihelpers.h
new file mode 100644
index 000000000000..d48026f8014f
--- /dev/null
+++ b/arch/x86/include/asm/intel_mid_pcihelpers.h
@@ -0,0 +1,25 @@
+/*
+ * Access to message bus through three registers
+ * in CUNIT(0:0:0) PCI configuration space.
+ * MSGBUS_CTRL_REG(0xD0):
+ *   31:24      = message bus opcode
+ *   23:16      = message bus port
+ *   15:8       = message bus address, low 8 bits.
+ *   7:4        = message bus byte enables
+ * MSGBUS_CTRL_EXT_REG(0xD8):
+ *   31:8       = message bus address, high 24 bits.
+ * MSGBUS_DATA_REG(0xD4):
+ *   hold the data for write or read
+ */
+#define PCI_ROOT_MSGBUS_CTRL_REG        0xD0
+#define PCI_ROOT_MSGBUS_DATA_REG        0xD4
+#define PCI_ROOT_MSGBUS_CTRL_EXT_REG    0xD8
+#define PCI_ROOT_MSGBUS_READ            0x10
+#define PCI_ROOT_MSGBUS_WRITE           0x11
+#define PCI_ROOT_MSGBUS_DWORD_ENABLE    0xf0
+
+u32 intel_mid_msgbus_read32_raw(u32 cmd);
+u32 intel_mid_msgbus_read32(u8 port, u32 addr);
+void intel_mid_msgbus_write32_raw(u32 cmd, u32 data);
+void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data);
+u32 intel_mid_soc_stepping(void);
diff --git a/arch/x86/platform/intel-mid/Makefile b/arch/x86/platform/intel-mid/Makefile
index cbdda58cff57..916d6c2ddb7a 100644
--- a/arch/x86/platform/intel-mid/Makefile
+++ b/arch/x86/platform/intel-mid/Makefile
@@ -10,7 +10,7 @@ obj-y += device_libs/
 
 # SoC specific files
 obj-$(CONFIG_X86_INTEL_MID) += mfld.o mrfl.o
-obj-$(CONFIG_X86_WANT_INTEL_MID) += vlv2.o
+obj-$(CONFIG_X86_WANT_INTEL_MID) += vlv2.o intel_mid_pcihelpers.o
 obj-$(CONFIG_X86_INTEL_MID) += intel_mid_scu.o
 
 >>>>>>> 6a9f567... intel_mid: Added intel mid scu remoteproc init code.
diff --git a/arch/x86/platform/intel-mid/intel-mid.c b/arch/x86/platform/intel-mid/intel-mid.c
index f03d6e24d9e9..6678cb5780a9 100644
--- a/arch/x86/platform/intel-mid/intel-mid.c
+++ b/arch/x86/platform/intel-mid/intel-mid.c
@@ -80,100 +80,6 @@ static unsigned long __init intel_mid_calibrate_tsc(void)
 {
 	return 0;
 }
-/* Unified message bus read/write operation */
-static DEFINE_SPINLOCK(msgbus_lock);
-
-static struct pci_dev *pci_root;
-
-static int intel_mid_msgbus_init(void)
-{
-	pci_root = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
-	if (!pci_root) {
-		printk(KERN_ALERT "%s: Error: msgbus PCI handle NULL",
-			__func__);
-		return -ENODEV;
-	}
-	return 0;
-}
-
-fs_initcall(intel_mid_msgbus_init);
-
-
-u32 intel_mid_msgbus_read32_raw(u32 cmd)
-{
-	unsigned long irq_flags;
-	u32 data;
-
-	spin_lock_irqsave(&msgbus_lock, irq_flags);
-	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
-	pci_read_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, &data);
-	spin_unlock_irqrestore(&msgbus_lock, irq_flags);
-
-	return data;
-}
-EXPORT_SYMBOL(intel_mid_msgbus_read32_raw);
-
-void intel_mid_msgbus_write32_raw(u32 cmd, u32 data)
-{
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&msgbus_lock, irq_flags);
-	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
-	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
-	spin_unlock_irqrestore(&msgbus_lock, irq_flags);
-}
-EXPORT_SYMBOL(intel_mid_msgbus_write32_raw);
-
-u32 intel_mid_msgbus_read32(u8 port, u32 addr)
-{
-	unsigned long irq_flags;
-	u32 data;
-	u32 cmd;
-	u32 cmdext;
-
-	cmd = (PCI_ROOT_MSGBUS_READ << 24) | (port << 16) |
-		((addr & 0xff) << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
-	cmdext = addr & 0xffffff00;
-
-	spin_lock_irqsave(&msgbus_lock, irq_flags);
-
-	if (cmdext) {
-		/* This resets to 0 automatically, no need to write 0 */
-		pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_EXT_REG,
-			cmdext);
-	}
-
-	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
-	pci_read_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, &data);
-	spin_unlock_irqrestore(&msgbus_lock, irq_flags);
-
-	return data;
-}
-EXPORT_SYMBOL(intel_mid_msgbus_read32);
-
-void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data)
-{
-	unsigned long irq_flags;
-	u32 cmd;
-	u32 cmdext;
-
-	cmd = (PCI_ROOT_MSGBUS_WRITE << 24) | (port << 16) |
-		((addr & 0xFF) << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
-	cmdext = addr & 0xffffff00;
-
-	spin_lock_irqsave(&msgbus_lock, irq_flags);
-	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
-
-	if (cmdext) {
-		/* This resets to 0 automatically, no need to write 0 */
-		pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_EXT_REG,
-			cmdext);
-	}
-
-	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
-	spin_unlock_irqrestore(&msgbus_lock, irq_flags);
-}
-EXPORT_SYMBOL(intel_mid_msgbus_write32);
 
 static void __init intel_mid_time_init(void)
 {
diff --git a/arch/x86/platform/intel-mid/intel_mid_pcihelpers.c b/arch/x86/platform/intel-mid/intel_mid_pcihelpers.c
new file mode 100644
index 000000000000..85d4be8c1858
--- /dev/null
+++ b/arch/x86/platform/intel-mid/intel_mid_pcihelpers.c
@@ -0,0 +1,105 @@
+#include <linux/export.h>
+#include <linux/pci.h>
+
+#include <asm/intel_mid_pcihelpers.h>
+
+/* Unified message bus read/write operation */
+static DEFINE_SPINLOCK(msgbus_lock);
+
+static struct pci_dev *pci_root;
+
+static int intel_mid_msgbus_init(void)
+{
+        pci_root = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
+        if (!pci_root) {
+                printk(KERN_ALERT "%s: Error: msgbus PCI handle NULL",
+                        __func__);
+                return -ENODEV;
+        }
+        return 0;
+}
+fs_initcall(intel_mid_msgbus_init);
+
+u32 intel_mid_msgbus_read32_raw(u32 cmd)
+{
+        unsigned long irq_flags;
+        u32 data;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        pci_read_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, &data);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+
+        return data;
+}
+EXPORT_SYMBOL(intel_mid_msgbus_read32_raw);
+
+void intel_mid_msgbus_write32_raw(u32 cmd, u32 data)
+{
+        unsigned long irq_flags;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+}
+EXPORT_SYMBOL(intel_mid_msgbus_write32_raw);
+
+u32 intel_mid_msgbus_read32(u8 port, u32 addr)
+{
+        unsigned long irq_flags;
+        u32 data;
+        u32 cmd;
+        u32 cmdext;
+
+        cmd = (PCI_ROOT_MSGBUS_READ << 24) | (port << 16) |
+                ((addr & 0xff) << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+        cmdext = addr & 0xffffff00;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+
+        if (cmdext) {
+                /* This resets to 0 automatically, no need to write 0 */
+                pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_EXT_REG,
+                        cmdext);
+        }
+
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        pci_read_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, &data);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+
+        return data;
+}
+
+EXPORT_SYMBOL(intel_mid_msgbus_read32);
+void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data)
+{
+        unsigned long irq_flags;
+        u32 cmd;
+        u32 cmdext;
+
+        cmd = (PCI_ROOT_MSGBUS_WRITE << 24) | (port << 16) |
+                ((addr & 0xFF) << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+        cmdext = addr & 0xffffff00;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
+
+        if (cmdext) {
+                /* This resets to 0 automatically, no need to write 0 */
+                pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_EXT_REG,
+                        cmdext);
+        }
+
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+}
+EXPORT_SYMBOL(intel_mid_msgbus_write32);
+
+/* called only from where is later then fs_initcall */
+u32 intel_mid_soc_stepping(void)
+{
+        return pci_root->revision;
+}
+EXPORT_SYMBOL(intel_mid_soc_stepping);
+
-- 
2.37.3

