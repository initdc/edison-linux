From ed496edd2e353758c795cc8b3bede715386483de Mon Sep 17 00:00:00 2001
From: "Wu, Hao" <hao.wu@intel.com>
Date: Mon, 9 Dec 2013 12:19:40 +0800
Subject: [PATCH 204/429] dwc3_otg: enable GPIO ID detection for BYT CR

This patch enables the ID detection via SOC GPIO,
and send out notification to other drivers.

Signed-off-by: Wu, Hao <hao.wu@intel.com>
---
 drivers/usb/dwc3/dwc3-intel-byt.c  | 152 +++++++++++++++++++++++++++++
 include/linux/usb/dwc3-intel-mid.h |   7 ++
 2 files changed, 159 insertions(+)

diff --git a/drivers/usb/dwc3/dwc3-intel-byt.c b/drivers/usb/dwc3/dwc3-intel-byt.c
index caf0832144b0..96faa73d85c2 100644
--- a/drivers/usb/dwc3/dwc3-intel-byt.c
+++ b/drivers/usb/dwc3/dwc3-intel-byt.c
@@ -208,11 +208,163 @@ static void set_sus_phy(struct dwc_otg2 *otg, int bit)
 	otg_write(otg, GUSB3PIPECTL0, data);
 }
 
+static int dwc3_check_gpio_id(struct dwc_otg2 *otg2)
+{
+	struct dwc_otg2 *otg = dwc3_get_otg();
+	struct intel_dwc_otg_pdata *data;
+	int id = 0;
+	int next = 0;
+	int count = 0;
+	unsigned long timeout;
+
+	otg_dbg(otg, "start check gpio id\n");
+
+	data = (struct intel_dwc_otg_pdata *)otg->otg_data;
+
+	/* Polling ID GPIO PIN value for SW debounce as HW debouce chip
+	 * is not connected on BYT CR board */
+	if (data && data->gpio_id) {
+		id = gpio_get_value(data->gpio_id);
+
+		/* If get 20 of the same value in a row by GPIO read,
+		 * then end SW debouce and return the ID value.
+		 * the total length of debouce time is 80ms~100ms for
+		 * 20 times GPIO read on BYT CR, which is longer than
+		 * normal debounce time done by HW chip.
+		 * Also set 200ms timeout value to avoid impact from
+		 * pin unstable cases */
+		timeout = jiffies + msecs_to_jiffies(200);
+		while ((count < 20) && (!time_after(jiffies, timeout))) {
+			next = gpio_get_value(data->gpio_id);
+			otg_dbg(otg, "id value pin %d = %d\n",
+				data->gpio_id, next);
+			if (next < 0)
+				return -EINVAL;
+			else if (id == next)
+				count++;
+			else {
+				id = next;
+				count = 0;
+			}
+		}
+		if (count >= 20) {
+			otg_dbg(otg, "id debounce done = %d\n", id);
+			return id;
+		}
+	}
+
+	return -ENODEV;
+}
+
+static irqreturn_t dwc3_gpio_id_irq(int irq, void *dev)
+{
+	struct dwc_otg2 *otg = dwc3_get_otg();
+	struct intel_dwc_otg_pdata *data;
+	int id;
+
+	data = (struct intel_dwc_otg_pdata *)otg->otg_data;
+
+	id = dwc3_check_gpio_id(otg);
+	if (id == 0 || id == 1) {
+		if (data->id != id) {
+			data->id = id;
+			dev_info(otg->dev, "ID notification (id = %d)\n",
+					data->id);
+			atomic_notifier_call_chain(&otg->usb2_phy.notifier,
+				USB_EVENT_ID, &id);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void dwc_otg_suspend_discon_work(struct work_struct *work)
+{
+	struct dwc_otg2 *otg = dwc3_get_otg();
+	unsigned long flags;
+
+	otg_dbg(otg, "start suspend_disconn work\n");
+
+	spin_lock_irqsave(&otg->lock, flags);
+	otg->otg_events |= OEVT_A_DEV_SESS_END_DET_EVNT;
+	otg->otg_events &= ~OEVT_B_DEV_SES_VLD_DET_EVNT;
+	dwc3_wakeup_otg_thread(otg);
+	spin_unlock_irqrestore(&otg->lock, flags);
+}
+
 int dwc3_intel_byt_platform_init(struct dwc_otg2 *otg)
 {
 	u32 gctl;
+	int id_value;
 	int retval;
 
+	data = (struct intel_dwc_otg_pdata *)otg->otg_data;
+
+	if (data)
+		INIT_DELAYED_WORK(&data->suspend_discon_work,
+			dwc_otg_suspend_discon_work);
+
+	if (data && data->gpio_cs && data->gpio_reset) {
+		retval = gpio_request(data->gpio_cs, "phy_cs");
+		if (retval < 0) {
+			otg_err(otg, "failed to request CS pin %d\n",
+					data->gpio_cs);
+			return retval;
+		}
+
+		retval = gpio_request(data->gpio_reset, "phy_reset");
+		if (retval < 0) {
+			otg_err(otg, "failed to request RESET pin %d\n",
+					data->gpio_reset);
+			return retval;
+		}
+	}
+
+	if (data && data->gpio_id) {
+		dev_info(otg->dev,  "USB ID detection - Enabled - GPIO\n");
+
+		/* Set ID default value to 1 Floating */
+		data->id = 1;
+
+		retval = gpio_request(data->gpio_id, "gpio_id");
+		if (retval < 0) {
+			otg_err(otg, "failed to request ID pin %d\n",
+					data->gpio_id);
+			return retval;
+		}
+
+		retval = gpio_direction_input(data->gpio_id);
+		if (retval < 0) {
+			otg_err(otg, "failed to request ID pin %d\n",
+					data->gpio_id);
+			return retval;
+		}
+
+		retval = request_threaded_irq(gpio_to_irq(data->gpio_id),
+				NULL, dwc3_gpio_id_irq,
+				IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING |
+				IRQF_ONESHOT, "dwc-gpio-id", otg->dev);
+
+		if (retval < 0) {
+			otg_err(otg, "failed to request interrupt gpio ID\n");
+			return retval;
+		}
+
+		otg_dbg(otg, "GPIO ID request/Interrupt reuqest Done\n");
+
+		id_value = dwc3_check_gpio_id(otg);
+		if ((id_value == 0 || id_value == 1) &&
+					(data->id != id_value)) {
+			data->id = id_value;
+			dev_info(otg->dev, "ID notification (id = %d)\n",
+						data->id);
+
+			atomic_notifier_call_chain(&otg->usb2_phy.notifier,
+					USB_EVENT_ID, &id_value);
+		} else
+			otg_dbg(otg, "Get incorrect ID value %d\n", id_value);
+	}
+
 	/* Don't let phy go to suspend mode, which
 	 * will cause FS/LS devices enum failed in host mode.
 	 */
diff --git a/include/linux/usb/dwc3-intel-mid.h b/include/linux/usb/dwc3-intel-mid.h
index f8168313cf98..70c337f3fe72 100644
--- a/include/linux/usb/dwc3-intel-mid.h
+++ b/include/linux/usb/dwc3-intel-mid.h
@@ -24,6 +24,13 @@
 
 struct intel_dwc_otg_pdata {
 	int is_hvp;
+	enum intel_mid_pmic_type pmic_type;
+	int charger_detect_enable;
+	int gpio_cs;
+	int gpio_reset;
+	int gpio_id;
+	int id;
+	int charging_compliance;
 };
 
 #define TUSB1211_VENDOR_ID_LO					0x00
-- 
2.37.3

